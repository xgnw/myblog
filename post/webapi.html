<!doctype html><html lang=zh-cn data-theme=light><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.102.3"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple-touch-icon.png><meta itemprop=name content="WebApi"><meta itemprop=description content="有钱说什么都是硬道理，没钱说什么都是吹牛逼。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://blog.jiandan.cf/imgs/babiwawa.png"><meta itemprop=keywords content="爸比娃娃,博客,Hugo,NexT,主题,简单,强大"><meta property="og:type" content="article"><meta property="og:title" content="WebApi"><meta property="og:description" content="有钱说什么都是硬道理，没钱说什么都是吹牛逼。"><meta property="og:image" content="/imgs/babiwawa.png"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://blog.jiandan.cf/post/webapi.html"><meta property="og:site_name" content="爸比娃娃的自留地"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="爸比娃娃"><meta property="article:published_time" content="2023-08-28 21:52:03 +0800 CST"><meta property="article:modified_time" content="2023-08-28 21:52:03 +0800 CST"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.2722a1f9d585b77a08019811b3140da8196bdb769cba16e8f1cc25aa393ba6c5.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":true,"isHome":false,"isPage":true,"path":"webapi.html","permalink":"https://blog.jiandan.cf/post/webapi.html","title":"WebApi","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>WebApi - 爸比娃娃的自留地</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>爸比娃娃的自留地</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>我是一个吃苦耐劳的享乐主义者。</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-flinks"><a href=/flinks.html class=hvr-icon-pulse rel=section><i class="fa fa-thumbs-up hvr-icon"></i>友情链接</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>20</span></a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#webapi>WebApi</a></li><li><a href=#canvas-api>Canvas API</a><ul><li><a href=#概述>概述</a></li><li><a href=#canvas-api绘制图形>Canvas API：绘制图形</a><ul><li><a href=#路径>路径</a></li><li><a href=#线型>线型</a></li><li><a href=#矩形>矩形</a></li><li><a href=#弧线>弧线</a></li><li><a href=#文本>文本</a></li><li><a href=#渐变色和图像填充>渐变色和图像填充</a></li><li><a href=#阴影>阴影</a></li></ul></li><li><a href=#canvas-api图像处理>Canvas API：图像处理</a><ul><li><a href=#canvasrenderingcontext2ddrawimage>CanvasRenderingContext2D.drawImage()</a></li><li><a href=#像素读写>像素读写</a></li><li><a href=#canvasrenderingcontext2dsavecanvasrenderingcontext2drestore>CanvasRenderingContext2D.save()，CanvasRenderingContext2D.restore()</a></li><li><a href=#canvasrenderingcontext2dcanvas>CanvasRenderingContext2D.canvas</a></li><li><a href=#图像变换>图像变换</a></li></ul></li><li><a href=#canvas-元素的方法><code>&lt;canvas></code> 元素的方法</a><ul><li><a href=#htmlcanvaselementtodataurl>HTMLCanvasElement.toDataURL()</a></li><li><a href=#htmlcanvaselementtoblob>HTMLCanvasElement.toBlob()</a></li></ul></li><li><a href=#canvas-使用实例>Canvas 使用实例</a><ul><li><a href=#动画效果>动画效果</a></li><li><a href=#像素处理>像素处理</a></li></ul></li><li><a href=#参考链接>参考链接</a></li></ul></li><li><a href=#剪贴板操作-clipboard-api-教程>剪贴板操作 Clipboard API 教程</a><ul><li><a href=#简介>简介</a></li><li><a href=#documentexeccommand-方法>Document.execCommand() 方法</a></li><li><a href=#异步-clipboard-api>异步 Clipboard API</a></li><li><a href=#clipboard-对象>Clipboard 对象</a><ul><li><a href=#clipboardreadtext>Clipboard.readText()</a></li><li><a href=#clipboardread>Clipboard.read()</a></li><li><a href=#clipboardwritetext>Clipboard.writeText()</a></li><li><a href=#clipboardwrite>Clipboard.write()</a></li></ul></li><li><a href=#copy-事件cut-事件>copy 事件，cut 事件</a></li><li><a href=#paste-事件>paste 事件</a></li><li><a href=#参考链接-1>参考链接</a></li></ul></li><li><a href=#fetch-api-教程>Fetch API 教程</a><ul><li><a href=#基本用法>基本用法</a></li><li><a href=#response-对象处理-http-回应>Response 对象：处理 HTTP 回应</a><ul><li><a href=#response-对象的同步属性>Response 对象的同步属性</a></li><li><a href=#判断请求是否成功>判断请求是否成功</a></li><li><a href=#responseheaders-属性>Response.headers 属性</a></li><li><a href=#读取内容的方法>读取内容的方法</a></li><li><a href=#responseclone>Response.clone()</a></li><li><a href=#responsebody-属性>Response.body 属性</a></li></ul></li><li><a href=#fetch的第二个参数定制-http-请求><code>fetch()</code>的第二个参数：定制 HTTP 请求</a></li><li><a href=#fetch配置对象的完整-api><code>fetch()</code>配置对象的完整 API</a></li><li><a href=#取消fetch请求>取消<code>fetch()</code>请求</a></li><li><a href=#参考链接-2>参考链接</a></li></ul></li><li><a href=#fontface-api>FontFace API</a></li><li><a href=#geolocation-api>Geolocation API</a><ul><li><a href=#geolocation-对象>Geolocation 对象</a><ul><li><a href=#geolocationgetcurrentposition>Geolocation.getCurrentPosition()</a></li><li><a href=#geolocationwatchposition>Geolocation.watchPosition()</a></li><li><a href=#geolocationclearwatch>Geolocation.clearWatch()</a></li></ul></li><li><a href=#coordinates-对象>Coordinates 对象</a></li><li><a href=#参考链接-3>参考链接</a></li></ul></li><li><a href=#intersectionobserver>IntersectionObserver</a><ul><li><a href=#简介-1>简介</a></li><li><a href=#intersectionobserverobserve>IntersectionObserver.observe()</a><ul><li><a href=#callback-参数>callback 参数</a></li><li><a href=#intersectionobserverentry-对象>IntersectionObserverEntry 对象</a></li><li><a href=#option-对象>Option 对象</a></li></ul></li><li><a href=#实例>实例</a><ul><li><a href=#惰性加载lazy-load>惰性加载（lazy load）</a></li><li><a href=#无限滚动>无限滚动</a></li><li><a href=#视频自动播放>视频自动播放</a></li></ul></li><li><a href=#参考链接-4>参考链接</a></li></ul></li><li><a href=#intlrelativetimeformat>Intl.RelativeTimeFormat</a><ul><li><a href=#基本用法-1>基本用法</a></li><li><a href=#intlrelativetimeformatprototypeformat>Intl.RelativeTimeFormat.prototype.format()</a></li><li><a href=#intlrelativetimeformatprototypeformattoparts>Intl.RelativeTimeFormat.prototype.formatToParts()</a></li><li><a href=#参考链接-5>参考链接</a></li></ul></li><li><a href=#offline-应用>Offline 应用</a></li><li><a href=#page-lifecycle-api>Page Lifecycle API</a><ul><li><a href=#生命周期阶段>生命周期阶段</a></li><li><a href=#常见场景>常见场景</a></li><li><a href=#事件>事件</a><ul><li><a href=#focus-事件>focus 事件</a></li><li><a href=#blur-事件>blur 事件</a></li><li><a href=#visibilitychange-事件>visibilitychange 事件</a></li><li><a href=#freeze-事件>freeze 事件</a></li><li><a href=#resume-事件>resume 事件</a></li><li><a href=#pageshow-事件>pageshow 事件</a></li><li><a href=#pagehide-事件>pagehide 事件</a></li><li><a href=#beforeunload-事件>beforeunload 事件</a></li><li><a href=#unload-事件>unload 事件</a></li></ul></li><li><a href=#获取当前阶段>获取当前阶段</a></li><li><a href=#documentwasdiscarded>document.wasDiscarded</a></li><li><a href=#参考链接-6>参考链接</a></li></ul></li><li><a href=#page-visibility-api>Page Visibility API</a><ul><li><a href=#简介-2>简介</a></li><li><a href=#documentvisibilitystate>document.visibilityState</a></li><li><a href=#documenthidden>document.hidden</a></li><li><a href=#visibilitychange-事件-1>visibilitychange 事件</a></li><li><a href=#页面卸载>页面卸载</a></li><li><a href=#参考链接-7>参考链接</a></li></ul></li><li><a href=#point-lock-api>Point lock API</a></li><li><a href=#server-sent-events>Server-Sent Events</a><ul><li><a href=#简介-3>简介</a></li><li><a href=#与-websocket-的比较>与 WebSocket 的比较</a></li><li><a href=#客户端-api>客户端 API</a><ul><li><a href=#eventsource-对象>EventSource 对象</a></li><li><a href=#readystate-属性>readyState 属性</a></li><li><a href=#url-属性>url 属性</a></li><li><a href=#withcredentials-属性>withCredentials 属性</a></li><li><a href=#onopen-属性>onopen 属性</a></li><li><a href=#onmessage-属性>onmessage 属性</a></li><li><a href=#onerror-属性>onerror 属性</a></li><li><a href=#自定义事件>自定义事件</a></li><li><a href=#close-方法>close() 方法</a></li></ul></li><li><a href=#服务器实现>服务器实现</a><ul><li><a href=#数据格式>数据格式</a></li><li><a href=#data-字段>data 字段</a></li><li><a href=#id-字段>id 字段</a></li><li><a href=#event-字段>event 字段</a></li><li><a href=#retry-字段>retry 字段</a></li></ul></li><li><a href=#node-服务器实例>Node 服务器实例</a></li><li><a href=#参考链接-8>参考链接</a></li></ul></li><li><a href=#service-worker>Service Worker</a><ul><li><a href=#含义>含义</a></li><li><a href=#使用步骤>使用步骤</a><ul><li><a href=#登记>登记</a></li><li><a href=#安装>安装</a></li><li><a href=#激活>激活</a></li></ul></li><li><a href=#service-worker-与网页的通信>Service Worker 与网页的通信</a></li><li><a href=#参考链接-9>参考链接</a></li></ul></li><li><a href=#svg-图像>SVG 图像</a><ul><li><a href=#概述-1>概述</a></li><li><a href=#语法>语法</a><ul><li><a href=#svg标签><code>&lt;svg></code>标签</a></li><li><a href=#circle标签><code>&lt;circle></code>标签</a></li><li><a href=#line标签><code>&lt;line></code>标签</a></li><li><a href=#polyline标签><code>&lt;polyline></code>标签</a></li><li><a href=#rect标签><code>&lt;rect></code>标签</a></li><li><a href=#ellipse标签><code>&lt;ellipse></code>标签</a></li><li><a href=#polygon标签><code>&lt;polygon></code>标签</a></li><li><a href=#path标签><code>&lt;path></code>标签</a></li><li><a href=#text标签><code>&lt;text></code>标签</a></li><li><a href=#use标签><code>&lt;use></code>标签</a></li><li><a href=#g标签><code>&lt;g></code>标签</a></li><li><a href=#defs标签><code>&lt;defs></code>标签</a></li><li><a href=#pattern标签><code>&lt;pattern></code>标签</a></li><li><a href=#image标签><code>&lt;image></code>标签</a></li><li><a href=#animate标签><code>&lt;animate></code>标签</a></li><li><a href=#animatetransform标签><code>&lt;animateTransform></code>标签</a></li></ul></li><li><a href=#javascript-操作>JavaScript 操作</a><ul><li><a href=#dom-操作>DOM 操作</a></li><li><a href=#获取-svg-dom>获取 SVG DOM</a></li><li><a href=#读取-svg-源码>读取 SVG 源码</a></li><li><a href=#svg-图像转为-canvas-图像>SVG 图像转为 Canvas 图像</a></li></ul></li><li><a href=#实例折线图>实例：折线图</a></li><li><a href=#参考链接-10>参考链接</a></li></ul></li><li><a href=#web-share-api>Web Share API</a><ul><li><a href=#概述-2>概述</a></li><li><a href=#接口细节>接口细节</a></li><li><a href=#分享文件>分享文件</a></li><li><a href=#参考链接-11>参考链接</a></li></ul></li><li><a href=#web-audio-api>Web Audio API</a><ul><li><a href=#基本用法-2>基本用法</a></li><li><a href=#contextcreatebuffer>context.createBuffer()</a></li><li><a href=#过滤器>过滤器</a></li></ul></li><li><a href=#web-components>Web Components</a><ul><li><a href=#概述-3>概述</a></li><li><a href=#custom-element>Custom Element</a><ul><li><a href=#简介-4>简介</a></li><li><a href=#生命周期方法>生命周期方法</a></li><li><a href=#自定义属性和方法>自定义属性和方法</a></li><li><a href=#windowcustomelementswhendefined>window.customElements.whenDefined()</a></li><li><a href=#回调函数>回调函数</a></li><li><a href=#custom-element-的子元素>Custom Element 的子元素</a></li></ul></li><li><a href=#template标签><code>&lt;template></code>标签</a><ul><li><a href=#基本用法-3>基本用法</a></li><li><a href=#documentimportnode>document.importNode()</a></li></ul></li><li><a href=#shadow-dom>Shadow DOM</a></li><li><a href=#html-import>HTML Import</a><ul><li><a href=#基本操作>基本操作</a></li><li><a href=#脚本的执行>脚本的执行</a></li><li><a href=#web-component的封装>Web Component的封装</a></li></ul></li><li><a href=#polymerjs>Polymer.js</a><ul><li><a href=#直接使用的组件>直接使用的组件</a></li><li><a href=#安装-1>安装</a></li><li><a href=#自定义组件>自定义组件</a></li><li><a href=#组件的使用方法>组件的使用方法</a></li></ul></li><li><a href=#参考链接-12>参考链接</a></li></ul></li><li><a href=#websocket>WebSocket</a><ul><li><a href=#简介-5>简介</a></li><li><a href=#websocket-握手>WebSocket 握手</a></li><li><a href=#客户端的简单示例>客户端的简单示例</a></li><li><a href=#客户端-api-1>客户端 API</a><ul><li><a href=#构造函数-websocket>构造函数 WebSocket</a></li><li><a href=#websocketreadystate>webSocket.readyState</a></li><li><a href=#websocketonopen>webSocket.onopen</a></li><li><a href=#websocketonclose>webSocket.onclose</a></li><li><a href=#websocketonmessage>webSocket.onmessage</a></li><li><a href=#websocketsend>webSocket.send()</a></li><li><a href=#websocketbufferedamount>webSocket.bufferedAmount</a></li><li><a href=#websocketonerror>webSocket.onerror</a></li></ul></li><li><a href=#websocket-服务器>WebSocket 服务器</a></li><li><a href=#参考链接-13>参考链接</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=爸比娃娃 src=/imgs/img-lazy-loading.gif data-src=/imgs/babiwawa.png><p class=site-author-name itemprop=name>爸比娃娃</p><div class=site-description itemprop=description>有钱说什么都是硬道理，没钱说什么都是吹牛逼。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>20</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>6</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>27</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/babiwawa title="Github → https://github.com/babiwawa" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github</a></span>
<span class=links-of-social-item><a href=mailto:1223112302@qq.com title="E-Mail → mailto:1223112302@qq.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail</a></span>
<span class=links-of-social-item><a href=https://www.zhihu.com/people/hbalnw title="知乎 → https://www.zhihu.com/people/hbalnw" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎</a></span>
<span class=links-of-social-item><a href="http://wpa.qq.com/msgrd?v=3&uin=1223112302&site=qq&menu=yes" title="Q Q → http://wpa.qq.com/msgrd?v=3&uin=1223112302&site=qq&menu=yes" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa-brands fa-qq fa-fw hvr-icon"></i>
Q Q</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://jiandan.cf title=https://jiandan.cf target=_blank>简单导航</a></li><li class=links-of-blogroll-item><a href=https://lisenhui.cn title=https://lisenhui.cn target=_blank>凡梦星尘空间站</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate=2005-01-02T11:52:03+08:00></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=184177></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=379></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate=2023-08-28T21:52:03+08:00></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=goto-gtranslate class=button title=直达底部><i class="fas fa-arrow-down"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a>
<a href=https://github.com/babiwawa rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script>
<script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://blog.jiandan.cf/post/webapi.html><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/babiwawa.png"><meta itemprop=name content="爸比娃娃"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="爸比娃娃"><meta itemprop=description content="有钱说什么都是硬道理，没钱说什么都是吹牛逼。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="WebApi"><meta itemprop=description content="WebApi 这个只作为一个了解就可以了 Canvas API 概述 <canvas>元素用于生成图像。它本身就像一个画布，JavaScript 通过操作它的 API"></span><header class=post-header><h1 class=post-title itemprop="name headline">WebApi</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text title=发表于>发表于：</span>
<time title="创建时间：2023-08-28 21:52:03 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-08-28 21:52:03 +0800 CST">2023-08-28</time></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>字数：</span>
<span>54017</span></span>
<span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i></span>
<span class=post-meta-item-text>阅读：&ap;</span>
<span>108分钟</span></span>
<span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i></span>
<span class=post-meta-item-text>浏览：</span>
<span id=busuanzi_value_page_pv data-path=/post/webapi.html><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><h2 id=webapi>WebApi
<a class=header-anchor href=#webapi></a></h2><p>这个只作为一个了解就可以了</p><h2 id=canvas-api>Canvas API
<a class=header-anchor href=#canvas-api></a></h2><h3 id=概述>概述
<a class=header-anchor href=#%e6%a6%82%e8%bf%b0></a></h3><p><code>&lt;canvas></code>元素用于生成图像。它本身就像一个画布，JavaScript 通过操作它的 API，在上面生成图像。它的底层是一个个像素，基本上<code>&lt;canvas></code>是一个可以用 JavaScript 操作的位图（bitmap）。</p><p>它与 SVG 图像的区别在于，<code>&lt;canvas></code>是脚本调用各种方法生成图像，SVG 则是一个 XML 文件，通过各种子元素生成图像。</p><p>使用 Canvas API 之前，需要在网页里面新建一个<code>&lt;canvas></code>元素。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>canvas</span> <span style=color:#a6e22e>id</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;myCanvas&#34;</span> <span style=color:#a6e22e>width</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;400&#34;</span> <span style=color:#a6e22e>height</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;250&#34;</span>&gt;
</span></span><span style=display:flex><span>  您的浏览器不支持 Canvas
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>canvas</span>&gt;
</span></span></code></pre></div><p>如果浏览器不支持这个 API，就会显示<code>&lt;canvas></code>标签中间的文字：“您的浏览器不支持 Canvas”。</p><p>每个<code>&lt;canvas></code>元素都有一个对应的<code>CanvasRenderingContext2D</code>对象（上下文对象）。Canvas API 就定义在这个对象上面。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span></code></pre></div><p>上面代码中，<code>&lt;canvas></code>元素节点对象的<code>getContext()</code>方法，返回的就是<code>CanvasRenderingContext2D</code>对象。</p><p>注意，Canvas API 需要<code>getContext</code>方法指定参数<code>2d</code>，表示该<code>&lt;canvas></code>节点生成 2D 的平面图像。如果参数是<code>webgl</code>，就表示用于生成 3D 的立体图案，这部分属于 WebGL API。</p><p>按照用途，Canvas API 分成两大部分：绘制图形和图像处理。</p><h3 id=canvas-api绘制图形>Canvas API：绘制图形
<a class=header-anchor href=#canvas-api%e7%bb%98%e5%88%b6%e5%9b%be%e5%bd%a2></a></h3><p>Canvas 画布提供了一个作图的平面空间，该空间的每个点都有自己的坐标。原点<code>(0, 0)</code>位于图像左上角，<code>x</code>轴的正向是原点向右，<code>y</code>轴的正向是原点向下。</p><h4 id=路径>路径
<a class=header-anchor href=#%e8%b7%af%e5%be%84></a></h4><p>以下方法和属性用来绘制路径。</p><ul><li><code>CanvasRenderingContext2D.beginPath()</code>：开始绘制路径。</li><li><code>CanvasRenderingContext2D.closePath()</code>：结束路径，返回到当前路径的起始点，会从当前点到起始点绘制一条直线。如果图形已经封闭，或者只有一个点，那么此方法不会产生任何效果。</li><li><code>CanvasRenderingContext2D.moveTo()</code>：设置路径的起点，即将一个新路径的起始点移动到<code>(x，y)</code>坐标。</li><li><code>CanvasRenderingContext2D.lineTo()</code>：使用直线从当前点连接到<code>(x, y)</code>坐标。</li><li><code>CanvasRenderingContext2D.fill()</code>：在路径内部填充颜色（默认为黑色）。</li><li><code>CanvasRenderingContext2D.stroke()</code>：路径线条着色（默认为黑色）。</li><li><code>CanvasRenderingContext2D.fillStyle</code>：指定路径填充的颜色和样式（默认为黑色）。</li><li><code>CanvasRenderingContext2D.strokeStyle</code>：指定路径线条的颜色和样式（默认为黑色）。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>beginPath</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>moveTo</span>(<span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>lineTo</span>(<span style=color:#ae81ff>200</span>, <span style=color:#ae81ff>200</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>lineTo</span>(<span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>200</span>);
</span></span></code></pre></div><p>上面代码只是确定了路径的形状，画布上还看不出来，因为没有颜色。所以还需要着色。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fill</span>()
</span></span><span style=display:flex><span><span style=color:#75715e>// 或者
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>stroke</span>()
</span></span></code></pre></div><p>上面代码中，这两个方法都可以使得路径可见。<code>fill()</code>在路径内部填充颜色，使之变成一个实心的图形；<code>stroke()</code>只对路径线条着色。</p><p>这两个方法默认都是使用黑色，可以使用<code>fillStyle</code>和<code>strokeStyle</code>属性指定其他颜色。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillStyle</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;red&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fill</span>();
</span></span><span style=display:flex><span><span style=color:#75715e>// 或者
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>strokeStyle</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;red&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>stroke</span>();
</span></span></code></pre></div><p>上面代码将填充和线条的颜色指定为红色。</p><h4 id=线型>线型
<a class=header-anchor href=#%e7%ba%bf%e5%9e%8b></a></h4><p>以下的方法和属性控制线条的视觉特征。</p><ul><li><code>CanvasRenderingContext2D.lineWidth</code>：指定线条的宽度，默认为1.0。</li><li><code>CanvasRenderingContext2D.lineCap</code>：指定线条末端的样式，有三个可能的值：<code>butt</code>（默认值，末端为矩形）、<code>round</code>（末端为圆形）、<code>square</code>（末端为突出的矩形，矩形宽度不变，高度为线条宽度的一半）。</li><li><code>CanvasRenderingContext2D.lineJoin</code>：指定线段交点的样式，有三个可能的值：<code>round</code>（交点为扇形）、<code>bevel</code>（交点为三角形底边）、<code>miter</code>（默认值，交点为菱形)。</li><li><code>CanvasRenderingContext2D.miterLimit</code>：指定交点菱形的长度，默认为10。该属性只在<code>lineJoin</code>属性的值等于<code>miter</code>时有效。</li><li><code>CanvasRenderingContext2D.getLineDash()</code>：返回一个数组，表示虚线里面线段和间距的长度。</li><li><code>CanvasRenderingContext2D.setLineDash()</code>：数组，用于指定虚线里面线段和间距的长度。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>beginPath</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>moveTo</span>(<span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>lineTo</span>(<span style=color:#ae81ff>200</span>, <span style=color:#ae81ff>200</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>lineTo</span>(<span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>200</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>lineWidth</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>lineCap</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;round&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>lineJoin</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;round&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>setLineDash</span>([<span style=color:#ae81ff>15</span>, <span style=color:#ae81ff>5</span>]);
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>stroke</span>();
</span></span></code></pre></div><p>上面代码中，线条的宽度为3，线条的末端和交点都改成圆角，并且设置为虚线。</p><h4 id=矩形>矩形
<a class=header-anchor href=#%e7%9f%a9%e5%bd%a2></a></h4><p>以下方法用来绘制矩形。</p><ul><li><code>CanvasRenderingContext2D.rect()</code>：绘制矩形路径。</li><li><code>CanvasRenderingContext2D.fillRect()</code>：填充一个矩形。</li><li><code>CanvasRenderingContext2D.strokeRect()</code>：绘制矩形边框。</li><li><code>CanvasRenderingContext2D.clearRect()</code>：指定矩形区域的像素都变成透明。</li></ul><p>上面四个方法的格式都一样，都接受四个参数，分别是矩形左上角的横坐标和纵坐标、矩形的宽和高。</p><p><code>CanvasRenderingContext2D.rect()</code>方法用于绘制矩形路径。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>rect</span>(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fill</span>();
</span></span></code></pre></div><p>上面代码绘制一个正方形，左上角坐标为<code>(10, 10)</code>，宽和高都为100。</p><p><code>CanvasRenderingContext2D.fillRect()</code>用来向一个矩形区域填充颜色。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillStyle</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;green&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillRect</span>(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>100</span>);
</span></span></code></pre></div><p>上面代码绘制一个绿色的正方形，左上角坐标为<code>(10, 10)</code>，宽和高都为100。</p><p><code>CanvasRenderingContext2D.strokeRect()</code>用来绘制一个矩形区域的边框。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>strokeStyle</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;green&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>strokeRect</span>(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>100</span>);
</span></span></code></pre></div><p>上面代码绘制一个绿色的空心正方形，左上角坐标为<code>(10, 10)</code>，宽和高都为100。</p><p><code>CanvasRenderingContext2D.clearRect()</code>用于擦除指定矩形区域的像素颜色，等同于把早先的绘制效果都去除。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillRect</span>(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>clearRect</span>(<span style=color:#ae81ff>15</span>, <span style=color:#ae81ff>15</span>, <span style=color:#ae81ff>90</span>, <span style=color:#ae81ff>90</span>);
</span></span></code></pre></div><p>上面代码先绘制一个 100 x 100 的正方形，然后在它的内部擦除 90 x 90 的区域，等同于形成了一个5像素宽度的边框。</p><h4 id=弧线>弧线
<a class=header-anchor href=#%e5%bc%a7%e7%ba%bf></a></h4><p>以下方法用于绘制弧形。</p><ul><li><code>CanvasRenderingContext2D.arc()</code>：通过指定圆心和半径绘制弧形。</li><li><code>CanvasRenderingContext2D.arcTo()</code>：通过指定两根切线和半径绘制弧形。</li></ul><p><code>CanvasRenderingContext2D.arc()</code>主要用来绘制圆形或扇形。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 格式
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>arc</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>, <span style=color:#a6e22e>radius</span>, <span style=color:#a6e22e>startAngle</span>, <span style=color:#a6e22e>endAngle</span>, <span style=color:#a6e22e>anticlockwise</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 实例
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>arc</span>(<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> Math.<span style=color:#a6e22e>PI</span>, <span style=color:#66d9ef>true</span>)
</span></span></code></pre></div><p><code>arc()</code>方法的<code>x</code>和<code>y</code>参数是圆心坐标，<code>radius</code>是半径，<code>startAngle</code>和<code>endAngle</code>则是扇形的起始角度和终止角度（以弧度表示），<code>anticlockwise</code>表示做图时应该逆时针画（<code>true</code>）还是顺时针画（<code>false</code>），这个参数用来控制扇形的方向（比如上半圆还是下半圆）。</p><p>下面是绘制实心圆形的例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>beginPath</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>arc</span>(<span style=color:#ae81ff>60</span>, <span style=color:#ae81ff>60</span>, <span style=color:#ae81ff>50</span>, <span style=color:#ae81ff>0</span>, Math.<span style=color:#a6e22e>PI</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>, <span style=color:#66d9ef>true</span>); 
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fill</span>();
</span></span></code></pre></div><p>上面代码绘制了一个半径50，起始角度为0，终止角度为 2 * PI 的完整的圆。</p><p>绘制空心半圆的例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>beginPath</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>moveTo</span>(<span style=color:#ae81ff>50</span>, <span style=color:#ae81ff>20</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>arc</span>(<span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>20</span>, <span style=color:#ae81ff>50</span>, <span style=color:#ae81ff>0</span>, Math.<span style=color:#a6e22e>PI</span>, <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>stroke</span>();
</span></span></code></pre></div><p><code>CanvasRenderingContext2D.arcTo()</code>方法主要用来绘制圆弧，需要给出两个点的坐标，当前点与第一个点形成一条直线，第一个点与第二个点形成另一条直线，然后画出与这两根直线相切的弧线。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>beginPath</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>moveTo</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>arcTo</span>(<span style=color:#ae81ff>50</span>, <span style=color:#ae81ff>50</span>, <span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>25</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>lineTo</span>(<span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>stroke</span>();
</span></span></code></pre></div><p>上面代码中，<code>arcTo()</code>有5个参数，前两个参数是第一个点的坐标，第三个参数和第四个参数是第二个点的坐标，第五个参数是半径。然后，<code>(0, 0)</code>与<code>(50, 50)</code>形成一条直线，然后<code>(50, 50)</code>与<code>(100, 0)</code>形成第二条直线。弧线就是与这两根直线相切的部分。</p><h4 id=文本>文本
<a class=header-anchor href=#%e6%96%87%e6%9c%ac></a></h4><p>以下方法和属性用于绘制文本。</p><ul><li><code>CanvasRenderingContext2D.fillText()</code>：在指定位置绘制实心字符。</li><li><code>CanvasRenderingContext2D.strokeText()</code>：在指定位置绘制空心字符。</li><li><code>CanvasRenderingContext2D.measureText()</code>：返回一个 TextMetrics 对象。</li><li><code>CanvasRenderingContext2D.font</code>：指定字型大小和字体，默认值为<code>10px sans-serif</code>。</li><li><code>CanvasRenderingContext2D.textAlign</code>：文本的对齐方式，默认值为<code>start</code>。</li><li><code>CanvasRenderingContext2D.direction</code>：文本的方向，默认值为<code>inherit</code>。</li><li><code>CanvasRenderingContext2D.textBaseline</code>：文本的垂直位置，默认值为<code>alphabetic</code>。</li></ul><p><code>fillText()</code>方法用来在指定位置绘制实心字符。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>CanvasRenderingContext2D</span>.<span style=color:#a6e22e>fillText</span>(<span style=color:#a6e22e>text</span>, <span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span> [, <span style=color:#a6e22e>maxWidth</span>])
</span></span></code></pre></div><p>该方法接受四个参数。</p><ul><li><code>text</code>：所要填充的字符串。</li><li><code>x</code>：文字起点的横坐标，单位像素。</li><li><code>y</code>：文字起点的纵坐标，单位像素。</li><li><code>maxWidth</code>：文本的最大像素宽度。该参数可选，如果省略，则表示宽度没有限制。如果文本实际长度超过这个参数指定的值，那么浏览器将尝试用较小的字体填充。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillText</span>(<span style=color:#e6db74>&#39;Hello world&#39;</span>, <span style=color:#ae81ff>50</span>, <span style=color:#ae81ff>50</span>);
</span></span></code></pre></div><p>上面代码在<code>(50, 50)</code>位置写入字符串<code>Hello world</code>。</p><p>注意，<code>fillText()</code>方法不支持文本断行，所有文本一定出现在一行内。如果要生成多行文本，只有调用多次<code>fillText()</code>方法。</p><p><code>strokeText()</code>方法用来添加空心字符，它的参数与<code>fillText()</code>一致。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>strokeText</span>(<span style=color:#e6db74>&#39;Hello world&#39;</span>, <span style=color:#ae81ff>50</span>, <span style=color:#ae81ff>50</span>);
</span></span></code></pre></div><p>上面这两种方法绘制的文本，默认都是<code>10px</code>大小、<code>sans-serif</code>字体，<code>font</code>属性可以改变字体设置。该属性的值是一个字符串，使用 CSS 的<code>font</code>属性即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>font</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Bold 20px Arial&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillText</span>(<span style=color:#e6db74>&#39;Hello world&#39;</span>, <span style=color:#ae81ff>50</span>, <span style=color:#ae81ff>50</span>);
</span></span></code></pre></div><p><code>textAlign</code>属性用来指定文本的对齐方式。它可以取以下几个值。</p><ul><li><code>left</code>：左对齐</li><li><code>right</code>：右对齐</li><li><code>center</code>：居中</li><li><code>start</code>：默认值，起点对齐（从左到右的文本为左对齐，从右到左的文本为右对齐）。</li><li><code>end</code>：结尾对齐（从左到右的文本为右对齐，从右到左的文本为左对齐）。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>font</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Bold 20px Arial&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>textAlign</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;center&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillText</span>(<span style=color:#e6db74>&#39;Hello world&#39;</span>, <span style=color:#ae81ff>50</span>, <span style=color:#ae81ff>50</span>);
</span></span></code></pre></div><p><code>direction</code>属性指定文本的方向，默认值为<code>inherit</code>，表示继承<code>&lt;canvas></code>或<code>document</code>的设置。其他值包括<code>ltr</code>（从左到右）和<code>rtl</code>（从右到左）。</p><p><code>textBaseline</code>属性指定文本的垂直位置，可以取以下值。</p><ul><li><code>top</code>：上部对齐（字母的基线是整体上移）。</li><li><code>hanging</code>：悬挂对齐（字母的上沿在一根直线上），适用于印度文和藏文。</li><li><code>middle</code>：中部对齐（字母的中线在一根直线上）。</li><li><code>alphabetic</code>：默认值，表示字母位于字母表的正常位置（四线格的第三根线）。</li><li><code>ideographic</code>：下沿对齐（字母的下沿在一根直线上），使用于东亚文字。</li><li><code>bottom</code>：底部对齐（字母的基线下移）。对于英文字母，这个设置与<code>ideographic</code>没有差异。</li></ul><p><code>measureText()</code>方法接受一个字符串作为参数，返回一个 TextMetrics 对象，可以从这个对象上面获取参数字符串的信息，目前主要是文本渲染后的宽度（<code>width</code>）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>text1</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>measureText</span>(<span style=color:#e6db74>&#39;Hello world&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>text1</span>.<span style=color:#a6e22e>width</span> <span style=color:#75715e>// 49.46
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>font</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Bold 20px Arial&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>text2</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>measureText</span>(<span style=color:#e6db74>&#39;Hello world&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>text2</span>.<span style=color:#a6e22e>width</span> <span style=color:#75715e>// 107.78
</span></span></span></code></pre></div><p>上面代码中，<code>10px</code>大小的字符串<code>Hello world</code>，渲染后宽度为<code>49.46</code>。放大到<code>20px</code>以后，宽度为<code>107.78</code>。</p><h4 id=渐变色和图像填充>渐变色和图像填充
<a class=header-anchor href=#%e6%b8%90%e5%8f%98%e8%89%b2%e5%92%8c%e5%9b%be%e5%83%8f%e5%a1%ab%e5%85%85></a></h4><p>以下方法用于设置渐变效果和图像填充效果。</p><ul><li><code>CanvasRenderingContext2D.createLinearGradient()</code>：定义线性渐变样式。</li><li><code>CanvasRenderingContext2D.createRadialGradient()</code>：定义辐射渐变样式。</li><li><code>CanvasRenderingContext2D.createPattern()</code>：定义图像填充样式。</li></ul><p><code>createLinearGradient()</code>方法按照给定直线，生成线性渐变的样式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>createLinearGradient</span>(<span style=color:#a6e22e>x0</span>, <span style=color:#a6e22e>y0</span>, <span style=color:#a6e22e>x1</span>, <span style=color:#a6e22e>y1</span>)
</span></span></code></pre></div><p><code>ctx.createLinearGradient(x0, y0, x1, y1)</code>方法接受四个参数：<code>x0</code>和<code>y0</code>是起点的横坐标和纵坐标，<code>x1</code>和<code>y1</code>是终点的横坐标和纵坐标。通过不同的坐标值，可以生成从上至下、从左到右的渐变等等。</p><p>该方法的返回值是一个<code>CanvasGradient</code>对象，该对象只有一个<code>addColorStop()</code>方向，用来指定渐变点的颜色。<code>addColorStop()</code>方法接受两个参数，第一个参数是0到1之间的一个位置量，0表示起点，1表示终点，第二个参数是一个字符串，表示 CSS 颜色。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>gradient</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>createLinearGradient</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>200</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>gradient</span>.<span style=color:#a6e22e>addColorStop</span>(<span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#39;green&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>gradient</span>.<span style=color:#a6e22e>addColorStop</span>(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#39;white&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillStyle</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>gradient</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillRect</span>(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>200</span>, <span style=color:#ae81ff>100</span>);
</span></span></code></pre></div><p>上面代码中，定义了渐变样式<code>gradient</code>以后，将这个样式指定给<code>fillStyle</code>属性，然后<code>fillRect()</code>就会生成以这个样式填充的矩形区域。</p><p><code>createRadialGradient()</code>方法定义一个辐射渐变，需要指定两个圆。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>createRadialGradient</span>(<span style=color:#a6e22e>x0</span>, <span style=color:#a6e22e>y0</span>, <span style=color:#a6e22e>r0</span>, <span style=color:#a6e22e>x1</span>, <span style=color:#a6e22e>y1</span>, <span style=color:#a6e22e>r1</span>)
</span></span></code></pre></div><p><code>createRadialGradient()</code>方法接受六个参数，<code>x0</code>和<code>y0</code>是辐射起始的圆的圆心坐标，<code>r0</code>是起始圆的半径，<code>x1</code>和<code>y1</code>是辐射终止的圆的圆心坐标，<code>r1</code>是终止圆的半径。</p><p>该方法的返回值也是一个<code>CanvasGradient</code>对象。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>gradient</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>createRadialGradient</span>(<span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>50</span>, <span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>gradient</span>.<span style=color:#a6e22e>addColorStop</span>(<span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#39;white&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>gradient</span>.<span style=color:#a6e22e>addColorStop</span>(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#39;green&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillStyle</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>gradient</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillRect</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>200</span>, <span style=color:#ae81ff>200</span>);
</span></span></code></pre></div><p>上面代码中，生成辐射样式以后，用这个样式填充一个矩形。</p><p><code>createPattern()</code>方法定义一个图像填充样式，在指定方向上不断重复该图像，填充指定的区域。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>createPattern</span>(<span style=color:#a6e22e>image</span>, <span style=color:#a6e22e>repetition</span>)
</span></span></code></pre></div><p>该方法接受两个参数，第一个参数是图像数据，它可以是<code>&lt;img></code>元素，也可以是另一个<code>&lt;canvas></code>元素，或者一个表示图像的 Blob 对象。第二个参数是一个字符串，有四个可能的值，分别是<code>repeat</code>（双向重复）、<code>repeat-x</code>(水平重复)、<code>repeat-y</code>(垂直重复)、<code>no-repeat</code>(不重复)。如果第二个参数是空字符串或<code>null</code>，则等同于<code>null</code>。</p><p>该方法的返回值是一个<code>CanvasPattern</code>对象。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>img</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Image</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>src</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;https://example.com/pattern.png&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>onload</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>( ) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>pattern</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>createPattern</span>(<span style=color:#a6e22e>img</span>, <span style=color:#e6db74>&#39;repeat&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillStyle</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>pattern</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillRect</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>400</span>, <span style=color:#ae81ff>400</span>);
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>上面代码中，图像加载成功以后，使用<code>createPattern()</code>生成图像样式，然后使用这个样式填充指定区域。</p><h4 id=阴影>阴影
<a class=header-anchor href=#%e9%98%b4%e5%bd%b1></a></h4><p>以下属性用于设置阴影。</p><ul><li><code>CanvasRenderingContext2D.shadowBlur</code>：阴影的模糊程度，默认为<code>0</code>。</li><li><code>CanvasRenderingContext2D.shadowColor</code>：阴影的颜色，默认为<code>black</code>。</li><li><code>CanvasRenderingContext2D.shadowOffsetX</code>：阴影的水平位移，默认为<code>0</code>。</li><li><code>CanvasRenderingContext2D.shadowOffsetY</code>：阴影的垂直位移，默认为<code>0</code>。</li></ul><p>下面是一个例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>shadowOffsetX</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>shadowOffsetY</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>shadowBlur</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>shadowColor</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;rgba(0,0,0,0.5)&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillStyle</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;green&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillRect</span>(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>100</span>);
</span></span></code></pre></div><h3 id=canvas-api图像处理>Canvas API：图像处理
<a class=header-anchor href=#canvas-api%e5%9b%be%e5%83%8f%e5%a4%84%e7%90%86></a></h3><h4 id=canvasrenderingcontext2ddrawimage>CanvasRenderingContext2D.drawImage()
<a class=header-anchor href=#canvasrenderingcontext2ddrawimage></a></h4><p>Canvas API 允许将图像文件写入画布，做法是读取图片后，使用<code>drawImage()</code>方法将这张图片放上画布。</p><p><code>CanvasRenderingContext2D.drawImage()</code>有三种使用格式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>drawImage</span>(<span style=color:#a6e22e>image</span>, <span style=color:#a6e22e>dx</span>, <span style=color:#a6e22e>dy</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>drawImage</span>(<span style=color:#a6e22e>image</span>, <span style=color:#a6e22e>dx</span>, <span style=color:#a6e22e>dy</span>, <span style=color:#a6e22e>dWidth</span>, <span style=color:#a6e22e>dHeight</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>drawImage</span>(<span style=color:#a6e22e>image</span>, <span style=color:#a6e22e>sx</span>, <span style=color:#a6e22e>sy</span>, <span style=color:#a6e22e>sWidth</span>, <span style=color:#a6e22e>sHeight</span>, <span style=color:#a6e22e>dx</span>, <span style=color:#a6e22e>dy</span>, <span style=color:#a6e22e>dWidth</span>, <span style=color:#a6e22e>dHeight</span>);
</span></span></code></pre></div><p>各个参数的含义如下。</p><ul><li>image：图像元素</li><li>sx：图像内部的横坐标，用于映射到画布的放置点上。</li><li>sy：图像内部的纵坐标，用于映射到画布的放置点上。</li><li>sWidth：图像在画布上的宽度，会产生缩放效果。如果未指定，则图像不会缩放，按照实际大小占据画布的宽度。</li><li>sHeight：图像在画布上的高度，会产生缩放效果。如果未指定，则图像不会缩放，按照实际大小占据画布的高度。</li><li>dx：画布内部的横坐标，用于放置图像的左上角</li><li>dy：画布内部的纵坐标，用于放置图像的右上角</li><li>dWidth：图像在画布内部的宽度，会产生缩放效果。</li><li>dHeight：图像在画布内部的高度，会产生缩放效果。</li></ul><p>下面是最简单的使用场景，将图像放在画布上，两者左上角对齐。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>img</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Image</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>src</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;image.png&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>onload</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> () {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>drawImage</span>(<span style=color:#a6e22e>img</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>上面代码将一个 PNG 图像放入画布。这时，图像将是原始大小，如果画布小于图像，就会只显示出图像左上角，正好等于画布大小的那一块。</p><p>如果要显示完整的图片，可以用图像的宽和高，设置成画布的宽和高。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>image</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Image</span>(<span style=color:#ae81ff>60</span>, <span style=color:#ae81ff>45</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>image</span>.<span style=color:#a6e22e>onload</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>drawImageActualSize</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>image</span>.<span style=color:#a6e22e>src</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;https://example.com/image.jpg&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>drawImageActualSize</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>width</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>naturalWidth</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>height</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>naturalHeight</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>drawImage</span>(<span style=color:#66d9ef>this</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>naturalWidth</span>, <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>naturalHeight</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码中，<code>&lt;canvas></code>元素的大小设置成图像的本来大小，就能保证完整展示图像。由于图像的本来大小，只有图像加载成功以后才能拿到，因此调整画布的大小，必须放在<code>image.onload</code>这个监听函数里面。</p><h4 id=像素读写>像素读写
<a class=header-anchor href=#%e5%83%8f%e7%b4%a0%e8%af%bb%e5%86%99></a></h4><p>以下三个方法与像素读写相关。</p><ul><li><code>CanvasRenderingContext2D.getImageData()</code>：将画布读取成一个 ImageData 对象</li><li><code>CanvasRenderingContext2D.putImageData()</code>：将 ImageData 对象写入画布</li><li><code>CanvasRenderingContext2D.createImageData()</code>：生成 ImageData 对象</li></ul><p><strong>（1）getImageData()</strong></p><p><code>CanvasRenderingContext2D.getImageData()</code>方法用来读取<code>&lt;canvas></code>的内容，返回一个 ImageData 对象，包含了每个像素的信息。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>getImageData</span>(<span style=color:#a6e22e>sx</span>, <span style=color:#a6e22e>sy</span>, <span style=color:#a6e22e>sw</span>, <span style=color:#a6e22e>sh</span>)
</span></span></code></pre></div><p><code>getImageData()</code>方法接受四个参数。<code>sx</code>和<code>sy</code>是读取区域的左上角坐标，<code>sw</code>和<code>sh</code>是读取区域的宽度和高度。如果想要读取整个<code>&lt;canvas></code>区域，可以写成下面这样。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>imageData</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>getImageData</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>width</span>, <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>height</span>);
</span></span></code></pre></div><p><code>getImageData()</code>方法返回的是一个<code>ImageData</code>对象。该对象有三个属性。</p><ul><li>ImageData.data：一个一维数组。该数组的值，依次是每个像素的红、绿、蓝、alpha 通道值（每个值的范围是 0～255），因此该数组的长度等于<code>图像的像素宽度 x 图像的像素高度 x 4</code>。这个数组不仅可读，而且可写，因此通过操作这个数组，就可以达到操作图像的目的。</li><li>ImageData.width：浮点数，表示 ImageData 的像素宽度。</li><li>ImageData.height：浮点数，表示 ImageData 的像素高度。</li></ul><p><strong>（2）putImageData()</strong></p><p><code>CanvasRenderingContext2D.putImageData()</code>方法将<code>ImageData</code>对象的像素绘制在<code>&lt;canvas></code>画布上。该方法有两种使用格式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>putImageData</span>(<span style=color:#a6e22e>imagedata</span>, <span style=color:#a6e22e>dx</span>, <span style=color:#a6e22e>dy</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>putImageData</span>(<span style=color:#a6e22e>imagedata</span>, <span style=color:#a6e22e>dx</span>, <span style=color:#a6e22e>dy</span>, <span style=color:#a6e22e>dirtyX</span>, <span style=color:#a6e22e>dirtyY</span>, <span style=color:#a6e22e>dirtyWidth</span>, <span style=color:#a6e22e>dirtyHeight</span>)
</span></span></code></pre></div><p>该方法有如下参数。</p><ul><li>imagedata：包含像素信息的 ImageData 对象。</li><li>dx：<code>&lt;canvas></code>元素内部的横坐标，用于放置 ImageData 图像的左上角。</li><li>dy：<code>&lt;canvas></code>元素内部的纵坐标，用于放置 ImageData 图像的左上角。</li><li>dirtyX：ImageData 图像内部的横坐标，用于作为放置到<code>&lt;canvas></code>的矩形区域的左上角的横坐标，默认为0。</li><li>dirtyY：ImageData 图像内部的纵坐标，用于作为放置到<code>&lt;canvas></code>的矩形区域的左上角的纵坐标，默认为0。</li><li>dirtyWidth：放置到<code>&lt;canvas></code>的矩形区域的宽度，默认为 ImageData 图像的宽度。</li><li>dirtyHeight：放置到<code>&lt;canvas></code>的矩形区域的高度，默认为 ImageData 图像的高度。</li></ul><p>下面是将 ImageData 对象绘制到<code>&lt;canvas></code>的例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>putImageData</span>(<span style=color:#a6e22e>imageData</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span></code></pre></div><p><strong>（3）createImageData()</strong></p><p><code>CanvasRenderingContext2D.createImageData()</code>方法用于生成一个空的<code>ImageData</code>对象，所有像素都是透明的黑色（即每个值都是<code>0</code>）。该方法有两种使用格式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>createImageData</span>(<span style=color:#a6e22e>width</span>, <span style=color:#a6e22e>height</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>createImageData</span>(<span style=color:#a6e22e>imagedata</span>)
</span></span></code></pre></div><p><code>createImageData()</code>方法的参数如下。</p><ul><li>width：ImageData 对象的宽度，单位为像素。</li><li>height：ImageData 对象的高度，单位为像素。</li><li>imagedata：一个现有的 ImageData 对象，返回值将是这个对象的拷贝。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>imageData</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>createImageData</span>(<span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>100</span>);
</span></span></code></pre></div><p>上面代码中，<code>imageData</code>是一个 100 x 100 的像素区域，其中每个像素都是透明的黑色。</p><h4 id=canvasrenderingcontext2dsavecanvasrenderingcontext2drestore>CanvasRenderingContext2D.save()，CanvasRenderingContext2D.restore()
<a class=header-anchor href=#canvasrenderingcontext2dsavecanvasrenderingcontext2drestore></a></h4><p><code>CanvasRenderingContext2D.save()</code>方法用于将画布的当前样式保存到堆栈，相当于在内存之中产生一个样式快照。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>save</span>();
</span></span></code></pre></div><p>上面代码中，<code>save()</code>会为画布的默认样式产生一个快照。</p><p><code>CanvasRenderingContext2D.restore()</code>方法将画布的样式恢复到上一个保存的快照，如果没有已保存的快照，则不产生任何效果。</p><p>上下文环境，restore方法用于恢复到上一次保存的上下文环境。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>save</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillStyle</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;green&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>restore</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillRect</span>(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>100</span>);
</span></span></code></pre></div><p>上面代码画一个矩形。矩形的填充色本来设为绿色，但是<code>restore()</code>方法撤销了这个设置，将样式恢复上一次保存的状态（即默认样式），所以实际的填充色是黑色（默认颜色）。</p><h4 id=canvasrenderingcontext2dcanvas>CanvasRenderingContext2D.canvas
<a class=header-anchor href=#canvasrenderingcontext2dcanvas></a></h4><p><code>CanvasRenderingContext2D.canvas</code>属性指向当前<code>CanvasRenderingContext2D</code>对象所在的<code>&lt;canvas></code>元素。该属性只读。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>canvas</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>canvas</span> <span style=color:#75715e>// true
</span></span></span></code></pre></div><h4 id=图像变换>图像变换
<a class=header-anchor href=#%e5%9b%be%e5%83%8f%e5%8f%98%e6%8d%a2></a></h4><p>以下方法用于图像变换。</p><ul><li><code>CanvasRenderingContext2D.rotate()</code>：图像旋转</li><li><code>CanvasRenderingContext2D.scale()</code>：图像缩放</li><li><code>CanvasRenderingContext2D.translate()</code>：图像平移</li><li><code>CanvasRenderingContext2D.transform()</code>：通过一个变换矩阵完成图像变换</li><li><code>CanvasRenderingContext2D.setTransform()</code>：取消前面的图像变换</li></ul><p><strong>（1）rotate()</strong></p><p><code>CanvasRenderingContext2D.rotate()</code>方法用于图像旋转。它接受一个弧度值作为参数，表示顺时针旋转的度数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>rotate</span>(<span style=color:#ae81ff>45</span> <span style=color:#f92672>*</span> Math.<span style=color:#a6e22e>PI</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>180</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillRect</span>(<span style=color:#ae81ff>70</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>30</span>);
</span></span></code></pre></div><p>上面代码会显示一个顺时针倾斜45度的矩形。注意，<code>rotate()</code>方法必须在<code>fillRect()</code>方法之前调用，否则是不起作用的。</p><p>旋转中心点始终是画布左上角的原点。如果要更改中心点，需要使用<code>translate()</code>方法移动画布。</p><p><strong>（2）scale()</strong></p><p><code>CanvasRenderingContext2D.scale()</code>方法用于缩放图像。它接受两个参数，分别是<code>x</code>轴方向的缩放因子和<code>y</code>轴方向的缩放因子。默认情况下，一个单位就是一个像素，缩放因子可以缩放单位，比如缩放因子<code>0.5</code>表示将大小缩小为原来的50%，缩放因子<code>10</code>表示放大十倍。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>scale</span>(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillRect</span>(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>);
</span></span></code></pre></div><p>上面代码中，原来的矩形是 10 x 10，缩放后展示出来是 100 x 30。</p><p>如果缩放因子为1，就表示图像没有任何缩放。如果为-1，则表示方向翻转。<code>ctx.scale(-1, 1)</code>为水平翻转，<code>ctx.scale(1, -1)</code>表示垂直翻转。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>scale</span>(<span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>font</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;16px serif&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillText</span>(<span style=color:#e6db74>&#39;Hello world!&#39;</span>, <span style=color:#ae81ff>20</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>20</span>);
</span></span></code></pre></div><p>上面代码会显示一个水平倒转的、高度放大2倍的<code>Hello World!</code>。</p><p>注意，负向缩放本质是坐标翻转，所针对的坐标轴就是画布左上角原点的坐标轴。</p><p><strong>（3）translate()</strong></p><p><code>CanvasRenderingContext2D.translate()</code>方法用于平移图像。它接受两个参数，分别是 x 轴和 y 轴移动的距离（单位像素）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>translate</span>(<span style=color:#ae81ff>50</span>, <span style=color:#ae81ff>50</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillRect</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>100</span>);
</span></span></code></pre></div><p><strong>（4）transform()</strong></p><p><code>CanvasRenderingContext2D.transform()</code>方法接受一个变换矩阵的六个元素作为参数，完成缩放、旋转、移动和倾斜等变形。</p><p>它的使用格式如下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>transform</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>d</span>, <span style=color:#a6e22e>e</span>, <span style=color:#a6e22e>f</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>a:水平缩放(默认值1，单位倍数)
</span></span></span><span style=display:flex><span><span style=color:#75715e>b:水平倾斜(默认值0，单位弧度)
</span></span></span><span style=display:flex><span><span style=color:#75715e>c:垂直倾斜(默认值0，单位弧度)
</span></span></span><span style=display:flex><span><span style=color:#75715e>d:垂直缩放(默认值1，单位倍数)
</span></span></span><span style=display:flex><span><span style=color:#75715e>e:水平位移(默认值0，单位像素)
</span></span></span><span style=display:flex><span><span style=color:#75715e>f:垂直位移(默认值0，单位像素)
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><p>下面是一个例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>transform</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>50</span>, <span style=color:#ae81ff>50</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillRect</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>100</span>);
</span></span></code></pre></div><p>上面代码中，原始图形是 100 x 100 的矩形，结果缩放成 200 x 100 的矩形，并且左上角从<code>(0, 0)</code>移动到<code>(50, 50)</code>。</p><p>注意，多个<code>transform()</code>方法具有叠加效果。</p><p><strong>（5）setTransform()</strong></p><p><code>CanvasRenderingContext2D.setTransform()</code>方法取消前面的图形变换，将画布恢复到该方法指定的状态。该方法的参数与<code>transform()</code>方法完全一致。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>translate</span>(<span style=color:#ae81ff>50</span>, <span style=color:#ae81ff>50</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillRect</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>setTransform</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillRect</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>100</span>);
</span></span></code></pre></div><p>上面代码中，第一个<code>fillRect()</code>方法绘制的矩形，左上角从<code>(0, 0)</code>平移到<code>(50, 50)</code>。<code>setTransform()</code>方法取消了这个变换（已绘制的图形不受影响），将画布恢复到默认状态（变换矩形<code>1, 0, 0, 1, 0, 0</code>），所以第二个矩形的左上角回到<code>(0, 0)</code>。</p><h3 id=canvas-元素的方法><code>&lt;canvas></code> 元素的方法
<a class=header-anchor href=#canvas-%e5%85%83%e7%b4%a0%e7%9a%84%e6%96%b9%e6%b3%95></a></h3><p>除了<code>CanvasRenderingContext2D</code>对象提供的方法，<code>&lt;canvas></code>元素本身也有自己的方法。</p><h4 id=htmlcanvaselementtodataurl>HTMLCanvasElement.toDataURL()
<a class=header-anchor href=#htmlcanvaselementtodataurl></a></h4><p><code>&lt;canvas></code>元素的<code>toDataURL()</code>方法，可以将 Canvas 数据转为 Data URI 格式的图像。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>toDataURL</span>(<span style=color:#a6e22e>type</span>, <span style=color:#a6e22e>quality</span>)
</span></span></code></pre></div><p><code>toDataURL()</code>方法接受两个参数。</p><ul><li>type：字符串，表示图像的格式。默认为<code>image/png</code>，另一个可用的值是<code>image/jpeg</code>，Chrome 浏览器还可以使用<code>image/webp</code>。</li><li>quality：浮点数，0到1之间，表示 JPEG 和 WebP 图像的质量系数，默认值为0.92。</li></ul><p>该方法的返回值是一个 Data URI 格式的字符串。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>convertCanvasToImage</span>(<span style=color:#a6e22e>canvas</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>image</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Image</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>image</span>.<span style=color:#a6e22e>src</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>toDataURL</span>(<span style=color:#e6db74>&#39;image/png&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>image</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的代码将<code>&lt;canvas></code>元素，转化成PNG Data URI。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>fullQuality</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>toDataURL</span>(<span style=color:#e6db74>&#39;image/jpeg&#39;</span>, <span style=color:#ae81ff>0.9</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>mediumQuality</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>toDataURL</span>(<span style=color:#e6db74>&#39;image/jpeg&#39;</span>, <span style=color:#ae81ff>0.6</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>lowQuality</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>toDataURL</span>(<span style=color:#e6db74>&#39;image/jpeg&#39;</span>, <span style=color:#ae81ff>0.3</span>);
</span></span></code></pre></div><p>上面代码将<code>&lt;canvas></code>元素转成高画质、中画质、低画质三种 JPEG 图像。</p><h4 id=htmlcanvaselementtoblob>HTMLCanvasElement.toBlob()
<a class=header-anchor href=#htmlcanvaselementtoblob></a></h4><p><code>HTMLCanvasElement.toBlob()</code>方法用于将<code>&lt;canvas></code>图像转成一个 Blob 对象，默认类型是<code>image/png</code>。它的使用格式如下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 格式
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>toBlob</span>(<span style=color:#a6e22e>callback</span>, <span style=color:#a6e22e>mimeType</span>, <span style=color:#a6e22e>quality</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 示例
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>toBlob</span>(<span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>blob</span>) {...}, <span style=color:#e6db74>&#39;image/jpeg&#39;</span>, <span style=color:#ae81ff>0.95</span>)
</span></span></code></pre></div><p><code>toBlob()</code>方法可以接受三个参数。</p><ul><li>callback：回调函数。它接受生成的 Blob 对象作为参数。</li><li>mimeType：字符串，图像的 MIMEType 类型，默认是<code>image/png</code>。</li><li>quality：浮点数，0到1之间，表示图像的质量，只对<code>image/jpeg</code>和<code>image/webp</code>类型的图像有效。</li></ul><p>注意，该方法没有返回值。</p><p>下面的例子将<code>&lt;canvas></code>图像复制成<code>&lt;img></code>图像。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>blobToImg</span>(<span style=color:#a6e22e>blob</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>newImg</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>createElement</span>(<span style=color:#e6db74>&#39;img&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>url</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>createObjectURL</span>(<span style=color:#a6e22e>blob</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>newImg</span>.<span style=color:#a6e22e>onload</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> () {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 使用完毕，释放 URL 对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>revokeObjectURL</span>(<span style=color:#a6e22e>url</span>);
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>newImg</span>.<span style=color:#a6e22e>src</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>url</span>;
</span></span><span style=display:flex><span>  document.<span style=color:#a6e22e>body</span>.<span style=color:#a6e22e>appendChild</span>(<span style=color:#a6e22e>newImg</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>toBlob</span>(<span style=color:#a6e22e>blobToImg</span>);
</span></span></code></pre></div><h3 id=canvas-使用实例>Canvas 使用实例
<a class=header-anchor href=#canvas-%e4%bd%bf%e7%94%a8%e5%ae%9e%e4%be%8b></a></h3><h4 id=动画效果>动画效果
<a class=header-anchor href=#%e5%8a%a8%e7%94%bb%e6%95%88%e6%9e%9c></a></h4><p>通过改变坐标，很容易在画布 Canvas 元素上产生动画效果。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;myCanvas&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>posX</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>posY</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>setInterval</span>(<span style=color:#66d9ef>function</span> () {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillStyle</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;black&#39;</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillRect</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>width</span>, <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>height</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>posX</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>posY</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>0.25</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>beginPath</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillStyle</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;white&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>arc</span>(<span style=color:#a6e22e>posX</span>, <span style=color:#a6e22e>posY</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>0</span>, Math.<span style=color:#a6e22e>PI</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>closePath</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fill</span>();
</span></span><span style=display:flex><span>}, <span style=color:#ae81ff>30</span>);
</span></span></code></pre></div><p>上面代码会产生一个小圆点，每隔30毫秒就向右下方移动的效果。<code>setInterval()</code>函数的一开始，之所以要将画布重新渲染黑色底色，是为了抹去上一步的小圆点。</p><p>在这个例子的基础上，通过设置圆心坐标，可以产生各种运动轨迹。下面是先上升后下降的例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>vx</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>vy</span> <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>gravity</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>setInterval</span>(<span style=color:#66d9ef>function</span> () {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>posX</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>vx</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>posY</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>vy</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>vy</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>gravity</span>;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>});
</span></span></code></pre></div><p>上面代码中，<code>x</code>坐标始终增大，表示持续向右运动。<code>y</code>坐标先变小，然后在重力作用下，不断增大，表示先上升后下降。</p><h4 id=像素处理>像素处理
<a class=header-anchor href=#%e5%83%8f%e7%b4%a0%e5%a4%84%e7%90%86></a></h4><p>通过<code>getImageData()</code>方法和<code>putImageData()</code>方法，可以处理每个像素，进而操作图像内容，因此可以改写图像。</p><p>下面是图像处理的通用写法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>width</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>height</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>imageData</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>getImageData</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>width</span>, <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>height</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>filter</span>(<span style=color:#a6e22e>imageData</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>putImageData</span>(<span style=color:#a6e22e>imageData</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码中，<code>filter</code>是一个处理像素的函数。以下是几种常见的<code>filter</code>。</p><p><strong>（1）灰度效果</strong></p><p>灰度图（grayscale）就是取红、绿、蓝三个像素值的算术平均值，这实际上将图像转成了黑白形式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>grayscale</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>pixels</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>d</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>pixels</span>.<span style=color:#a6e22e>data</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>length</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>4</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>r</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>d</span>[<span style=color:#a6e22e>i</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>g</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>d</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>d</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>d</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>d</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>d</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> (<span style=color:#a6e22e>r</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>g</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>b</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>pixels</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>上面代码中，<code>d[i]</code>是红色值，<code>d[i+1]</code>是绿色值，<code>d[i+2]</code>是蓝色值，<code>d[i+3]</code>是 alpha 通道值。转成灰度的算法，就是将红、绿、蓝三个值相加后除以3，再将结果写回数组。</p><p><strong>（2）复古效果</strong></p><p>复古效果（sepia）是将红、绿、蓝三种值，分别取这三个值的某种加权平均值，使得图像有一种古旧的效果。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>sepia</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>pixels</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>d</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>pixels</span>.<span style=color:#a6e22e>data</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>length</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>4</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>r</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>d</span>[<span style=color:#a6e22e>i</span>];
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>g</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>d</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>d</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>d</span>[<span style=color:#a6e22e>i</span>]     <span style=color:#f92672>=</span> (<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.393</span>) <span style=color:#f92672>+</span> (<span style=color:#a6e22e>g</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.769</span>) <span style=color:#f92672>+</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.189</span>); <span style=color:#75715e>// red
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>d</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> (<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.349</span>) <span style=color:#f92672>+</span> (<span style=color:#a6e22e>g</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.686</span>) <span style=color:#f92672>+</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.168</span>); <span style=color:#75715e>// green
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>d</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> (<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.272</span>) <span style=color:#f92672>+</span> (<span style=color:#a6e22e>g</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.534</span>) <span style=color:#f92672>+</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.131</span>); <span style=color:#75715e>// blue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>pixels</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><strong>（3）红色蒙版效果</strong></p><p>红色蒙版指的是，让图像呈现一种偏红的效果。算法是将红色通道设为红、绿、蓝三个值的平均值，而将绿色通道和蓝色通道都设为0。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>red</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>pixels</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>d</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>pixels</span>.<span style=color:#a6e22e>data</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>length</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>4</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>r</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>d</span>[<span style=color:#a6e22e>i</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>g</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>d</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>d</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>d</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>=</span> (<span style=color:#a6e22e>r</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>g</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>b</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>3</span>;        <span style=color:#75715e>// 红色通道取平均值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>d</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>d</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// 绿色通道和蓝色通道都设为0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>pixels</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><strong>（4）亮度效果</strong></p><p>亮度效果（brightness）是指让图像变得更亮或更暗。算法将红色通道、绿色通道、蓝色通道，同时加上一个正值或负值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>brightness</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>pixels</span>, <span style=color:#a6e22e>delta</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>d</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>pixels</span>.<span style=color:#a6e22e>data</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>length</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>4</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>d</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>+=</span> <span style=color:#a6e22e>delta</span>;     <span style=color:#75715e>// red
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>d</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+=</span> <span style=color:#a6e22e>delta</span>; <span style=color:#75715e>// green
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>d</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>] <span style=color:#f92672>+=</span> <span style=color:#a6e22e>delta</span>; <span style=color:#75715e>// blue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>pixels</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><strong>（5）反转效果</strong></p><p>反转效果（invert）是指图片呈现一种色彩颠倒的效果。算法为红、绿、蓝通道都取各自的相反值（<code>255 - 原值</code>）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>invert</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>pixels</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>d</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>pixels</span>.<span style=color:#a6e22e>data</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>length</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>4</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>d</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>255</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>d</span>[<span style=color:#a6e22e>i</span>];
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>d</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>255</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>d</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>d</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>255</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>d</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>pixels</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=参考链接>参考链接
<a class=header-anchor href=#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5></a></h3><ul><li>David Walsh,
<a href=http://davidwalsh.name/convert-canvas-image title="JavaScript Canvas Image Conversion" rel="noopener external nofollow noreferrer" target=_blank class=exturl>JavaScript Canvas Image Conversion
<i class="fa fa-external-link-alt"></i></a></li><li>Matt West,
<a href=http://blog.teamtreehouse.com/getting-started-with-the-canvas-api title="Getting Started With The Canvas API" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Getting Started With The Canvas API
<i class="fa fa-external-link-alt"></i></a></li><li>John Robinson,
<a href=http://www.storminthecastle.com/2013/04/06/how-you-can-do-cool-image-effects-using-html5-canvas/ title="How You Can Do Cool Image Effects Using HTML5 Canvas" rel="noopener external nofollow noreferrer" target=_blank class=exturl>How You Can Do Cool Image Effects Using HTML5 Canvas
<i class="fa fa-external-link-alt"></i></a></li><li>Ivaylo Gerchev,
<a href=http://www.sitepoint.com/html5-canvas-tutorial-introduction/ title="HTML5 Canvas Tutorial: An Introduction" rel="noopener external nofollow noreferrer" target=_blank class=exturl>HTML5 Canvas Tutorial: An Introduction
<i class="fa fa-external-link-alt"></i></a></li><li>Donovan Hutchinson,
<a href=http://hop.ie/blog/particles/ title="Particles in canvas" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Particles in canvas
<i class="fa fa-external-link-alt"></i></a></li></ul><h2 id=剪贴板操作-clipboard-api-教程>剪贴板操作 Clipboard API 教程
<a class=header-anchor href=#%e5%89%aa%e8%b4%b4%e6%9d%bf%e6%93%8d%e4%bd%9c-clipboard-api-%e6%95%99%e7%a8%8b></a></h2><h3 id=简介>简介
<a class=header-anchor href=#%e7%ae%80%e4%bb%8b></a></h3><p>浏览器允许 JavaScript 脚本读写剪贴板，自动复制或粘贴内容。</p><p>一般来说，脚本不应该改动用户的剪贴板，以免不符合用户的预期。但是，有些时候这样做确实能够带来方便，比如“一键复制”功能，用户点击一下按钮，指定的内容就自动进入剪贴板。</p><p>目前，一共有三种方法可以实现剪贴板操作。</p><ul><li><code>Document.execCommand()</code>方法</li><li>异步的 Clipboard API</li><li><code>copy</code>事件和<code>paste</code>事件</li></ul><p>本文逐一介绍这三种方法。</p><h3 id=documentexeccommand-方法>Document.execCommand() 方法
<a class=header-anchor href=#documentexeccommand-%e6%96%b9%e6%b3%95></a></h3><p><code>Document.execCommand()</code>是操作剪贴板的传统方法，各种浏览器都支持。</p><p>它支持复制、剪切和粘贴这三个操作。</p><ul><li><code>document.execCommand('copy')</code>（复制）</li><li><code>document.execCommand('cut')</code>（剪切）</li><li><code>document.execCommand('paste')</code>（粘贴）</li></ul><p>（1）复制操作</p><p>复制时，先选中文本，然后调用<code>document.execCommand('copy')</code>，选中的文本就会进入剪贴板。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>inputElement</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;##input&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>inputElement</span>.<span style=color:#a6e22e>select</span>();
</span></span><span style=display:flex><span>document.<span style=color:#a6e22e>execCommand</span>(<span style=color:#e6db74>&#39;copy&#39;</span>);
</span></span></code></pre></div><p>上面示例中，脚本先选中输入框<code>inputElement</code>里面的文字（<code>inputElement.select()</code>），然后<code>document.execCommand('copy')</code>将其复制到剪贴板。</p><p>注意，复制操作最好放在事件监听函数里面，由用户触发（比如用户点击按钮）。如果脚本自主执行，某些浏览器可能会报错。</p><p>（2）粘贴操作</p><p>粘贴时，调用<code>document.execCommand('paste')</code>，就会将剪贴板里面的内容，输出到当前的焦点元素中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>pasteText</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;##output&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>pasteText</span>.<span style=color:#a6e22e>focus</span>();
</span></span><span style=display:flex><span>document.<span style=color:#a6e22e>execCommand</span>(<span style=color:#e6db74>&#39;paste&#39;</span>);
</span></span></code></pre></div><p>（3）缺点</p><p><code>Document.execCommand()</code>方法虽然方便，但是有一些缺点。</p><p>首先，它只能将选中的内容复制到剪贴板，无法向剪贴板任意写入内容。</p><p>其次，它是同步操作，如果复制/粘贴大量数据，页面会出现卡顿。有些浏览器还会跳出提示框，要求用户许可，这时在用户做出选择前，页面会失去响应。</p><p>为了解决这些问题，浏览器厂商提出了异步的 Clipboard API。</p><h3 id=异步-clipboard-api>异步 Clipboard API
<a class=header-anchor href=#%e5%bc%82%e6%ad%a5-clipboard-api></a></h3><p>Clipboard API 是下一代的剪贴板操作方法，比传统的<code>document.execCommand()</code>方法更强大、更合理。</p><p>它的所有操作都是异步的，返回 Promise 对象，不会造成页面卡顿。而且，它可以将任意内容（比如图片）放入剪贴板。</p><p><code>navigator.clipboard</code>属性返回 Clipboard 对象，所有操作都通过这个对象进行。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>clipboardObj</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>clipboard</span>;
</span></span></code></pre></div><p>如果<code>navigator.clipboard</code>属性返回<code>undefined</code>，就说明当前浏览器不支持这个 API。</p><p>由于用户可能把敏感数据（比如密码）放在剪贴板，允许脚本任意读取会产生安全风险，所以这个 API 的安全限制比较多。</p><p>首先，Chrome 浏览器规定，只有 HTTPS 协议的页面才能使用这个 API。不过，开发环境（<code>localhost</code>）允许使用非加密协议。</p><p>其次，调用时需要明确获得用户的许可。权限的具体实现使用了 Permissions API，跟剪贴板相关的有两个权限：<code>clipboard-write</code>（写权限）和<code>clipboard-read</code>（读权限）。“写权限”自动授予脚本，而“读权限”必须用户明确同意给予。也就是说，写入剪贴板，脚本可以自动完成，但是读取剪贴板时，浏览器会弹出一个对话框，询问用户是否同意读取。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071415498.jpg alt></p><p>另外，需要注意的是，脚本读取的总是当前页面的剪贴板。这带来的一个问题是，如果把相关的代码粘贴到开发者工具中直接运行，可能会报错，因为这时的当前页面是开发者工具的窗口，而不是网页页面。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span>(<span style=color:#66d9ef>async</span> () =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>text</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>clipboard</span>.<span style=color:#a6e22e>readText</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>text</span>);
</span></span><span style=display:flex><span>})();
</span></span></code></pre></div><p>如果你把上面的代码，粘贴到开发者工具里面运行，就会报错。因为代码运行的时候，开发者工具窗口是当前页，这个页面不存在 Clipboard API 依赖的 DOM 接口。一个解决方法就是，相关代码放到<code>setTimeout()</code>里面延迟运行，在调用函数之前快速点击浏览器的页面窗口，将其变成当前页。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>setTimeout</span>(<span style=color:#66d9ef>async</span> () =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>text</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>clipboard</span>.<span style=color:#a6e22e>readText</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>text</span>);
</span></span><span style=display:flex><span>}, <span style=color:#ae81ff>2000</span>);
</span></span></code></pre></div><p>上面代码粘贴到开发者工具运行后，快速点击一下网页的页面窗口，使其变为当前页，这样就不会报错了。</p><h3 id=clipboard-对象>Clipboard 对象
<a class=header-anchor href=#clipboard-%e5%af%b9%e8%b1%a1></a></h3><p>Clipboard 对象提供了四个方法，用来读写剪贴板。它们都是异步方法，返回 Promise 对象。</p><h4 id=clipboardreadtext>Clipboard.readText()
<a class=header-anchor href=#clipboardreadtext></a></h4><p><code>Clipboard.readText()</code>方法用于复制剪贴板里面的文本数据。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span>document.<span style=color:#a6e22e>body</span>.<span style=color:#a6e22e>addEventListener</span>(
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#39;click&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>async</span> (<span style=color:#a6e22e>e</span>) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>text</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>clipboard</span>.<span style=color:#a6e22e>readText</span>();
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>text</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>上面示例中，用户点击页面后，就会输出剪贴板里面的文本。注意，浏览器这时会跳出一个对话框，询问用户是否同意脚本读取剪贴板。</p><p>如果用户不同意，脚本就会报错。这时，可以使用<code>try...catch</code>结构，处理报错。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getClipboardContents</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>text</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>clipboard</span>.<span style=color:#a6e22e>readText</span>();
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;Pasted content: &#39;</span>, <span style=color:#a6e22e>text</span>);
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>err</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#39;Failed to read clipboard contents: &#39;</span>, <span style=color:#a6e22e>err</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=clipboardread>Clipboard.read()
<a class=header-anchor href=#clipboardread></a></h4><p><code>Clipboard.read()</code>方法用于复制剪贴板里面的数据，可以是文本数据，也可以是二进制数据（比如图片）。该方法需要用户明确给予许可。</p><p>该方法返回一个 Promise 对象。一旦该对象的状态变为 resolved，就可以获得一个数组，每个数组成员都是 ClipboardItem 对象的实例。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getClipboardContents</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>clipboardItems</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>clipboard</span>.<span style=color:#a6e22e>read</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>clipboardItem</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>clipboardItems</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>type</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>clipboardItem</span>.<span style=color:#a6e22e>types</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>blob</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>clipboardItem</span>.<span style=color:#a6e22e>getType</span>(<span style=color:#a6e22e>type</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>createObjectURL</span>(<span style=color:#a6e22e>blob</span>));
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>err</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>error</span>(<span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>name</span>, <span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>message</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ClipboardItem 对象表示一个单独的剪贴项，每个剪贴项都拥有<code>ClipboardItem.types</code>属性和<code>ClipboardItem.getType()</code>方法。</p><p><code>ClipboardItem.types</code>属性返回一个数组，里面的成员是该剪贴项可用的 MIME 类型，比如某个剪贴项可以用 HTML 格式粘贴，也可以用纯文本格式粘贴，那么它就有两个 MIME 类型（<code>text/html</code>和<code>text/plain</code>）。</p><p><code>ClipboardItem.getType(type)</code>方法用于读取剪贴项的数据，返回一个 Promise 对象。该方法接受剪贴项的 MIME 类型作为参数，返回该类型的数据，该参数是必需的，否则会报错。</p><h4 id=clipboardwritetext>Clipboard.writeText()
<a class=header-anchor href=#clipboardwritetext></a></h4><p><code>Clipboard.writeText()</code>方法用于将文本内容写入剪贴板。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span>document.<span style=color:#a6e22e>body</span>.<span style=color:#a6e22e>addEventListener</span>(
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#39;click&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>async</span> (<span style=color:#a6e22e>e</span>) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>clipboard</span>.<span style=color:#a6e22e>writeText</span>(<span style=color:#e6db74>&#39;Yo&#39;</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>上面示例是用户在网页点击后，脚本向剪贴板写入文本数据。</p><p>该方法不需要用户许可，但是最好也放在<code>try...catch</code>里面防止报错。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>copyPageUrl</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>clipboard</span>.<span style=color:#a6e22e>writeText</span>(<span style=color:#a6e22e>location</span>.<span style=color:#a6e22e>href</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;Page URL copied to clipboard&#39;</span>);
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>err</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#39;Failed to copy: &#39;</span>, <span style=color:#a6e22e>err</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=clipboardwrite>Clipboard.write()
<a class=header-anchor href=#clipboardwrite></a></h4><p><code>Clipboard.write()</code>方法用于将任意数据写入剪贴板，可以是文本数据，也可以是二进制数据。</p><p>该方法接受一个 ClipboardItem 实例作为参数，表示写入剪贴板的数据。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>imgURL</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;https://dummyimage.com/300.png&#39;</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#a6e22e>imgURL</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>blob</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>blob</span>();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>clipboard</span>.<span style=color:#a6e22e>write</span>([
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ClipboardItem</span>({
</span></span><span style=display:flex><span>      [<span style=color:#a6e22e>blob</span>.<span style=color:#a6e22e>type</span>]<span style=color:#f92672>:</span> <span style=color:#a6e22e>blob</span>
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>  ]);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;Image copied.&#39;</span>);
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>err</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>error</span>(<span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>name</span>, <span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>message</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面示例中，脚本向剪贴板写入了一张图片。注意，Chrome 浏览器目前只支持写入 PNG 格式的图片。</p><p><code>ClipboardItem()</code>是浏览器原生提供的构造函数，用来生成<code>ClipboardItem</code>实例，它接受一个对象作为参数，该对象的键名是数据的 MIME 类型，键值就是数据本身。</p><p>下面的例子是将同一个剪贴项的多种格式的值，写入剪贴板，一种是文本数据，另一种是二进制数据，供不同的场合粘贴使用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>copy</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>image</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;kitten.png&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>text</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Blob</span>([<span style=color:#e6db74>&#39;Cute sleeping kitten&#39;</span>], {<span style=color:#a6e22e>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;text/plain&#39;</span>});
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>item</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ClipboardItem</span>({
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;text/plain&#39;</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>text</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;image/png&#39;</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>image</span>
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>clipboard</span>.<span style=color:#a6e22e>write</span>([<span style=color:#a6e22e>item</span>]);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=copy-事件cut-事件>copy 事件，cut 事件
<a class=header-anchor href=#copy-%e4%ba%8b%e4%bb%b6cut-%e4%ba%8b%e4%bb%b6></a></h3><p>用户向剪贴板放入数据时，将触发<code>copy</code>事件。</p><p>下面的示例是将用户放入剪贴板的文本，转为大写。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>source</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;.source&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>source</span>.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;copy&#39;</span>, (<span style=color:#a6e22e>event</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>selection</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getSelection</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>clipboardData</span>.<span style=color:#a6e22e>setData</span>(<span style=color:#e6db74>&#39;text/plain&#39;</span>, <span style=color:#a6e22e>selection</span>.<span style=color:#a6e22e>toString</span>().<span style=color:#a6e22e>toUpperCase</span>());
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>preventDefault</span>();
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>上面示例中，事件对象的<code>clipboardData</code>属性包含了剪贴板数据。它是一个对象，有以下属性和方法。</p><ul><li><code>Event.clipboardData.setData(type, data)</code>：修改剪贴板数据，需要指定数据类型。</li><li><code>Event.clipboardData.getData(type)</code>：获取剪贴板数据，需要指定数据类型。</li><li><code>Event.clipboardData.clearData([type])</code>：清除剪贴板数据，可以指定数据类型。如果不指定类型，将清除所有类型的数据。</li><li><code>Event.clipboardData.items</code>：一个类似数组的对象，包含了所有剪贴项，不过通常只有一个剪贴项。</li></ul><p>下面的示例是拦截用户的复制操作，将指定内容放入剪贴板。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>clipboardItems</span> <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>document.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;copy&#39;</span>, <span style=color:#66d9ef>async</span> (<span style=color:#a6e22e>e</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>preventDefault</span>();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>clipboardItems</span> <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>item</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>clipboardData</span>.<span style=color:#a6e22e>items</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>item</span>.<span style=color:#a6e22e>type</span>.<span style=color:#a6e22e>startsWith</span>(<span style=color:#e6db74>&#39;image/&#39;</span>)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>clipboardItems</span>.<span style=color:#a6e22e>push</span>(
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ClipboardItem</span>({
</span></span><span style=display:flex><span>          [<span style=color:#a6e22e>item</span>.<span style=color:#a6e22e>type</span>]<span style=color:#f92672>:</span> <span style=color:#a6e22e>item</span>,
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>      );
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>clipboard</span>.<span style=color:#a6e22e>write</span>(<span style=color:#a6e22e>clipboardItems</span>);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;Image copied.&#39;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>err</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>error</span>(<span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>name</span>, <span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>message</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>上面示例中，先使用<code>e.preventDefault()</code>取消了剪贴板的默认操作，然后由脚本接管复制操作。</p><p><code>cut</code>事件则是在用户进行剪切操作时触发，它的处理跟<code>copy</code>事件完全一样，也是从<code>Event.clipboardData</code>属性拿到剪切的数据。</p><h3 id=paste-事件>paste 事件
<a class=header-anchor href=#paste-%e4%ba%8b%e4%bb%b6></a></h3><p>用户使用剪贴板数据，进行粘贴操作时，会触发<code>paste</code>事件。</p><p>下面的示例是拦截粘贴操作，由脚本将剪贴板里面的数据取出来。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span>document.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;paste&#39;</span>, <span style=color:#66d9ef>async</span> (<span style=color:#a6e22e>e</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>preventDefault</span>();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>text</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>clipboard</span>.<span style=color:#a6e22e>readText</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;Pasted text: &#39;</span>, <span style=color:#a6e22e>text</span>);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h3 id=参考链接-1>参考链接
<a class=header-anchor href=#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5-1></a></h3><ul><li><a href=https://web.dev/async-clipboard/ title="Unblocking clipboard access" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Unblocking clipboard access
<i class="fa fa-external-link-alt"></i></a></li><li><a href=https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Interact_with_the_clipboard title="Interact with the clipboard" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Interact with the clipboard
<i class="fa fa-external-link-alt"></i></a></li><li><a href=https://blog.tomayac.com/2020/03/20/multi-mime-type-copying-with-the-async-clipboard-api/ title="Multi-MIME Type Copying with the Async Clipboard API" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Multi-MIME Type Copying with the Async Clipboard API
<i class="fa fa-external-link-alt"></i></a></li></ul><h2 id=fetch-api-教程>Fetch API 教程
<a class=header-anchor href=#fetch-api-%e6%95%99%e7%a8%8b></a></h2><p><code>fetch()</code>是 XMLHttpRequest 的升级版，用于在 JavaScript 脚本里面发出 HTTP 请求。</p><p>浏览器原生提供这个对象。本章详细介绍它的用法。</p><h3 id=基本用法>基本用法
<a class=header-anchor href=#%e5%9f%ba%e6%9c%ac%e7%94%a8%e6%b3%95></a></h3><p><code>fetch()</code>的功能与 XMLHttpRequest 基本相同，但有三个主要的差异。</p><p>（1）<code>fetch()</code>使用 Promise，不使用回调函数，因此大大简化了写法，写起来更简洁。</p><p>（2）<code>fetch()</code>采用模块化设计，API 分散在多个对象上（Response 对象、Request 对象、Headers 对象），更合理一些；相比之下，XMLHttpRequest 的 API 设计并不是很好，输入、输出、状态都在同一个接口管理，容易写出非常混乱的代码。</p><p>（3）<code>fetch()</code>通过数据流（Stream 对象）处理数据，可以分块读取，有利于提高网站性能表现，减少内存占用，对于请求大文件或者网速慢的场景相当有用。XMLHTTPRequest 对象不支持数据流，所有的数据必须放在缓存里，不支持分块读取，必须等待全部拿到后，再一次性吐出来。</p><p>在用法上，<code>fetch()</code>接受一个 URL 字符串作为参数，默认向该网址发出 GET 请求，返回一个 Promise 对象。它的基本用法如下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>fetch</span>(<span style=color:#a6e22e>url</span>)
</span></span><span style=display:flex><span>  .<span style=color:#a6e22e>then</span>(...)
</span></span><span style=display:flex><span>  .<span style=color:#66d9ef>catch</span>(...)
</span></span></code></pre></div><p>下面是一个例子，从服务器获取 JSON 数据。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;https://api.github.com/users/ruanyf&#39;</span>)
</span></span><span style=display:flex><span>  .<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>response</span> =&gt; <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>json</span>())
</span></span><span style=display:flex><span>  .<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>json</span> =&gt; <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>json</span>))
</span></span><span style=display:flex><span>  .<span style=color:#66d9ef>catch</span>(<span style=color:#a6e22e>err</span> =&gt; <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;Request Failed&#39;</span>, <span style=color:#a6e22e>err</span>)); 
</span></span></code></pre></div><p>上面示例中，<code>fetch()</code>接收到的<code>response</code>是一个
<a href=https://developer.mozilla.org/en-US/docs/Web/API/Streams_API title="Stream 对象" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Stream 对象
<i class="fa fa-external-link-alt"></i>
</a>，<code>response.json()</code>是一个异步操作，取出所有内容，并将其转为 JSON 对象。</p><p>Promise 可以使用 await 语法改写，使得语义更清晰。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getJSON</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>url</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;https://api.github.com/users/ruanyf&#39;</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>response</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#a6e22e>url</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>json</span>();
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>error</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;Request Failed&#39;</span>, <span style=color:#a6e22e>error</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面示例中，<code>await</code>语句必须放在<code>try...catch</code>里面，这样才能捕捉异步操作中可能发生的错误。</p><p>后文都采用<code>await</code>的写法，不使用<code>.then()</code>的写法。</p><h3 id=response-对象处理-http-回应>Response 对象：处理 HTTP 回应
<a class=header-anchor href=#response-%e5%af%b9%e8%b1%a1%e5%a4%84%e7%90%86-http-%e5%9b%9e%e5%ba%94></a></h3><h4 id=response-对象的同步属性>Response 对象的同步属性
<a class=header-anchor href=#response-%e5%af%b9%e8%b1%a1%e7%9a%84%e5%90%8c%e6%ad%a5%e5%b1%9e%e6%80%a7></a></h4><p><code>fetch()</code>请求成功以后，得到的是一个
<a href=https://developer.mozilla.org/en-US/docs/Web/API/Response title="Response 对象" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Response 对象
<i class="fa fa-external-link-alt"></i>
</a>。它对应服务器的 HTTP 回应。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>response</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#a6e22e>url</span>);
</span></span></code></pre></div><p>前面说过，Response 包含的数据通过 Stream 接口异步读取，但是它还包含一些同步属性，对应 HTTP 回应的标头信息（Headers），可以立即读取。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>fetchText</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>response</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;/readme.txt&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>status</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>statusText</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面示例中，<code>response.status</code>和<code>response.statusText</code>就是 Response 的同步属性，可以立即读取。</p><p>标头信息属性有下面这些。</p><p><strong>Response.ok</strong></p><p><code>Response.ok</code>属性返回一个布尔值，表示请求是否成功，<code>true</code>对应 HTTP 请求的状态码 200 到 299，<code>false</code>对应其他的状态码。</p><p><strong>Response.status</strong></p><p><code>Response.status</code>属性返回一个数字，表示 HTTP 回应的状态码（例如200，表示成功请求）。</p><p><strong>Response.statusText</strong></p><p><code>Response.statusText</code>属性返回一个字符串，表示 HTTP 回应的状态信息（例如请求成功以后，服务器返回“OK”）。</p><p><strong>Response.url</strong></p><p><code>Response.url</code>属性返回请求的 URL。如果 URL 存在跳转，该属性返回的是最终 URL。</p><p><strong>Response.type</strong></p><p><code>Response.type</code>属性返回请求的类型。可能的值如下：</p><ul><li><code>basic</code>：普通请求，即同源请求。</li><li><code>cors</code>：跨源请求。</li><li><code>error</code>：网络错误，主要用于 Service Worker。</li><li><code>opaque</code>：如果<code>fetch()</code>请求的<code>type</code>属性设为<code>no-cors</code>，就会返回这个值，详见请求部分。表示发出的是简单的跨源请求，类似<code>&lt;form></code>表单的那种跨源请求。</li><li><code>opaqueredirect</code>：如果<code>fetch()</code>请求的<code>redirect</code>属性设为<code>manual</code>，就会返回这个值，详见请求部分。</li></ul><p><strong>Response.redirected</strong></p><p><code>Response.redirected</code>属性返回一个布尔值，表示请求是否发生过跳转。</p><h4 id=判断请求是否成功>判断请求是否成功
<a class=header-anchor href=#%e5%88%a4%e6%96%ad%e8%af%b7%e6%b1%82%e6%98%af%e5%90%a6%e6%88%90%e5%8a%9f></a></h4><p><code>fetch()</code>发出请求以后，有一个很重要的注意点：只有网络错误，或者无法连接时，<code>fetch()</code>才会报错，其他情况都不会报错，而是认为请求成功。</p><p>这就是说，即使服务器返回的状态码是 4xx 或 5xx，<code>fetch()</code>也不会报错（即 Promise 不会变为 <code>rejected</code>状态）。</p><p>只有通过<code>Response.status</code>属性，得到 HTTP 回应的真实状态码，才能判断请求是否成功。请看下面的例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>fetchText</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>response</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;/readme.txt&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>status</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>200</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>status</span> <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>300</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>text</span>();
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>statusText</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面示例中，<code>response.status</code>属性只有等于 2xx （200~299），才能认定请求成功。这里不用考虑网址跳转（状态码为 3xx），因为<code>fetch()</code>会将跳转的状态码自动转为 200。</p><p>另一种方法是判断<code>response.ok</code>是否为<code>true</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>ok</span>) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 请求成功
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 请求失败
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h4 id=responseheaders-属性>Response.headers 属性
<a class=header-anchor href=#responseheaders-%e5%b1%9e%e6%80%a7></a></h4><p>Response 对象还有一个<code>Response.headers</code>属性，指向一个
<a href=https://developer.mozilla.org/en-US/docs/Web/API/Headers title="Headers 对象" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Headers 对象
<i class="fa fa-external-link-alt"></i>
</a>，对应 HTTP 回应的所有标头。</p><p>Headers 对象可以使用<code>for...of</code>循环进行遍历。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>response</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#a6e22e>url</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> [<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>value</span>] <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>headers</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>key</span><span style=color:#e6db74>}</span><span style=color:#e6db74> : </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>value</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 或者
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> [<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>value</span>] <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>headers</span>.<span style=color:#a6e22e>entries</span>()) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>key</span><span style=color:#e6db74>}</span><span style=color:#e6db74> : </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>value</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Headers 对象提供了以下方法，用来操作标头。</p><blockquote><ul><li><code>Headers.get()</code>：根据指定的键名，返回键值。</li><li><code>Headers.has()</code>： 返回一个布尔值，表示是否包含某个标头。</li><li><code>Headers.set()</code>：将指定的键名设置为新的键值，如果该键名不存在则会添加。</li><li><code>Headers.append()</code>：添加标头。</li><li><code>Headers.delete()</code>：删除标头。</li><li><code>Headers.keys()</code>：返回一个遍历器，可以依次遍历所有键名。</li><li><code>Headers.values()</code>：返回一个遍历器，可以依次遍历所有键值。</li><li><code>Headers.entries()</code>：返回一个遍历器，可以依次遍历所有键值对（<code>[key, value]</code>）。</li><li><code>Headers.forEach()</code>：依次遍历标头，每个标头都会执行一次参数函数。</li></ul></blockquote><p>上面的有些方法可以修改标头，那是因为继承自 Headers 接口。对于 HTTP 回应来说，修改标头意义不大，况且很多标头是只读的，浏览器不允许修改。</p><p>这些方法中，最常用的是<code>response.headers.get()</code>，用于读取某个标头的值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>response</span> <span style=color:#f92672>=</span>  <span style=color:#66d9ef>await</span>  <span style=color:#a6e22e>fetch</span>(<span style=color:#a6e22e>url</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>headers</span>.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#39;Content-Type&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>// application/json; charset=utf-8
</span></span></span></code></pre></div><p><code>Headers.keys()</code>和<code>Headers.values()</code>方法用来分别遍历标头的键名和键值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 键名
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>key</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>myHeaders</span>.<span style=color:#a6e22e>keys</span>()) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>key</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 键值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>value</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>myHeaders</span>.<span style=color:#a6e22e>values</span>()) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>value</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Headers.forEach()</code>方法也可以遍历所有的键值和键名。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>response</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#a6e22e>url</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>headers</span>.<span style=color:#a6e22e>forEach</span>(
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>value</span>, <span style=color:#a6e22e>key</span>) =&gt; <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>key</span>, <span style=color:#e6db74>&#39;:&#39;</span>, <span style=color:#a6e22e>value</span>)
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><h4 id=读取内容的方法>读取内容的方法
<a class=header-anchor href=#%e8%af%bb%e5%8f%96%e5%86%85%e5%ae%b9%e7%9a%84%e6%96%b9%e6%b3%95></a></h4><p><code>Response</code>对象根据服务器返回的不同类型的数据，提供了不同的读取方法。</p><blockquote><ul><li><code>response.text()</code>：得到文本字符串。</li><li><code>response.json()</code>：得到 JSON 对象。</li><li><code>response.blob()</code>：得到二进制 Blob 对象。</li><li><code>response.formData()</code>：得到 FormData 表单对象。</li><li><code>response.arrayBuffer()</code>：得到二进制 ArrayBuffer 对象。</li></ul></blockquote><p>上面5个读取方法都是异步的，返回的都是 Promise 对象。必须等到异步操作结束，才能得到服务器返回的完整数据。</p><p><strong>response.text()</strong></p><p><code>response.text()</code>可以用于获取文本数据，比如 HTML 文件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>response</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;/users.html&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>body</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>text</span>();
</span></span><span style=display:flex><span>document.<span style=color:#a6e22e>body</span>.<span style=color:#a6e22e>innerHTML</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>body</span>
</span></span></code></pre></div><p><strong>response.json()</strong></p><p><code>response.json()</code>主要用于获取服务器返回的 JSON 数据，前面已经举过例子了。</p><p><strong>response.formData()</strong></p><p><code>response.formData()</code>主要用在 Service Worker 里面，拦截用户提交的表单，修改某些数据以后，再提交给服务器。</p><p><strong>response.blob()</strong></p><p><code>response.blob()</code>用于获取二进制文件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>response</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;flower.jpg&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>myBlob</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>blob</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>objectURL</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>createObjectURL</span>(<span style=color:#a6e22e>myBlob</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>myImage</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;img&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>myImage</span>.<span style=color:#a6e22e>src</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>objectURL</span>;
</span></span></code></pre></div><p>上面示例读取图片文件<code>flower.jpg</code>，显示在网页上。</p><p><strong>response.arrayBuffer()</strong></p><p><code>response.arrayBuffer()</code>主要用于获取流媒体文件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>audioCtx</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> window.<span style=color:#a6e22e>AudioContext</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>source</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>audioCtx</span>.<span style=color:#a6e22e>createBufferSource</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>response</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;song.ogg&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>buffer</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>arrayBuffer</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>decodeData</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>audioCtx</span>.<span style=color:#a6e22e>decodeAudioData</span>(<span style=color:#a6e22e>buffer</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>source</span>.<span style=color:#a6e22e>buffer</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>buffer</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>source</span>.<span style=color:#a6e22e>connect</span>(<span style=color:#a6e22e>audioCtx</span>.<span style=color:#a6e22e>destination</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>source</span>.<span style=color:#a6e22e>loop</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span></code></pre></div><p>上面示例是<code>response.arrayBuffer()</code>获取音频文件<code>song.ogg</code>，然后在线播放的例子。</p><h4 id=responseclone>Response.clone()
<a class=header-anchor href=#responseclone></a></h4><p>Stream 对象只能读取一次，读取完就没了。这意味着，前一节的五个读取方法，只能使用一个，否则会报错。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>text</span> <span style=color:#f92672>=</span>  <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>text</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>json</span> <span style=color:#f92672>=</span>  <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>json</span>();  <span style=color:#75715e>// 报错
</span></span></span></code></pre></div><p>上面示例先使用了<code>response.text()</code>，就把 Stream 读完了。后面再调用<code>response.json()</code>，就没有内容可读了，所以报错。</p><p>Response 对象提供<code>Response.clone()</code>方法，创建<code>Response</code>对象的副本，实现多次读取。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>response1</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;flowers.jpg&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>response2</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>response1</span>.<span style=color:#a6e22e>clone</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>myBlob1</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>response1</span>.<span style=color:#a6e22e>blob</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>myBlob2</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>response2</span>.<span style=color:#a6e22e>blob</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>image1</span>.<span style=color:#a6e22e>src</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>createObjectURL</span>(<span style=color:#a6e22e>myBlob1</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>image2</span>.<span style=color:#a6e22e>src</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>createObjectURL</span>(<span style=color:#a6e22e>myBlob2</span>);
</span></span></code></pre></div><p>上面示例中，<code>response.clone()</code>复制了一份 Response 对象，然后将同一张图片读取了两次。</p><p>Response 对象还有一个<code>Response.redirect()</code>方法，用于将 Response 结果重定向到指定的 URL。该方法一般只用在 Service Worker 里面，这里就不介绍了。</p><h4 id=responsebody-属性>Response.body 属性
<a class=header-anchor href=#responsebody-%e5%b1%9e%e6%80%a7></a></h4><p><code>Response.body</code>属性是 Response 对象暴露出的底层接口，返回一个 ReadableStream 对象，供用户操作。</p><p>它可以用来分块读取内容，应用之一就是显示下载的进度。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>response</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;flower.jpg&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>reader</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>body</span>.<span style=color:#a6e22e>getReader</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span>(<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> {<span style=color:#a6e22e>done</span>, <span style=color:#a6e22e>value</span>} <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>reader</span>.<span style=color:#a6e22e>read</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>done</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`Received </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>value</span>.<span style=color:#a6e22e>length</span><span style=color:#e6db74>}</span><span style=color:#e6db74> bytes`</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面示例中，<code>response.body.getReader()</code>方法返回一个遍历器。这个遍历器的<code>read()</code>方法每次返回一个对象，表示本次读取的内容块。</p><p>这个对象的<code>done</code>属性是一个布尔值，用来判断有没有读完；<code>value</code>属性是一个 arrayBuffer 数组，表示内容块的内容，而<code>value.length</code>属性是当前块的大小。</p><h3 id=fetch的第二个参数定制-http-请求><code>fetch()</code>的第二个参数：定制 HTTP 请求
<a class=header-anchor href=#fetch%e7%9a%84%e7%ac%ac%e4%ba%8c%e4%b8%aa%e5%8f%82%e6%95%b0%e5%ae%9a%e5%88%b6-http-%e8%af%b7%e6%b1%82></a></h3><p><code>fetch()</code>的第一个参数是 URL，还可以接受第二个参数，作为配置对象，定制发出的 HTTP 请求。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>fetch</span>(<span style=color:#a6e22e>url</span>, <span style=color:#a6e22e>optionObj</span>)
</span></span></code></pre></div><p>上面命令的<code>optionObj</code>就是第二个参数。</p><p>HTTP 请求的方法、标头、数据体都在这个对象里面设置。下面是一些示例。</p><p><strong>（1）POST 请求</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>response</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#a6e22e>url</span>, {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>method</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;POST&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>headers</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;Content-type&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;application/x-www-form-urlencoded; charset=UTF-8&#34;</span>,
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>body</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;foo=bar&amp;lorem=ipsum&#39;</span>,
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>json</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>json</span>();
</span></span></code></pre></div><p>上面示例中，配置对象用到了三个属性。</p><blockquote><ul><li><code>method</code>：HTTP 请求的方法，<code>POST</code>、<code>DELETE</code>、<code>PUT</code>都在这个属性设置。</li><li><code>headers</code>：一个对象，用来定制 HTTP 请求的标头。</li><li><code>body</code>：POST 请求的数据体。</li></ul></blockquote><p>注意，有些标头不能通过<code>headers</code>属性设置，比如<code>Content-Length</code>、<code>Cookie</code>、<code>Host</code>等等。它们是由浏览器自动生成，无法修改。</p><p><strong>（2）提交 JSON 数据</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>user</span> <span style=color:#f92672>=</span>  { <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span>  <span style=color:#e6db74>&#39;John&#39;</span>, <span style=color:#a6e22e>surname</span><span style=color:#f92672>:</span>  <span style=color:#e6db74>&#39;Smith&#39;</span>  };
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>response</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;/article/fetch/post/user&#39;</span>, {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>method</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;POST&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>headers</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>   <span style=color:#e6db74>&#39;Content-Type&#39;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;application/json;charset=utf-8&#39;</span>
</span></span><span style=display:flex><span>  }, 
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>body</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>user</span>) 
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>上面示例中，标头<code>Content-Type</code>要设成<code>'application/json;charset=utf-8'</code>。因为默认发送的是纯文本，<code>Content-Type</code>的默认值是<code>'text/plain;charset=UTF-8'</code>。</p><p><strong>（3）提交表单</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>form</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;form&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>response</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;/users&#39;</span>, {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>method</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;POST&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>body</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>FormData</span>(<span style=color:#a6e22e>form</span>)
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p><strong>（4）文件上传</strong></p><p>如果表单里面有文件选择器，可以用前一个例子的写法，上传的文件包含在整个表单里面，一起提交。</p><p>另一种方法是用脚本添加文件，构造出一个表单，进行上传，请看下面的例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>input</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;input[type=&#34;file&#34;]&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>FormData</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>append</span>(<span style=color:#e6db74>&#39;file&#39;</span>, <span style=color:#a6e22e>input</span>.<span style=color:#a6e22e>files</span>[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span><span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>append</span>(<span style=color:#e6db74>&#39;user&#39;</span>, <span style=color:#e6db74>&#39;foo&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;/avatars&#39;</span>, {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>method</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;POST&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>body</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>data</span>
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>上传二进制文件时，不用修改标头的<code>Content-Type</code>，浏览器会自动设置。</p><p><strong>（5）直接上传二进制数据</strong></p><p><code>fetch()</code>也可以直接上传二进制数据，将 Blob 或 arrayBuffer 数据放在<code>body</code>属性里面。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>blob</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#66d9ef>new</span> Promise(<span style=color:#a6e22e>resolve</span> =&gt;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>canvasElem</span>.<span style=color:#a6e22e>toBlob</span>(<span style=color:#a6e22e>resolve</span>,  <span style=color:#e6db74>&#39;image/png&#39;</span>)
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>response</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;/article/fetch/post/image&#39;</span>, {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>method</span><span style=color:#f92672>:</span>  <span style=color:#e6db74>&#39;POST&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>body</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>blob</span>
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h3 id=fetch配置对象的完整-api><code>fetch()</code>配置对象的完整 API
<a class=header-anchor href=#fetch%e9%85%8d%e7%bd%ae%e5%af%b9%e8%b1%a1%e7%9a%84%e5%ae%8c%e6%95%b4-api></a></h3><p><code>fetch()</code>第二个参数的完整 API 如下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>response</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#a6e22e>url</span>, {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>method</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;GET&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>headers</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;Content-Type&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;text/plain;charset=UTF-8&#34;</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>body</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>undefined</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>referrer</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;about:client&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>referrerPolicy</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;no-referrer-when-downgrade&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mode</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;cors&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>credentials</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;same-origin&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>cache</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;default&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>redirect</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;follow&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>integrity</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>keepalive</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>signal</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>undefined</span>
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p><code>fetch()</code>请求的底层用的是
<a href=https://developer.mozilla.org/en-US/docs/Web/API/Request/Request title="Request() 对象" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Request() 对象
<i class="fa fa-external-link-alt"></i>
</a>的接口，参数完全一样，因此上面的 API 也是<code>Request()</code>的 API。</p><p>这些属性里面，<code>headers</code>、<code>body</code>、<code>method</code>前面已经给过示例了，下面是其他属性的介绍。</p><p><strong>cache</strong></p><p><code>cache</code>属性指定如何处理缓存。可能的取值如下：</p><ul><li><code>default</code>：默认值，先在缓存里面寻找匹配的请求。</li><li><code>no-store</code>：直接请求远程服务器，并且不更新缓存。</li><li><code>reload</code>：直接请求远程服务器，并且更新缓存。</li><li><code>no-cache</code>：将服务器资源跟本地缓存进行比较，有新的版本才使用服务器资源，否则使用缓存。</li><li><code>force-cache</code>：缓存优先，只有不存在缓存的情况下，才请求远程服务器。</li><li><code>only-if-cached</code>：只检查缓存，如果缓存里面不存在，将返回504错误。</li></ul><p><strong>mode</strong></p><p><code>mode</code>属性指定请求的模式。可能的取值如下：</p><ul><li><code>cors</code>：默认值，允许跨源请求。</li><li><code>same-origin</code>：只允许同源请求。</li><li><code>no-cors</code>：请求方法只限于 GET、POST 和 HEAD，并且只能使用有限的几个简单标头，不能添加跨源的复杂标头，相当于提交表单、<code>&lt;script></code>加载脚本、<code>&lt;img></code>加载图片等传统的跨源请求方法。</li></ul><p><strong>credentials</strong></p><p><code>credentials</code>属性指定是否发送 Cookie。可能的取值如下：</p><ul><li><code>same-origin</code>：默认值，同源请求时发送 Cookie，跨源请求时不发送。</li><li><code>include</code>：不管同源请求，还是跨源请求，一律发送 Cookie。</li><li><code>omit</code>：一律不发送。</li></ul><p>跨源请求发送 Cookie，需要将<code>credentials</code>属性设为<code>include</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;http://another.com&#39;</span>, {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>credentials</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;include&#34;</span>
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p><strong>signal</strong></p><p><code>signal</code>属性指定一个 AbortSignal 实例，用于取消<code>fetch()</code>请求，详见下一节。</p><p><strong>keepalive</strong></p><p><code>keepalive</code>属性用于页面卸载时，告诉浏览器在后台保持连接，继续发送数据。</p><p>一个典型的场景就是，用户离开网页时，脚本向服务器提交一些用户行为的统计信息。这时，如果不用<code>keepalive</code>属性，数据可能无法发送，因为浏览器已经把页面卸载了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span>window.<span style=color:#a6e22e>onunload</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;/analytics&#39;</span>, {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>method</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;POST&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>headers</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#39;Content-Type&#39;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;application/json&#39;</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>body</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>({
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>some</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;data&#39;</span>
</span></span><span style=display:flex><span>    }),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>keepalive</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><strong>redirect</strong></p><p><code>redirect</code>属性指定 HTTP 跳转的处理方法。可能的取值如下：</p><ul><li><code>follow</code>：默认值，<code>fetch()</code>跟随 HTTP 跳转。</li><li><code>error</code>：如果发生跳转，<code>fetch()</code>就报错。</li><li><code>manual</code>：<code>fetch()</code>不跟随 HTTP 跳转，但是<code>response.url</code>属性会指向新的 URL，<code>response.redirected</code>属性会变为<code>true</code>，由开发者自己决定后续如何处理跳转。</li></ul><p><strong>integrity</strong></p><p><code>integrity</code>属性指定一个哈希值，用于检查 HTTP 回应传回的数据是否等于这个预先设定的哈希值。</p><p>比如，下载文件时，检查文件的 SHA-256 哈希值是否相符，确保没有被篡改。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;http://site.com/file&#39;</span>, {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>integrity</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;sha256-abcdef&#39;</span>
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p><strong>referrer</strong></p><p><code>referrer</code>属性用于设定<code>fetch()</code>请求的<code>referer</code>标头。</p><p>这个属性可以为任意字符串，也可以设为空字符串（即不发送<code>referer</code>标头）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;/page&#39;</span>, {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>referrer</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;&#39;</span>
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p><strong>referrerPolicy</strong></p><p><code>referrerPolicy</code>属性用于设定<code>Referer</code>标头的规则。可能的取值如下：</p><ul><li><code>no-referrer-when-downgrade</code>：默认值，总是发送<code>Referer</code>标头，除非从 HTTPS 页面请求 HTTP 资源时不发送。</li><li><code>no-referrer</code>：不发送<code>Referer</code>标头。</li><li><code>origin</code>：<code>Referer</code>标头只包含域名，不包含完整的路径。</li><li><code>origin-when-cross-origin</code>：同源请求<code>Referer</code>标头包含完整的路径，跨源请求只包含域名。</li><li><code>same-origin</code>：跨源请求不发送<code>Referer</code>，同源请求发送。</li><li><code>strict-origin</code>：<code>Referer</code>标头只包含域名，HTTPS 页面请求 HTTP 资源时不发送<code>Referer</code>标头。</li><li><code>strict-origin-when-cross-origin</code>：同源请求时<code>Referer</code>标头包含完整路径，跨源请求时只包含域名，HTTPS 页面请求 HTTP 资源时不发送该标头。</li><li><code>unsafe-url</code>：不管什么情况，总是发送<code>Referer</code>标头。</li></ul><h3 id=取消fetch请求>取消<code>fetch()</code>请求
<a class=header-anchor href=#%e5%8f%96%e6%b6%88fetch%e8%af%b7%e6%b1%82></a></h3><p><code>fetch()</code>请求发送以后，如果中途想要取消，需要使用<code>AbortController</code>对象。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>controller</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>AbortController</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>signal</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>controller</span>.<span style=color:#a6e22e>signal</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>fetch</span>(<span style=color:#a6e22e>url</span>, {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>signal</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>controller</span>.<span style=color:#a6e22e>signal</span>
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>signal</span>.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;abort&#39;</span>,
</span></span><span style=display:flex><span>  () =&gt; <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;abort!&#39;</span>)
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>controller</span>.<span style=color:#a6e22e>abort</span>(); <span style=color:#75715e>// 取消
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>signal</span>.<span style=color:#a6e22e>aborted</span>); <span style=color:#75715e>// true
</span></span></span></code></pre></div><p>上面示例中，首先新建 AbortController 实例，然后发送<code>fetch()</code>请求，配置对象的<code>signal</code>属性必须指定接收 AbortController 实例发送的信号<code>controller.signal</code>。</p><p><code>controller.abort()</code>方法用于发出取消信号。这时会触发<code>abort</code>事件，这个事件可以监听，也可以通过<code>controller.signal.aborted</code>属性判断取消信号是否已经发出。</p><p>下面是一个1秒后自动取消请求的例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>controller</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>AbortController</span>();
</span></span><span style=display:flex><span><span style=color:#a6e22e>setTimeout</span>(() =&gt; <span style=color:#a6e22e>controller</span>.<span style=color:#a6e22e>abort</span>(), <span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>response</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;/long-operation&#39;</span>, {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>signal</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>controller</span>.<span style=color:#a6e22e>signal</span>
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>catch</span>(<span style=color:#a6e22e>err</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;AbortError&#39;</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;Aborted!&#39;</span>);
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> <span style=color:#a6e22e>err</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=参考链接-2>参考链接
<a class=header-anchor href=#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5-2></a></h3><ul><li><a href=https://javascript.info/fetch title="Network requests: Fetch" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Network requests: Fetch
<i class="fa fa-external-link-alt"></i></a></li><li><a href=https://github.com/node-fetch/node-fetch title=node-fetch rel="noopener external nofollow noreferrer" target=_blank class=exturl>node-fetch
<i class="fa fa-external-link-alt"></i></a></li><li><a href=https://developers.google.com/web/updates/2015/03/introduction-to-fetch title="Introduction to fetch()" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Introduction to fetch()
<i class="fa fa-external-link-alt"></i></a></li><li><a href=https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch title="Using Fetch" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Using Fetch
<i class="fa fa-external-link-alt"></i></a></li><li><a href=https://developerhowto.com/2019/09/14/javascript-fetch-api/ title="Javascript Fetch API: The XMLHttpRequest evolution" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Javascript Fetch API: The XMLHttpRequest evolution
<i class="fa fa-external-link-alt"></i></a></li><li><a href=https://www.sitepen.com/blog/2017/10/02/a-guide-to-faster-web-app-io-and-data-operations-with-streams/ title="A Guide to Faster Web App I/O and Data Operations with Streams" rel="noopener external nofollow noreferrer" target=_blank class=exturl>A Guide to Faster Web App I/O and Data Operations with Streams
<i class="fa fa-external-link-alt"></i></a></li></ul><h2 id=fontface-api>FontFace API
<a class=header-anchor href=#fontface-api></a></h2><p>FontFace API 用来控制字体加载。</p><p>这个 API 提供一个构造函数<code>FontFace()</code>，返回一个字体对象。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>new</span> <span style=color:#a6e22e>FontFace</span>(<span style=color:#a6e22e>family</span>, <span style=color:#a6e22e>source</span>, <span style=color:#a6e22e>descriptors</span>)
</span></span></code></pre></div><p><code>FontFace()</code>构造函数接受三个参数。</p><ul><li><code>family</code>：字符串，表示字体名，写法与 CSS 的<code>@font-face</code>的<code>font-family</code>属性相同。</li><li><code>source</code>：字体文件的 URL（必须包括 CSS 的<code>url()</code>方法），或者是一个字体的 ArrayBuffer 对象。</li><li><code>descriptors</code>：对象，用来定制字体文件。该参数可选。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>fontFace</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>FontFace</span>(
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#39;Roboto&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#39;url(https://fonts.example.com/roboto.woff2)&#39;</span>
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>fontFace</span>.<span style=color:#a6e22e>family</span> <span style=color:#75715e>// &#34;Roboto&#34;
</span></span></span></code></pre></div><p><code>FontFace()</code>返回的是一个字体对象，这个对象包含字体信息。注意，这时字体文件还没有开始加载。</p><p>字体对象包含以下属性。</p><ul><li><code>FontFace.family</code>：字符串，表示字体的名字，等同于 CSS 的<code>font-family</code>属性。</li><li><code>FontFace.display</code>：字符串，指定字体加载期间如何展示，等同于 CSS 的<code>font-display</code>属性。它有五个可能的值：<code>auto</code>（由浏览器决定）、<code>block</code>（字体加载期间，前3秒会显示不出内容，然后只要还没完成加载，就一直显示后备字体）、<code>fallback</code>（前100毫秒显示不出内容，后3秒显示后备字体，然后只要字体还没完成加载，就一直显示后备字体）、<code>optional</code>（前100毫秒显示不出内容，然后只要字体还没有完成加载，就一直显示后备字体），<code>swap</code>（只要字体没有完成加载，就一直显示后备字体）。</li><li><code>FontFace.style</code>：字符串，等同于 CSS 的<code>font-style</code>属性。</li><li><code>FontFace.weight</code>：字符串，等同于 CSS 的<code>font-weight</code>属性。</li><li><code>FontFace.stretch</code>：字符串，等同于 CSS 的<code>font-strentch</code>属性。</li><li><code>FontFace.unicodeRange</code>：字符串，等同于<code>descriptors</code>对象的同名属性。</li><li><code>FontFace.variant</code>：字符串，等同于<code>descriptors</code>对象的同名属性。</li><li><code>FontFace.featureSettings</code>：字符串，等同于<code>descriptors</code>对象的同名属性。</li><li><code>FontFace.status</code>：字符串，表示字体的加载状态，有四个可能的值：<code>unloaded</code>、<code>loading</code>、<code>loaded</code>、<code>error</code>。该属性只读。</li><li><code>FontFace.loaded</code>：返回一个 Promise 对象，字体加载成功或失败，会导致该 Promise 状态改变。该属性只读。</li></ul><p>字体对象的方法，只有一个<code>FontFace.load()</code>，该方法会真正开始加载字体。它返回一个 Promise 对象，状态由字体加载的结果决定。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>f</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>FontFace</span>(<span style=color:#e6db74>&#39;test&#39;</span>, <span style=color:#e6db74>&#39;url(x)&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>load</span>().<span style=color:#a6e22e>then</span>(<span style=color:#66d9ef>function</span> () {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 网页可以开始使用该字体
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>});
</span></span></code></pre></div><h2 id=geolocation-api>Geolocation API
<a class=header-anchor href=#geolocation-api></a></h2><p>Geolocation API 用于获取用户的地理位置。</p><p>由于该功能涉及用户隐私，所以浏览器会提示用户，是否同意给出地理位置，用户可能会拒绝。另外，这个 API 只能在 HTTPS 环境使用。</p><p>浏览器通过<code>navigator.geolocation</code>属性提供该 API。</p><h3 id=geolocation-对象>Geolocation 对象
<a class=header-anchor href=#geolocation-%e5%af%b9%e8%b1%a1></a></h3><p><code>navigator.geolocation</code>属性返回一个 Geolocation 对象。该对象具有以下三个方法。</p><ul><li><code>Geolocation.getCurrentPosition()</code>：返回一个 Position 对象，表示用户的当前位置。</li><li><code>Geolocation.watchPosition()</code>：指定一个监听函数，每当用户的位置发生变化，就执行该监听函数。</li><li><code>Geolocation.clearWatch()</code>：取消<code>watchPosition()</code>方法指定的监听函数。</li></ul><h4 id=geolocationgetcurrentposition>Geolocation.getCurrentPosition()
<a class=header-anchor href=#geolocationgetcurrentposition></a></h4><p><code>Geolocation.getCurrentPosition()</code>方法用于获取用户的位置。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>geolocation</span>.<span style=color:#a6e22e>getCurrentPosition</span>(<span style=color:#a6e22e>success</span>, <span style=color:#a6e22e>error</span>, <span style=color:#a6e22e>options</span>)
</span></span></code></pre></div><p>该方法接受三个参数。</p><ul><li><code>success</code>：用户同意给出位置时的回调函数，它的参数是一个 Position 对象。</li><li><code>error</code>：用户拒绝给出位置时的回调函数，它的参数是一个 PositionError 对象。该参数可选。</li><li><code>options</code>：参数对象，该参数可选。</li></ul><p>Position 对象有两个属性。</p><ul><li><code>Position.coords</code>：返回一个 Coordinates 对象，表示当前位置的坐标。</li><li><code>Position.timestamp</code>：返回一个对象，代表当前时间戳。</li></ul><p>PositionError 对象主要有两个属性。</p><ul><li><code>PositionError.code</code>：整数，表示发生错误的原因。<code>1</code>表示无权限，有可能是用户拒绝授权；<code>2</code>表示无法获得位置，可能设备有故障；<code>3</code>表示超时。</li><li><code>PositionError.message</code>：字符串，表示错误的描述。</li></ul><p>参数对象<code>option</code>可以指定三个属性。</p><ul><li><code>enableHighAccuracy</code>：布尔值，是否返回高精度结果。如果设为<code>true</code>，可能导致响应时间变慢或（移动设备的）功耗增加；反之，如果设为<code>false</code>，设备可以更快速地响应。默认值为<code>false</code>。</li><li><code>timeout</code>：正整数，表示等待查询的最长时间，单位为毫秒。默认值为<code>Infinity</code>。</li><li><code>maximumAge</code>：正整数，表示可接受的缓存最长时间，单位为毫秒。如果设为<code>0</code>，表示不返回缓存值，必须查询当前的实际位置；如果设为<code>Infinity</code>，必须返回缓存值，不管缓存了多少时间。默认值为<code>0</code>。</li></ul><p>下面是一个例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>options</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>enableHighAccuracy</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>timeout</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>5000</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>maximumAge</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>success</span>(<span style=color:#a6e22e>pos</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>crd</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>pos</span>.<span style=color:#a6e22e>coords</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`经度：</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>crd</span>.<span style=color:#a6e22e>latitude</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`纬度：</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>crd</span>.<span style=color:#a6e22e>longitude</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`误差：</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>crd</span>.<span style=color:#a6e22e>accuracy</span><span style=color:#e6db74>}</span><span style=color:#e6db74> 米`</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>error</span>(<span style=color:#a6e22e>err</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>warn</span>(<span style=color:#e6db74>`ERROR(</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>code</span><span style=color:#e6db74>}</span><span style=color:#e6db74>): </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>message</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>geolocation</span>.<span style=color:#a6e22e>getCurrentPosition</span>(<span style=color:#a6e22e>success</span>, <span style=color:#a6e22e>error</span>, <span style=color:#a6e22e>options</span>);
</span></span></code></pre></div><h4 id=geolocationwatchposition>Geolocation.watchPosition()
<a class=header-anchor href=#geolocationwatchposition></a></h4><p><code>Geolocation.watchPosition()</code>对象指定一个监听函数，每当用户的位置发生变化，就是自动执行这个函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>geolocation</span>.<span style=color:#a6e22e>watchPosition</span>(<span style=color:#a6e22e>success</span>[, <span style=color:#a6e22e>error</span>[, <span style=color:#a6e22e>options</span>]])
</span></span></code></pre></div><p>该方法接受三个参数。</p><ul><li><code>success</code>：监听成功的回调函数，该函数的参数为一个 Position 对象。</li><li><code>error</code>：该参数可选，表示监听失败的回调函数，该函数的参数是一个 PositionError 对象。</li><li><code>options</code>：该参数可选，表示监听的参数配置对象。</li></ul><p>该方法返回一个整数值，表示监听函数的编号。该整数用来供<code>Geolocation.clearWatch()</code>方法取消监听。</p><p>下面是一个例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>id</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>target</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>latitude</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>longitude</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>options</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>enableHighAccuracy</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>timeout</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>5000</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>maximumAge</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>success</span>(<span style=color:#a6e22e>pos</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>crd</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>pos</span>.<span style=color:#a6e22e>coords</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>latitude</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>crd</span>.<span style=color:#a6e22e>latitude</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>longitude</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>crd</span>.<span style=color:#a6e22e>longitude</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;恭喜，你已经到达了指定位置。&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>geolocation</span>.<span style=color:#a6e22e>clearWatch</span>(<span style=color:#a6e22e>id</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>error</span>(<span style=color:#a6e22e>err</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>warn</span>(<span style=color:#e6db74>&#39;ERROR(&#39;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>code</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;): &#39;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>message</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>id</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>geolocation</span>.<span style=color:#a6e22e>watchPosition</span>(<span style=color:#a6e22e>success</span>, <span style=color:#a6e22e>error</span>, <span style=color:#a6e22e>options</span>);
</span></span></code></pre></div><h4 id=geolocationclearwatch>Geolocation.clearWatch()
<a class=header-anchor href=#geolocationclearwatch></a></h4><p><code>Geolocation.clearWatch()</code>方法用来取消<code>watchPosition()</code>方法指定的监听函数。它的参数是<code>watchPosition()</code>返回的监听函数的编号。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>geolocation</span>.<span style=color:#a6e22e>clearWatch</span>(<span style=color:#a6e22e>id</span>);
</span></span></code></pre></div><p>使用方法的例子见上一节。</p><h3 id=coordinates-对象>Coordinates 对象
<a class=header-anchor href=#coordinates-%e5%af%b9%e8%b1%a1></a></h3><p>Coordinates 对象是地理位置的坐标接口，<code>Position.coords</code>属性返回的就是这个对象。</p><p>它有以下属性，全部为只读属性。</p><ul><li><code>Coordinates.latitude</code>：浮点数，表示纬度。</li><li><code>Coordinates.longitude</code>：浮点数，表示经度。</li><li><code>Coordinates.altitude</code>：浮点数，表示海拔（单位：米）。如果不可得，返回<code>null</code>。</li><li><code>Coordinates.accuracy</code>：浮点数，表示经度和纬度的精度（单位：米）。</li><li><code>Coordinates.altitudeAccuracy</code>：浮点数，表示海拔的精度（单位：米）。返回<code>null</code>。</li><li><code>Coordinates.speed</code>：浮点数，表示设备的速度（单位：米/秒）。如果不可得，返回<code>null</code>。</li><li><code>Coordinates.heading</code>：浮点数，表示设备前进的方向（单位：度）。方向按照顺时针，北方是0度，东方是90度，西方是270度。如果<code>Coordinates.speed</code>为0，<code>heading</code>属性返回<code>NaN</code>。如果设备无法提供方向信息，该属性返回<code>null</code>。</li></ul><p>下面是一个例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>geolocation</span>.<span style=color:#a6e22e>getCurrentPosition</span>( <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>position</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>lat</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>position</span>.<span style=color:#a6e22e>coords</span>.<span style=color:#a6e22e>latitude</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>long</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>position</span>.<span style=color:#a6e22e>coords</span>.<span style=color:#a6e22e>longitude</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`纬度：</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>lat</span>.<span style=color:#a6e22e>toFixed</span>(<span style=color:#ae81ff>2</span>)<span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`经度：</span><span style=color:#e6db74>${</span><span style=color:#66d9ef>long</span>.<span style=color:#a6e22e>toFixed</span>(<span style=color:#ae81ff>2</span>)<span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h3 id=参考链接-3>参考链接
<a class=header-anchor href=#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5-3></a></h3><ul><li><a href=https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API title="Geolocation API" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Geolocation API
<i class="fa fa-external-link-alt"></i>
</a>, by MDN</li></ul><h2 id=intersectionobserver>IntersectionObserver
<a class=header-anchor href=#intersectionobserver></a></h2><p>网页开发时，常常需要了解某个元素是否进入了“视口”（viewport），即用户能不能看到它。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071415512.gif alt></p><p>上图的绿色方块不断滚动，顶部会提示它的可见性。</p><p>传统的实现方法是，监听到<code>scroll</code>事件后，调用目标元素（绿色方块）的
<a href=https://developer.mozilla.org/en/docs/Web/API/Element/getBoundingClientRect title="<code>getBoundingClientRect()</code>" rel="noopener external nofollow noreferrer" target=_blank class=exturl><code>getBoundingClientRect()</code>
<i class="fa fa-external-link-alt"></i>
</a>方法，得到它对应于视口左上角的坐标，再判断是否在视口之内。这种方法的缺点是，由于<code>scroll</code>事件密集发生，计算量很大，容易造成
<a href=http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html title=性能问题 rel="noopener external nofollow noreferrer" target=_blank class=exturl>性能问题
<i class="fa fa-external-link-alt"></i>
</a>。</p><p><a href=https://wicg.github.io/IntersectionObserver/ title="IntersectionObserver API" rel="noopener external nofollow noreferrer" target=_blank class=exturl>IntersectionObserver API
<i class="fa fa-external-link-alt"></i>
</a>，可以自动“观察”元素是否可见，Chrome 51+ 已经支持。由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做“交叉观察器”（intersection oberserver）。</p><h3 id=简介-1>简介
<a class=header-anchor href=#%e7%ae%80%e4%bb%8b-1></a></h3><p>IntersectionObserver API 的用法，简单来说就是两行。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>observer</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>IntersectionObserver</span>(<span style=color:#a6e22e>callback</span>, <span style=color:#a6e22e>options</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>observer</span>.<span style=color:#a6e22e>observe</span>(<span style=color:#a6e22e>target</span>);
</span></span></code></pre></div><p>上面代码中，<code>IntersectionObserver</code>是浏览器原生提供的构造函数，接受两个参数：<code>callback</code>是可见性变化时的回调函数，<code>option</code>是配置对象（该参数可选）。</p><p><code>IntersectionObserver()</code>的返回值是一个观察器实例。实例的<code>observe()</code>方法可以指定观察哪个 DOM 节点。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 开始观察
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>observer</span>.<span style=color:#a6e22e>observe</span>(document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;example&#39;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 停止观察
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>observer</span>.<span style=color:#a6e22e>unobserve</span>(<span style=color:#a6e22e>element</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 关闭观察器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>observer</span>.<span style=color:#a6e22e>disconnect</span>();
</span></span></code></pre></div><p>上面代码中，<code>observe()</code>的参数是一个 DOM 节点对象。如果要观察多个节点，就要多次调用这个方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>observer</span>.<span style=color:#a6e22e>observe</span>(<span style=color:#a6e22e>elementA</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>observer</span>.<span style=color:#a6e22e>observe</span>(<span style=color:#a6e22e>elementB</span>);
</span></span></code></pre></div><p>注意，IntersectionObserver API 是异步的，不随着目标元素的滚动同步触发。规格写明，<code>IntersectionObserver</code>的实现，应该采用<code>requestIdleCallback()</code>，即只有线程空闲下来，才会执行观察器。这意味着，这个观察器的优先级非常低，只在其他任务执行完，浏览器有了空闲才会执行。</p><h3 id=intersectionobserverobserve>IntersectionObserver.observe()
<a class=header-anchor href=#intersectionobserverobserve></a></h3><p>IntersectionObserver 实例的<code>observe()</code>方法用来启动对一个 DOM 元素的观察。该方法接受两个参数：回调函数<code>callback</code>和配置对象<code>options</code>。</p><h4 id=callback-参数>callback 参数
<a class=header-anchor href=#callback-%e5%8f%82%e6%95%b0></a></h4><p>目标元素的可见性变化时，就会调用观察器的回调函数<code>callback</code>。</p><p><code>callback</code>会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>observer</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>IntersectionObserver</span>(
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>entries</span>, <span style=color:#a6e22e>observer</span>) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>entries</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>上面代码中，回调函数采用的是
<a href=http://es6.ruanyifeng.com/##docs/function##%e7%ae%ad%e5%a4%b4%e5%87%bd%e6%95%b0 title=箭头函数 rel="noopener external nofollow noreferrer" target=_blank class=exturl>箭头函数
<i class="fa fa-external-link-alt"></i>
</a>的写法。<code>callback</code>函数的参数（<code>entries</code>）是一个数组，每个成员都是一个
<a href=https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry title="<code>IntersectionObserverEntry</code>" rel="noopener external nofollow noreferrer" target=_blank class=exturl><code>IntersectionObserverEntry</code>
<i class="fa fa-external-link-alt"></i>
</a>对象（详见下文）。举例来说，如果同时有两个被观察的对象的可见性发生变化，<code>entries</code>数组就会有两个成员。</p><h4 id=intersectionobserverentry-对象>IntersectionObserverEntry 对象
<a class=header-anchor href=#intersectionobserverentry-%e5%af%b9%e8%b1%a1></a></h4><p><code>IntersectionObserverEntry</code>对象提供目标元素的信息，一共有六个属性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>time</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>3893.92</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>rootBounds</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>ClientRect</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>bottom</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>920</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>height</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1024</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>left</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>right</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1024</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>top</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>width</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>920</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>boundingClientRect</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>ClientRect</span> {
</span></span><span style=display:flex><span>     <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>intersectionRect</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>ClientRect</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>intersectionRatio</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0.54</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>target</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>element</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>每个属性的含义如下。</p><blockquote><ul><li><code>time</code>：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒</li><li><code>target</code>：被观察的目标元素，是一个 DOM 节点对象</li><li><code>rootBounds</code>：容器元素的矩形区域的信息，<code>getBoundingClientRect()</code>方法的返回值，如果没有容器元素（即直接相对于视口滚动），则返回<code>null</code></li><li><code>boundingClientRect</code>：目标元素的矩形区域的信息</li><li><code>intersectionRect</code>：目标元素与视口（或容器元素）的交叉区域的信息</li><li><code>intersectionRatio</code>：目标元素的可见比例，即<code>intersectionRect</code>占<code>boundingClientRect</code>的比例，完全可见时为<code>1</code>，完全不可见时小于等于<code>0</code></li></ul></blockquote><p><img src=/imgs/img-lazy-loading.gif data-src=https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071415501.png alt></p><p>上图中，灰色的水平方框代表视口，深红色的区域代表四个被观察的目标元素。它们各自的<code>intersectionRatio</code>图中都已经注明。</p><p>我写了一个
<a href=http://jsbin.com/canuze/edit?js,console,output title=Demo rel="noopener external nofollow noreferrer" target=_blank class=exturl>Demo
<i class="fa fa-external-link-alt"></i>
</a>，演示<code>IntersectionObserverEntry</code>对象。注意，这个 Demo 只能在 Chrome 51+ 运行。</p><h4 id=option-对象>Option 对象
<a class=header-anchor href=#option-%e5%af%b9%e8%b1%a1></a></h4><p><code>IntersectionObserver</code>构造函数的第二个参数是一个配置对象。它可以设置以下属性。</p><p><strong>（1）threshold 属性</strong></p><p><code>threshold</code>属性决定了什么时候触发回调函数，即元素进入视口（或者容器元素）多少比例时，执行回调函数。它是一个数组，每个成员都是一个门槛值，默认为<code>[0]</code>，即交叉比例（<code>intersectionRatio</code>）达到<code>0</code>时触发回调函数。</p><p>如果<code>threshold</code>属性是0.5，当元素进入视口50%时，触发回调函数。如果值为<code>[0.3, 0.6]</code>，则当元素进入30％和60％是触发回调函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>new</span> <span style=color:#a6e22e>IntersectionObserver</span>(
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>entries</span> =&gt; {<span style=color:#75715e>/* … */</span>},
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>threshold</span><span style=color:#f92672>:</span> [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0.25</span>, <span style=color:#ae81ff>0.5</span>, <span style=color:#ae81ff>0.75</span>, <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>用户可以自定义这个数组。比如，上例的<code>[0, 0.25, 0.5, 0.75, 1]</code>就表示当目标元素 0%、25%、50%、75%、100% 可见时，会触发回调函数。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071415506.gif alt></p><p><strong>（2）root 属性，rootMargin 属性</strong></p><p><code>IntersectionObserver</code>不仅可以观察元素相对于视口的可见性，还可以观察元素相对于其所在容器的可见性。容器内滚动也会影响目标元素的可见性，参见本文开始时的那张示意图。</p><p>IntersectionObserver API 支持容器内滚动。<code>root</code>属性指定目标元素所在的容器节点。注意，容器元素必须是目标元素的祖先节点。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>opts</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>root</span><span style=color:#f92672>:</span> document.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;.container&#39;</span>),
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>rootMargin</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;0px 0px -200px 0px&#39;</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>observer</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>IntersectionObserver</span>(
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>callback</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>opts</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>上面代码中，除了<code>root</code>属性，还有
<a href=https://wicg.github.io/IntersectionObserver/##dom-intersectionobserverinit-rootmargin title="<code>rootMargin</code>" rel="noopener external nofollow noreferrer" target=_blank class=exturl><code>rootMargin</code>
<i class="fa fa-external-link-alt"></i>
</a>属性。该属性用来扩展或缩小<code>rootBounds</code>这个矩形的大小，从而影响<code>intersectionRect</code>交叉区域的大小。它的写法类似于 CSS 的<code>margin</code>属性，比如<code>0px 0px 0px 0px</code>，依次表示 top、right、bottom 和 left 四个方向的值。</p><p>上例的<code>0px 0px -200px 0px</code>，表示容器的下边缘向上收缩200像素，导致页面向下滚动时，目标元素的顶部进入可视区域200像素以后，才会触发回调函数。</p><p>这样设置以后，不管是窗口滚动或者容器内滚动，只要目标元素可见性变化，都会触发观察器。</p><h3 id=实例>实例
<a class=header-anchor href=#%e5%ae%9e%e4%be%8b></a></h3><h4 id=惰性加载lazy-load>惰性加载（lazy load）
<a class=header-anchor href=#%e6%83%b0%e6%80%a7%e5%8a%a0%e8%bd%bdlazy-load></a></h4><p>有时，我们希望某些静态资源（比如图片），只有用户向下滚动，它们进入视口时才加载，这样可以节省带宽，提高网页性能。这就叫做“惰性加载”。</p><p>有了 IntersectionObserver API，实现起来就很容易了。图像的 HTML 代码可以写成下面这样。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>img</span> <span style=color:#a6e22e>src</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;placeholder.png&#34;</span> <span style=color:#a6e22e>data-src</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;img-1.jpg&#34;</span>&gt;
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>img</span> <span style=color:#a6e22e>src</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;placeholder.png&#34;</span> <span style=color:#a6e22e>data-src</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;img-2.jpg&#34;</span>&gt;
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>img</span> <span style=color:#a6e22e>src</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;placeholder.png&#34;</span> <span style=color:#a6e22e>data-src</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;img-3.jpg&#34;</span>&gt;
</span></span></code></pre></div><p>上面代码中，图像默认显示一个占位符，<code>data-src</code>属性是惰性加载的真正图像。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>query</span>(<span style=color:#a6e22e>selector</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> Array.<span style=color:#a6e22e>from</span>(document.<span style=color:#a6e22e>querySelectorAll</span>(<span style=color:#a6e22e>selector</span>));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>observer</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>IntersectionObserver</span>(
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>entries</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>entries</span>.<span style=color:#a6e22e>forEach</span>(<span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>entry</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>entry</span>.<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>src</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>entry</span>.<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>dataset</span>.<span style=color:#a6e22e>src</span>;
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>observer</span>.<span style=color:#a6e22e>unobserve</span>(<span style=color:#a6e22e>entry</span>.<span style=color:#a6e22e>target</span>);
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>query</span>(<span style=color:#e6db74>&#39;.lazy-loaded&#39;</span>).<span style=color:#a6e22e>forEach</span>(<span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>item</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>observer</span>.<span style=color:#a6e22e>observe</span>(<span style=color:#a6e22e>item</span>);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>上面代码中，只有图像开始可见时，才会加载真正的图像文件。</p><h4 id=无限滚动>无限滚动
<a class=header-anchor href=#%e6%97%a0%e9%99%90%e6%bb%9a%e5%8a%a8></a></h4><p>无限滚动（infinite scroll）指的是，随着网页滚动到底部，不断加载新的内容到页面，它的实现也很简单。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>intersectionObserver</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>IntersectionObserver</span>(
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>entries</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果不可见，就返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>entries</span>[<span style=color:#ae81ff>0</span>].<span style=color:#a6e22e>intersectionRatio</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>loadItems</span>(<span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;Loaded new items&#39;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 开始观察
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>intersectionObserver</span>.<span style=color:#a6e22e>observe</span>(
</span></span><span style=display:flex><span>  document.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;.scrollerFooter&#39;</span>)
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>无限滚动时，最好像上例那样，页面底部有一个页尾栏（又称
<a href=sentinels title=sentinels>sentinels
</a>，上例是<code>.scrollerFooter</code>）。一旦页尾栏可见，就表示用户到达了页面底部，从而加载新的条目放在页尾栏前面。否则就需要每一次页面加入新内容时，都调用<code>observe()</code>方法，对新增内容的底部建立观察。</p><h4 id=视频自动播放>视频自动播放
<a class=header-anchor href=#%e8%a7%86%e9%a2%91%e8%87%aa%e5%8a%a8%e6%92%ad%e6%94%be></a></h4><p>下面是一个视频元素，希望它完全进入视口的时候自动播放，离开视口的时候自动暂停。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>video</span> <span style=color:#a6e22e>src</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;foo.mp4&#34;</span> <span style=color:#a6e22e>controls</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>&gt;&lt;/<span style=color:#f92672>video</span>&gt;
</span></span></code></pre></div><p>下面是 JS 代码。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>video</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;video&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>isPaused</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>observer</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>IntersectionObserver</span>((<span style=color:#a6e22e>entries</span>, <span style=color:#a6e22e>observer</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>entries</span>.<span style=color:#a6e22e>forEach</span>(<span style=color:#a6e22e>entry</span> =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>entry</span>.<span style=color:#a6e22e>intersectionRatio</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>1</span>  <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span><span style=color:#a6e22e>video</span>.<span style=color:#a6e22e>paused</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>video</span>.<span style=color:#a6e22e>pause</span>();
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>isPaused</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>isPaused</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>video</span>.<span style=color:#a6e22e>play</span>();
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>isPaused</span><span style=color:#f92672>=</span><span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>}, {<span style=color:#a6e22e>threshold</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>observer</span>.<span style=color:#a6e22e>observe</span>(<span style=color:#a6e22e>video</span>);
</span></span></code></pre></div><p>上面代码中，<code>IntersectionObserver()</code>的第二个参数是配置对象，它的<code>threshold</code>属性等于<code>1</code>，即目标元素完全可见时触发回调函数。</p><h3 id=参考链接-4>参考链接
<a class=header-anchor href=#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5-4></a></h3><ul><li><a href=https://developers.google.com/web/updates/2016/04/intersectionobserver title="IntersectionObserver’s Coming into View" rel="noopener external nofollow noreferrer" target=_blank class=exturl>IntersectionObserver’s Coming into View
<i class="fa fa-external-link-alt"></i></a></li><li><a href=https://github.com/WICG/IntersectionObserver/blob/gh-pages/explainer.md title="Intersection Observers Explained" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Intersection Observers Explained
<i class="fa fa-external-link-alt"></i></a></li><li><a href=https://css-tricks.com/a-few-functional-uses-for-intersection-observer-to-know-when-an-element-is-in-view/ title="A Few Functional Uses for Intersection Observer to Know When an Element is in View" rel="noopener external nofollow noreferrer" target=_blank class=exturl>A Few Functional Uses for Intersection Observer to Know When an Element is in View
<i class="fa fa-external-link-alt"></i>
</a>, Preethi</li></ul><h2 id=intlrelativetimeformat>Intl.RelativeTimeFormat
<a class=header-anchor href=#intlrelativetimeformat></a></h2><p>很多日期库支持显示相对时间，比如“昨天”、“五分钟前”、“两个月之前”等等。由于不同的语言，日期显示的格式和相关词语都不同，造成这些库的体积非常大。</p><p>现在，浏览器提供内置的 Intl.RelativeTimeFormat API，可以不使用这些库，直接显示相对时间。</p><h3 id=基本用法-1>基本用法
<a class=header-anchor href=#%e5%9f%ba%e6%9c%ac%e7%94%a8%e6%b3%95-1></a></h3><p><code>Intl.RelativeTimeFormat()</code>是一个构造函数，接受一个语言代码作为参数，返回一个相对时间的实例对象。如果省略参数，则默认传入当前运行时的语言代码。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>rtf</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Intl</span>.<span style=color:#a6e22e>RelativeTimeFormat</span>(<span style=color:#e6db74>&#39;en&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#ae81ff>3.14</span>, <span style=color:#e6db74>&#39;second&#39;</span>) <span style=color:#75715e>// &#34;in 3.14 seconds&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>15</span>, <span style=color:#e6db74>&#39;minute&#39;</span>) <span style=color:#75715e>// &#34;15 minutes ago&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#ae81ff>8</span>, <span style=color:#e6db74>&#39;hour&#39;</span>) <span style=color:#75715e>// &#34;in 8 hours&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>, <span style=color:#e6db74>&#39;day&#39;</span>) <span style=color:#75715e>// &#34;2 days ago&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#ae81ff>3</span>, <span style=color:#e6db74>&#39;week&#39;</span>) <span style=color:#75715e>// &#34;in 3 weeks&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>5</span>, <span style=color:#e6db74>&#39;month&#39;</span>) <span style=color:#75715e>// &#34;5 months ago&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#ae81ff>2</span>, <span style=color:#e6db74>&#39;quarter&#39;</span>) <span style=color:#75715e>// &#34;in 2 quarters&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>42</span>, <span style=color:#e6db74>&#39;year&#39;</span>) <span style=color:#75715e>// &#34;42 years ago&#34;
</span></span></span></code></pre></div><p>上面代码指定使用英语显示相对时间。</p><p>下面是使用西班牙语显示相对时间的例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>rtf</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Intl</span>.<span style=color:#a6e22e>RelativeTimeFormat</span>(<span style=color:#e6db74>&#39;es&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#ae81ff>3.14</span>, <span style=color:#e6db74>&#39;second&#39;</span>) <span style=color:#75715e>// &#34;dentro de 3,14 segundos&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>15</span>, <span style=color:#e6db74>&#39;minute&#39;</span>) <span style=color:#75715e>// &#34;hace 15 minutos&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#ae81ff>8</span>, <span style=color:#e6db74>&#39;hour&#39;</span>) <span style=color:#75715e>// &#34;dentro de 8 horas&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>, <span style=color:#e6db74>&#39;day&#39;</span>) <span style=color:#75715e>// &#34;hace 2 días&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#ae81ff>3</span>, <span style=color:#e6db74>&#39;week&#39;</span>) <span style=color:#75715e>// &#34;dentro de 3 semanas&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>5</span>, <span style=color:#e6db74>&#39;month&#39;</span>) <span style=color:#75715e>// &#34;hace 5 meses&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#ae81ff>2</span>, <span style=color:#e6db74>&#39;quarter&#39;</span>) <span style=color:#75715e>// &#34;dentro de 2 trimestres&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>42</span>, <span style=color:#e6db74>&#39;year&#39;</span>) <span style=color:#75715e>// &#34;hace 42 años&#34;
</span></span></span></code></pre></div><p><code>Intl.RelativeTimeFormat()</code>还可以接受一个配置对象，作为第二个参数，用来精确指定相对时间实例的行为。配置对象共有下面这些属性。</p><ul><li>options.style：表示返回字符串的风格，可能的值有<code>long</code>（默认值，比如“in 1 month”）、<code>short</code>（比如“in 1 mo.”）、<code>narrow</code>（比如“in 1 mo.”）。对于一部分语言来说，<code>narrow</code>风格和<code>short</code>风格是类似的。</li><li>options.localeMatcher：表示匹配语言参数的算法，可能的值有<code>best fit</code>（默认值）和<code>lookup</code>。</li><li>options.numeric：表示返回字符串是数字显示，还是文字显示，可能的值有<code>always</code>（默认值，总是文字显示）和<code>auto</code>（自动转换）。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 下面的配置对象，传入的都是默认值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>rtf</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Intl</span>.<span style=color:#a6e22e>RelativeTimeFormat</span>(<span style=color:#e6db74>&#39;en&#39;</span>, {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>localeMatcher</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;best fit&#39;</span>, <span style=color:#75715e>// 其他值：&#39;lookup&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>style</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;long&#39;</span>, <span style=color:#75715e>// 其他值：&#39;short&#39; or &#39;narrow&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>numeric</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;always&#39;</span>, <span style=color:#75715e>// 其他值：&#39;auto&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Now, let’s try some special cases!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#39;day&#39;</span>) <span style=color:#75715e>// &#34;1 day ago&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#39;day&#39;</span>) <span style=color:#75715e>// &#34;in 0 days&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#39;day&#39;</span>) <span style=color:#75715e>// &#34;in 1 day&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#39;week&#39;</span>) <span style=color:#75715e>// &#34;1 week ago&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#39;week&#39;</span>) <span style=color:#75715e>// &#34;in 0 weeks&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#39;week&#39;</span>) <span style=color:#75715e>// &#34;in 1 week&#34;
</span></span></span></code></pre></div><p>上面代码中，显示的是“1 day ago”，而不是“yesterday”；显示的是“in 0 weeks”，而不是“this week”。这是因为默认情况下，相对时间显示的是数值形式，而不是文字形式。</p><p>改变这个行为，可以把配置对象的<code>numeric</code>属性改成<code>auto</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>rtf</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Intl</span>.<span style=color:#a6e22e>RelativeTimeFormat</span>(<span style=color:#e6db74>&#39;en&#39;</span>, { <span style=color:#a6e22e>numeric</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;auto&#39;</span> });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#39;day&#39;</span>) <span style=color:#75715e>// &#34;yesterday&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#39;day&#39;</span>) <span style=color:#75715e>// &#34;today&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#39;day&#39;</span>) <span style=color:#75715e>// &#34;tomorrow&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#39;week&#39;</span>) <span style=color:#75715e>// &#34;last week&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#39;week&#39;</span>) <span style=color:#75715e>// &#34;this week&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#39;week&#39;</span>) <span style=color:#75715e>// &#34;next week&#34;
</span></span></span></code></pre></div><h3 id=intlrelativetimeformatprototypeformat>Intl.RelativeTimeFormat.prototype.format()
<a class=header-anchor href=#intlrelativetimeformatprototypeformat></a></h3><p>相对时间实例对象的<code>format</code>方法，接受两个参数，依次为时间间隔的数值和单位。其中，“单位”是一个字符串，可以接受以下八个值。</p><ul><li>year</li><li>quarter</li><li>month</li><li>week</li><li>day</li><li>hour</li><li>minute</li><li>second</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>rtf</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Intl</span>.<span style=color:#a6e22e>RelativeTimeFormat</span>(<span style=color:#e6db74>&#39;en&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;day&#34;</span>) <span style=color:#75715e>// &#34;yesterday&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#ae81ff>2.15</span>, <span style=color:#e6db74>&#34;day&#34;</span>) <span style=color:#75715e>// &#34;in 2.15 days
</span></span></span></code></pre></div><h3 id=intlrelativetimeformatprototypeformattoparts>Intl.RelativeTimeFormat.prototype.formatToParts()
<a class=header-anchor href=#intlrelativetimeformatprototypeformattoparts></a></h3><p>相对时间实例对象的<code>formatToParts()</code>方法的参数跟<code>format()</code>方法一样，但是返回的是一个数组，用来精确控制相对时间的每个部分。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>rtf</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Intl</span>.<span style=color:#a6e22e>RelativeTimeFormat</span>(<span style=color:#e6db74>&#39;en&#39;</span>, { <span style=color:#a6e22e>numeric</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;auto&#39;</span> });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#39;day&#39;</span>) 
</span></span><span style=display:flex><span><span style=color:#75715e>// &#34;yesterday&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>formatToParts</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#39;day&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// [{ type: &#34;literal&#34;, value: &#34;yesterday&#34; }]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>format</span>(<span style=color:#ae81ff>3</span>, <span style=color:#e6db74>&#39;week&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// &#34;in 3 weeks&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rtf</span>.<span style=color:#a6e22e>formatToParts</span>(<span style=color:#ae81ff>3</span>, <span style=color:#e6db74>&#39;week&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// [
</span></span></span><span style=display:flex><span><span style=color:#75715e>//   { type: &#39;literal&#39;, value: &#39;in &#39; },
</span></span></span><span style=display:flex><span><span style=color:#75715e>//   { type: &#39;integer&#39;, value: &#39;3&#39;, unit: &#39;week&#39; },
</span></span></span><span style=display:flex><span><span style=color:#75715e>//   { type: &#39;literal&#39;, value: &#39; weeks&#39; }
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ]
</span></span></span></code></pre></div><p>返回数组的每个成员都是一个对象，拥有两个属性。</p><ul><li>type：字符串，表示输出值的类型。</li><li>value：字符串，表示输出的内容。</li><li>unit：如果输出内容表示一个数值（即<code>type</code>属性不是<code>literal</code>），那么还会有<code>unit</code>属性，表示数值的单位。</li></ul><h3 id=参考链接-5>参考链接
<a class=header-anchor href=#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5-5></a></h3><ul><li><a href=https://developers.google.com/web/updates/2018/10/intl-relativetimeformat title="The Intl.RelativeTimeFormat API" rel="noopener external nofollow noreferrer" target=_blank class=exturl>The Intl.RelativeTimeFormat API
<i class="fa fa-external-link-alt"></i>
</a>, Mathias Bynens</li><li><a href=https://github.com/tc39/proposal-intl-relative-time##api title="Intl.RelativeTimeFormat API Specification" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Intl.RelativeTimeFormat API Specification
<i class="fa fa-external-link-alt"></i>
</a>, TC39</li></ul><h2 id=offline-应用>Offline 应用
<a class=header-anchor href=#offline-%e5%ba%94%e7%94%a8></a></h2><p>Web 应用不仅可以在浏览器缓存资源文件（HTML、CSS、JS 脚本、图片等），还可以把应用本身储存到浏览器。</p><p>缓存的资源文件必须在线使用，只有先从服务器加载网页，然后才能使用本地缓存；但是，应用一旦储存，就可以离线使用。另外，用户常规性地清除浏览器缓存，并不会清除储存的应用，除非用户显式地卸载或删除它们。</p><p>为了开启离线储存，必须创建一个 manifest 文件。该文件列出了所有需要储存的文件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>CACHE MANIFEST
</span></span><span style=display:flex><span>myapp.html
</span></span><span style=display:flex><span>myapp.js
</span></span><span style=display:flex><span>myapp.css
</span></span><span style=display:flex><span>/images/front_end/background.png
</span></span></code></pre></div><p>Manifest 文件的第一行必须是<code>CACHE MANIFEST</code>。然后，每一行列出一个需要储存的文件，它们的位置都是相对于 Manifest 文件的位置。空行会被忽略，以<code>##</code>开头的行是注释，也会被忽略。</p><p>这个文件的后缀名一般是<code>.appcache</code>。它的 MIME 类型必须是<code>text/cache-manifest</code>，如果服务器将其设为其他类型，就不会被浏览器缓存。</p><p>编写完这个文件以后，要将<code>&lt;html></code>元素的<code>manifest</code>属性指向它。浏览器加载这个网页的时候，就会读取这个 Manifest 文件，离线储存这个网页和相关的资源。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span><span style=color:#75715e>&lt;!DOCTYPE HTML&gt;</span>
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>html</span> <span style=color:#a6e22e>manifest</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;myapp.appcache&#34;</span>&gt;
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>head</span>&gt;...&lt;/<span style=color:#f92672>head</span>&gt;
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>body</span>&gt;...&lt;/<span style=color:#f92672>body</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>html</span>&gt;
</span></span></code></pre></div><p>如果一个 Web 应用有多个网页需要离线储存，那么每个网页都应该将<code>manifest</code>属性指向这个文件。一旦被储存，以后加载该网页的时候，就会从缓存里面加载。这时，只有 Manifest 文件里面列出的文件会被加载，其他文件不会。如果这时浏览器在线，浏览器就会去检查 Manifest 文件是否有新版本，如果有新版本，就会重新储存和更新该文件列出的资源。最方便的办法是在 Manifest 文件里面用注释列出版本号。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>CACHE MANIFEST
</span></span><span style=display:flex><span>## MyApp version 1
</span></span><span style=display:flex><span>MyApp.html
</span></span><span style=display:flex><span>MyApp.js
</span></span></code></pre></div><p>如果需要删除离线储存，只要删除 Manifest 文件，让其返回 404 状态码即可。</p><p>离线储存更新完成，会触发浏览器的<code>updateready</code>事件，可以对这个事件指定监听函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span>window.<span style=color:#a6e22e>applicationCache</span>.<span style=color:#a6e22e>onupdateready</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>reload</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>confirm</span>(<span style=color:#e6db74>&#39;新版本下载完成。是否需要重新加载？&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>reload</span>) <span style=color:#a6e22e>location</span>.<span style=color:#a6e22e>reload</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>脚本可以注册<code>online</code>和<code>offline</code>事件的监听函数，通过<code>navigator.onLine</code>属性，判断浏览器是否在线从而进行数据同步。</p><p>每次浏览器加载一个具有<code>manifest</code>属性的网页，浏览器就会触发一个<code>checking</code>事件，然后去加载 Manifest 文件。</p><ul><li>如果应用已经储存，并且 Manifest 文件没有变化，那么触发<code>noupdate</code>事件。</li><li>如果应用已经储存，并且 Manifest 文件有变化，那么触发<code>downloading</code>事件，浏览器重新下载所有离线资源。下载过程中，触发<code>progress</code>事件，下载结束触发<code>updateready</code>事件。</li><li>如果应用没有储存，下载结束将触发<code>cached</code>事件。</li><li>如果离线，无法检查 Manifest 文件，浏览器会触发一个<code>error</code>事件。</li><li>如果浏览器在线，而且应用已经储存，但是 Manifest 文件返回 404，浏览器触发<code>obsolete</code>事件，将储存的应用移除。</li></ul><p>所有这些事件都是可以取消的。监听函数可以返回<code>false</code>，取消这些事件的默认动作。</p><p><code>applicationCache. status</code>属性返回离线储存的状态。</p><ul><li>ApplicationCache.UNCACHED (0)
This application does not have a manifest attribute: it is not cached.</li><li>ApplicationCache.IDLE (1)
The manifest has been checked and this application is cached and up to date.</li><li>ApplicationCache.CHECKING (2)
The browser is checking the manifest file.</li><li>ApplicationCache.DOWNLOADING (3)
The browser is downloading and caching files listed in the manifest.</li><li>ApplicationCache.UPDATEREADY (4)
A new version of the application has been downloaded and cached.</li><li>ApplicationCache.OBSOLETE (5)
The manifest no longer exists and the cache will be deleted.</li></ul><h2 id=page-lifecycle-api>Page Lifecycle API
<a class=header-anchor href=#page-lifecycle-api></a></h2><p>Android、iOS 和最新的 Windows 系统可以随时自主地停止后台进程，及时释放系统资源。也就是说，网页可能随时被系统丢弃掉。以前的浏览器 API 完全没有考虑到这种情况，导致开发者根本没有办法监听到系统丢弃页面。</p><p>为了解决这个问题，W3C 新制定了一个 Page Lifecycle API，统一了网页从诞生到卸载的行为模式，并且定义了新的事件，允许开发者响应网页状态的各种转换。</p><p>有了这个 API，开发者就可以预测网页下一步的状态，从而进行各种针对性的处理。Chrome 68 支持这个 API，对于老式浏览器可以使用谷歌开发的兼容库
<a href=https://github.com/GoogleChromeLabs/page-lifecycle title=PageLifecycle.js rel="noopener external nofollow noreferrer" target=_blank class=exturl>PageLifecycle.js
<i class="fa fa-external-link-alt"></i>
</a>。</p><h3 id=生命周期阶段>生命周期阶段
<a class=header-anchor href=#%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e9%98%b6%e6%ae%b5></a></h3><p>网页的生命周期分成六个阶段，每个时刻只可能处于其中一个阶段。</p><p><img src=/imgs/img-lazy-loading.gif data-src=https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071415532.png alt></p><p><strong>（1）Active 阶段</strong></p><p>在 Active 阶段，网页处于可见状态，且拥有输入焦点。</p><p><strong>（2）Passive 阶段</strong></p><p>在 Passive 阶段，网页可见，但没有输入焦点，无法接受输入。UI 更新（比如动画）仍然在执行。该阶段只可能发生在桌面同时有多个窗口的情况。</p><p><strong>（3）Hidden 阶段</strong></p><p>在 Hidden 阶段，用户的桌面被其他窗口占据，网页不可见，但尚未冻结。UI 更新不再执行。</p><p><strong>（4）Terminated 阶段</strong></p><p>在 Terminated 阶段，由于用户主动关闭窗口，或者在同一个窗口前往其他页面，导致当前页面开始被浏览器卸载并从内存中清除。注意，这个阶段总是在 Hidden 阶段之后发生，也就是说，用户主动离开当前页面，总是先进入 Hidden 阶段，再进入 Terminated 阶段。</p><p>这个阶段会导致网页卸载，任何新任务都不会在这个阶段启动，并且如果运行时间太长，正在进行的任务可能会被终止。</p><p><strong>（5）Frozen 阶段</strong></p><p>如果网页处于 Hidden 阶段的时间过久，用户又不关闭网页，浏览器就有可能冻结网页，使其进入 Frozen 阶段。不过，也有可能，处于可见状态的页面长时间没有操作，也会进入 Frozen 阶段。</p><p>这个阶段的特征是，网页不会再被分配 CPU 计算资源。定时器、回调函数、网络请求、DOM 操作都不会执行，不过正在运行的任务会执行完。浏览器可能会允许 Frozen 阶段的页面，周期性复苏一小段时间，短暂变回 Hidden 状态，允许一小部分任务执行。</p><p><strong>（6）Discarded 阶段</strong></p><p>如果网页长时间处于 Frozen 阶段，用户又不唤醒页面，那么就会进入 Discarded 阶段，即浏览器自动卸载网页，清除该网页的内存占用。不过，Passive 阶段的网页如果长时间没有互动，也可能直接进入 Discarded 阶段。</p><p>这一般是在用户没有介入的情况下，由系统强制执行。任何类型的新任务或 JavaScript 代码，都不能在此阶段执行，因为这时通常处在资源限制的状况下。</p><p>网页被浏览器自动 Discarded 以后，它的 Tab 窗口还是在的。如果用户重新访问这个 Tab 页，浏览器将会重新向服务器发出请求，再一次重新加载网页，回到 Active 阶段。</p><h3 id=常见场景>常见场景
<a class=header-anchor href=#%e5%b8%b8%e8%a7%81%e5%9c%ba%e6%99%af></a></h3><p>以下是几个常见场景的网页生命周期变化。</p><p>（1）用户打开网页后，又切换到其他 App，但只过了一会又回到网页。</p><p>网页由 Active 变成 Hidden，又变回 Active。</p><p>（2）用户打开网页后，又切换到其他 App，并且长时候使用后者，导致系统自动丢弃网页。</p><p>网页由 Active 变成 Hidden，再变成 Frozen，最后 Discarded。</p><p>（3）用户打开网页后，又切换到其他 App，然后从任务管理器里面将浏览器进程清除。</p><p>网页由 Active 变成 Hidden，然后 Terminated。</p><p>（4）系统丢弃了某个 Tab 里面的页面后，用户重新打开这个 Tab。</p><p>网页由 Discarded 变成 Active。</p><h3 id=事件>事件
<a class=header-anchor href=#%e4%ba%8b%e4%bb%b6></a></h3><p>生命周期的各个阶段都有自己的事件，以供开发者指定监听函数。这些事件里面，只有两个是新定义的（<code>freeze</code>事件和<code>resume</code>事件），其它都是现有的。</p><p>注意，网页的生命周期事件是在所有帧（frame）触发，不管是底层的帧，还是内嵌的帧。也就是说，内嵌的<code>&lt;iframe></code>网页跟顶层网页一样，都会同时监听到下面的事件。</p><h4 id=focus-事件>focus 事件
<a class=header-anchor href=#focus-%e4%ba%8b%e4%bb%b6></a></h4><p><code>focus</code>事件在页面获得输入焦点时触发，比如网页从 Passive 阶段变为 Active 阶段。</p><h4 id=blur-事件>blur 事件
<a class=header-anchor href=#blur-%e4%ba%8b%e4%bb%b6></a></h4><p><code>blur</code>事件在页面失去输入焦点时触发，比如网页从 Active 阶段变为 Passive 阶段。</p><h4 id=visibilitychange-事件>visibilitychange 事件
<a class=header-anchor href=#visibilitychange-%e4%ba%8b%e4%bb%b6></a></h4><p><code>visibilitychange</code>事件在网页可见状态发生变化时触发，一般发生在以下几种场景。</p><blockquote><ul><li>用户隐藏页面（切换 Tab、最小化浏览器），页面由 Active 阶段变成 Hidden 阶段。</li><li>用户重新访问隐藏的页面，页面由 Hidden 阶段变成 Active 阶段。</li><li>用户关闭页面，页面会先进入 Hidden 阶段，然后进入 Terminated 阶段。</li></ul></blockquote><p>可以通过<code>document.onvisibilitychange</code>属性指定这个事件的回调函数。</p><h4 id=freeze-事件>freeze 事件
<a class=header-anchor href=#freeze-%e4%ba%8b%e4%bb%b6></a></h4><p><code>freeze</code>事件在网页进入 Frozen 阶段时触发。</p><p>可以通过<code>document.onfreeze</code>属性指定在进入 Frozen 阶段时调用的回调函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>handleFreeze</span>(<span style=color:#a6e22e>e</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Handle transition to FROZEN
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>document.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;freeze&#39;</span>, <span style=color:#a6e22e>handleFreeze</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>##</span> <span style=color:#a6e22e>或者</span>
</span></span><span style=display:flex><span>document.<span style=color:#a6e22e>onfreeze</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>() { <span style=color:#960050;background-color:#1e0010>…</span> }
</span></span></code></pre></div><p>这个事件的监听函数，最长只能运行500毫秒。并且只能复用已经打开的网络连接，不能发起新的网络请求。</p><p>注意，从 Frozen 阶段进入 Discarded 阶段，不会触发任何事件，无法指定回调函数，只能在进入 Frozen 阶段时指定回调函数。</p><h4 id=resume-事件>resume 事件
<a class=header-anchor href=#resume-%e4%ba%8b%e4%bb%b6></a></h4><p><code>resume</code>事件在网页离开 Frozen 阶段，变为 Active / Passive / Hidden 阶段时触发。</p><p><code>document.onresume</code>属性指的是页面离开 Frozen 阶段、进入可用状态时调用的回调函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>handleResume</span>(<span style=color:#a6e22e>e</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// handle state transition FROZEN -&gt; ACTIVE
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>document.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#34;resume&#34;</span>, <span style=color:#a6e22e>handleResume</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>##</span> <span style=color:#a6e22e>或者</span>
</span></span><span style=display:flex><span>document.<span style=color:#a6e22e>onresume</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>() { <span style=color:#960050;background-color:#1e0010>…</span> }
</span></span></code></pre></div><h4 id=pageshow-事件>pageshow 事件
<a class=header-anchor href=#pageshow-%e4%ba%8b%e4%bb%b6></a></h4><p><code>pageshow</code>事件在用户加载网页时触发。这时，有可能是全新的页面加载，也可能是从缓存中获取的页面。如果是从缓存中获取，则该事件对象的<code>event.persisted</code>属性为<code>true</code>，否则为<code>false</code>。</p><p>这个事件的名字有点误导，它跟页面的可见性其实毫无关系，只跟浏览器的 History 记录的变化有关。</p><h4 id=pagehide-事件>pagehide 事件
<a class=header-anchor href=#pagehide-%e4%ba%8b%e4%bb%b6></a></h4><p><code>pagehide</code>事件在用户离开当前网页、进入另一个网页时触发。它的前提是浏览器的 History 记录必须发生变化，跟网页是否可见无关。</p><p>如果浏览器能够将当前页面添加到缓存以供稍后重用，则事件对象的<code>event.persisted</code>属性为<code>true</code>。 如果为<code>true</code>。如果页面添加到了缓存，则页面进入 Frozen 状态，否则进入 Terminatied 状态。</p><h4 id=beforeunload-事件>beforeunload 事件
<a class=header-anchor href=#beforeunload-%e4%ba%8b%e4%bb%b6></a></h4><p><code>beforeunload</code>事件在窗口或文档即将卸载时触发。该事件发生时，文档仍然可见，此时卸载仍可取消。经过这个事件，网页进入 Terminated 状态。</p><h4 id=unload-事件>unload 事件
<a class=header-anchor href=#unload-%e4%ba%8b%e4%bb%b6></a></h4><p><code>unload</code>事件在页面正在卸载时触发。经过这个事件，网页进入 Terminated 状态。</p><h3 id=获取当前阶段>获取当前阶段
<a class=header-anchor href=#%e8%8e%b7%e5%8f%96%e5%bd%93%e5%89%8d%e9%98%b6%e6%ae%b5></a></h3><p>如果网页处于 Active、Passive 或 Hidden 阶段，可以通过下面的代码，获得网页当前的状态。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>getState</span> <span style=color:#f92672>=</span> () =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (document.<span style=color:#a6e22e>visibilityState</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;hidden&#39;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;hidden&#39;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (document.<span style=color:#a6e22e>hasFocus</span>()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;active&#39;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;passive&#39;</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>如果网页处于 Frozen 和 Terminated 状态，由于定时器代码不会执行，只能通过事件监听判断状态。进入 Frozen 阶段，可以监听<code>freeze</code>事件；进入 Terminated 阶段，可以监听<code>pagehide</code>事件。</p><h3 id=documentwasdiscarded>document.wasDiscarded
<a class=header-anchor href=#documentwasdiscarded></a></h3><p>如果某个选项卡处于 Frozen 阶段，就随时有可能被系统丢弃，进入 Discarded 阶段。如果后来用户再次点击该选项卡，浏览器会重新加载该页面。</p><p>这时，开发者可以通过判断<code>document.wasDiscarded</code>属性，了解先前的网页是否被丢弃了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>if</span> (document.<span style=color:#a6e22e>wasDiscarded</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 该网页已经不是原来的状态了，曾经被浏览器丢弃过
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 恢复以前的状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>getPersistedState</span>(<span style=color:#a6e22e>self</span>.<span style=color:#a6e22e>discardedClientId</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>同时，<code>window</code>对象上会新增<code>window.clientId</code>和<code>window.discardedClientId</code>两个属性，用来恢复丢弃前的状态。</p><h3 id=参考链接-6>参考链接
<a class=header-anchor href=#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5-6></a></h3><ul><li><a href=https://developers.google.com/web/updates/2018/07/page-lifecycle-api title="Page Lifecycle API" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Page Lifecycle API
<i class="fa fa-external-link-alt"></i>
</a>, Philip Walton</li><li><a href=https://github.com/WICG/page-lifecycle title="Lifecycle API for Web Pages" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Lifecycle API for Web Pages
<i class="fa fa-external-link-alt"></i>
</a>, W3C</li><li><a href=https://wicg.github.io/page-lifecycle/spec.html title="Page Lifecycle 1 Editor’s Draft" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Page Lifecycle 1 Editor’s Draft
<i class="fa fa-external-link-alt"></i>
</a>, W3C</li></ul><h2 id=page-visibility-api>Page Visibility API
<a class=header-anchor href=#page-visibility-api></a></h2><h3 id=简介-2>简介
<a class=header-anchor href=#%e7%ae%80%e4%bb%8b-2></a></h3><p>有时候，开发者需要知道，用户正在离开页面。常用的方法是监听下面三个事件。</p><blockquote><ul><li><code>pagehide</code></li><li><code>beforeunload</code></li><li><code>unload</code></li></ul></blockquote><p>但是，这些事件在手机上可能不会触发，页面就直接关闭了。因为手机系统可以将一个进程直接转入后台，然后杀死。</p><blockquote><ul><li>用户点击了一条系统通知，切换到另一个 App。</li><li>用户进入任务切换窗口，切换到另一个 App。</li><li>用户点击了 Home 按钮，切换回主屏幕。</li><li>操作系统自动切换到另一个 App（比如，收到一个电话）。</li></ul></blockquote><p>上面这些情况，都会导致手机将浏览器进程切换到后台，然后为了节省资源，可能就会杀死浏览器进程。</p><p>以前，页面被系统切换，以及系统清除浏览器进程，是无法监听到的。开发者想要指定，任何一种页面卸载情况下都会执行的代码，也是无法做到的。为了解决这个问题，就诞生了 Page Visibility API。不管手机或桌面电脑，所有情况下，这个 API 都会监听到页面的可见性发生变化。</p><p>这个新的 API 的意义在于，通过监听网页的可见性，可以预判网页的卸载，还可以用来节省资源，减缓电能的消耗。比如，一旦用户不看网页，下面这些网页行为都是可以暂停的。</p><blockquote><ul><li>对服务器的轮询</li><li>网页动画</li><li>正在播放的音频或视频</li></ul></blockquote><h3 id=documentvisibilitystate>document.visibilityState
<a class=header-anchor href=#documentvisibilitystate></a></h3><p>这个 API 主要在<code>document</code>对象上，新增了一个<code>document.visibilityState</code>属性。该属性返回一个字符串，表示页面当前的可见性状态，共有三个可能的值。</p><blockquote><ul><li><code>hidden</code>：页面彻底不可见。</li><li><code>visible</code>：页面至少一部分可见。</li><li><code>prerender</code>：页面即将或正在渲染，处于不可见状态。</li></ul></blockquote><p>其中，<code>hidden</code>状态和<code>visible</code>状态是所有浏览器都必须支持的。<code>prerender</code>状态只在支持“预渲染”的浏览器上才会出现，比如 Chrome 浏览器就有预渲染功能，可以在用户不可见的状态下，预先把页面渲染出来，等到用户要浏览的时候，直接展示渲染好的网页。</p><p>只要页面可见，哪怕只露出一个角，<code>document.visibilityState</code>属性就返回<code>visible</code>。只有以下四种情况，才会返回<code>hidden</code>。</p><blockquote><ul><li>浏览器最小化。</li><li>浏览器没有最小化，但是当前页面切换成了背景页。</li><li>浏览器将要卸载（unload）页面。</li><li>操作系统触发锁屏屏幕。</li></ul></blockquote><p>可以看到，上面四种场景涵盖了页面可能被卸载的所有情况。也就是说，页面卸载之前，<code>document.visibilityState</code>属性一定会变成<code>hidden</code>。事实上，这也是设计这个 API 的主要目的。</p><p>另外，早期版本的 API，这个属性还有第四个值<code>unloaded</code>，表示页面即将卸载，现在已经被废弃了。</p><p>注意，<code>document.visibilityState</code>属性只针对顶层窗口，内嵌的<code>&lt;iframe></code>页面的<code>document.visibilityState</code>属性由顶层窗口决定。使用 CSS 属性隐藏<code>&lt;iframe></code>页面（比如<code>display: none;</code>），并不会影响内嵌页面的可见性。</p><h3 id=documenthidden>document.hidden
<a class=header-anchor href=#documenthidden></a></h3><p>由于历史原因，这个 API 还定义了<code>document.hidden</code>属性。该属性只读，返回一个布尔值，表示当前页面是否可见。</p><p>当<code>document.visibilityState</code>属性返回<code>visible</code>时，<code>document.hidden</code>属性返回<code>false</code>；其他情况下，都返回<code>true</code>。</p><p>该属性只是出于历史原因而保留的，只要有可能，都应该使用<code>document.visibilityState</code>属性，而不是使用这个属性。</p><h3 id=visibilitychange-事件-1>visibilitychange 事件
<a class=header-anchor href=#visibilitychange-%e4%ba%8b%e4%bb%b6-1></a></h3><p>只要<code>document.visibilityState</code>属性发生变化，就会触发<code>visibilitychange</code>事件。因此，可以通过监听这个事件（通过<code>document.addEventListener()</code>方法或<code>document.onvisibilitychange</code>属性），跟踪页面可见性的变化。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span>document.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;visibilitychange&#39;</span>, <span style=color:#66d9ef>function</span> () {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 用户离开了当前页面
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (document.<span style=color:#a6e22e>visibilityState</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;hidden&#39;</span>) {
</span></span><span style=display:flex><span>        document.<span style=color:#a6e22e>title</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;页面不可见&#39;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 用户打开或回到页面
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (document.<span style=color:#a6e22e>visibilityState</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;visible&#39;</span>) {
</span></span><span style=display:flex><span>        document.<span style=color:#a6e22e>title</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;页面可见&#39;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>上面代码是 Page Visibility API 的最基本用法，可以监听可见性变化。</p><p>下面是另一个例子，一旦页面不可见，就暂停视频播放。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>vidElem</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;video-demo&#39;</span>);
</span></span><span style=display:flex><span>document.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;visibilitychange&#39;</span>, <span style=color:#a6e22e>startStopVideo</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>startStopVideo</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (document.<span style=color:#a6e22e>visibilityState</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;hidden&#39;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>vidElem</span>.<span style=color:#a6e22e>pause</span>();
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (document.<span style=color:#a6e22e>visibilityState</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;visible&#39;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>vidElem</span>.<span style=color:#a6e22e>play</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=页面卸载>页面卸载
<a class=header-anchor href=#%e9%a1%b5%e9%9d%a2%e5%8d%b8%e8%bd%bd></a></h3><p>下面专门讨论一下，如何正确监听页面卸载。</p><p>页面卸载可以分成三种情况。</p><blockquote><ul><li>页面可见时，用户关闭 Tab 页或浏览器窗口。</li><li>页面可见时，用户在当前窗口前往另一个页面。</li><li>页面不可见时，用户或系统关闭浏览器窗口。</li></ul></blockquote><p>这三种情况，都会触发<code>visibilitychange</code>事件。前两种情况，该事件在用户离开页面时触发；最后一种情况，该事件在页面从可见状态变为不可见状态时触发。</p><p>由此可见，<code>visibilitychange</code>事件比<code>pagehide</code>、<code>beforeunload</code>、<code>unload</code>事件更可靠，所有情况下都会触发（从<code>visible</code>变为<code>hidden</code>）。因此，可以只监听这个事件，运行页面卸载时需要运行的代码，不用监听后面那三个事件。</p><p>甚至可以这样说，<code>unload</code>事件在任何情况下都不必监听，<code>beforeunload</code>事件只有一种适用场景，就是用户修改了表单，没有提交就离开当前页面。另一方面，指定了这两个事件的监听函数，浏览器就不会缓存当前页面。</p><h3 id=参考链接-7>参考链接
<a class=header-anchor href=#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5-7></a></h3><ul><li><a href=https://w3c.github.io/page-visibility/ title="Page Visibility Level 2" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Page Visibility Level 2
<i class="fa fa-external-link-alt"></i>
</a>, W3C</li><li><a href=http://davidwalsh.name/page-visibility title="Page Visibility API" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Page Visibility API
<i class="fa fa-external-link-alt"></i>
</a>, David Walsh</li><li><a href=http://www.html5rocks.com/en/tutorials/pagevisibility/intro/ title="Using the pageVisbility API" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Using the pageVisbility API
<i class="fa fa-external-link-alt"></i>
</a>, Joe Marini</li><li><a href=http://blogs.msdn.com/b/ie/archive/2011/07/08/using-pc-hardware-more-efficiently-in-html5-new-web-performance-apis-part-2.aspx title="Using PC Hardware more efficiently in HTML5: New Web Performance APIs, Part 2" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Using PC Hardware more efficiently in HTML5: New Web Performance APIs, Part 2
<i class="fa fa-external-link-alt"></i>
</a>, Jatinder Mann</li><li><a href=https://www.igvita.com/2015/11/20/dont-lose-user-and-app-state-use-page-visibility/ title="Don&amp;rsquo;t lose user and app state, use Page Visibility" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Don&rsquo;t lose user and app state, use Page Visibility
<i class="fa fa-external-link-alt"></i>
</a>, Ilya Grigorik</li></ul><h2 id=point-lock-api>Point lock API
<a class=header-anchor href=#point-lock-api></a></h2><p>不用释放按钮，就锁定鼠标。</p><p><a href=https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API title=https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API
<i class="fa fa-external-link-alt"></i></a></p><h2 id=server-sent-events>Server-Sent Events
<a class=header-anchor href=#server-sent-events></a></h2><h3 id=简介-3>简介
<a class=header-anchor href=#%e7%ae%80%e4%bb%8b-3></a></h3><p>服务器向客户端推送数据，有很多解决方案。除了“轮询” 和 WebSocket，HTML 5 还提供了 Server-Sent Events（以下简称 SSE）。</p><p>一般来说，HTTP 协议只能客户端向服务器发起请求，服务器不能主动向客户端推送。但是有一种特殊情况，就是服务器向客户端声明，接下来要发送的是流信息（streaming）。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流。本质上，这种通信就是以流信息的方式，完成一次用时很长的下载。</p><p>SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 HTTP 协议，目前除了 IE/Edge，其他浏览器都支持。</p><h3 id=与-websocket-的比较>与 WebSocket 的比较
<a class=header-anchor href=#%e4%b8%8e-websocket-%e7%9a%84%e6%af%94%e8%be%83></a></h3><p>SSE 与 WebSocket 作用相似，都是建立浏览器与服务器之间的通信渠道，然后服务器向浏览器推送信息。</p><p>总体来说，WebSocket 更强大和灵活。因为它是全双工通道，可以双向通信；SSE 是单向通道，只能服务器向浏览器发送，因为 streaming 本质上就是下载。如果浏览器向服务器发送信息，就变成了另一次 HTTP 请求。</p><p>但是，SSE 也有自己的优点。</p><ul><li>SSE 使用 HTTP 协议，现有的服务器软件都支持。WebSocket 是一个独立协议。</li><li>SSE 属于轻量级，使用简单；WebSocket 协议相对复杂。</li><li>SSE 默认支持断线重连，WebSocket 需要自己实现断线重连。</li><li>SSE 一般只用来传送文本，二进制数据需要编码后传送，WebSocket 默认支持传送二进制数据。</li><li>SSE 支持自定义发送的消息类型。</li></ul><p>因此，两者各有特点，适合不同的场合。</p><h3 id=客户端-api>客户端 API
<a class=header-anchor href=#%e5%ae%a2%e6%88%b7%e7%ab%af-api></a></h3><h4 id=eventsource-对象>EventSource 对象
<a class=header-anchor href=#eventsource-%e5%af%b9%e8%b1%a1></a></h4><p>SSE 的客户端 API 部署在<code>EventSource</code>对象上。下面的代码可以检测浏览器是否支持 SSE。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#e6db74>&#39;EventSource&#39;</span> <span style=color:#66d9ef>in</span> window) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>使用 SSE 时，浏览器首先生成一个<code>EventSource</code>实例，向服务器发起连接。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>source</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>EventSource</span>(<span style=color:#a6e22e>url</span>);
</span></span></code></pre></div><p>上面的<code>url</code>可以与当前网址同域，也可以跨域。跨域时，可以指定第二个参数，打开<code>withCredentials</code>属性，表示是否一起发送 Cookie。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>source</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>EventSource</span>(<span style=color:#a6e22e>url</span>, { <span style=color:#a6e22e>withCredentials</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span> });
</span></span></code></pre></div><h4 id=readystate-属性>readyState 属性
<a class=header-anchor href=#readystate-%e5%b1%9e%e6%80%a7></a></h4><p><code>EventSource</code>实例的<code>readyState</code>属性，表明连接的当前状态。该属性只读，可以取以下值。</p><ul><li>0：相当于常量<code>EventSource.CONNECTING</code>，表示连接还未建立，或者断线正在重连。</li><li>1：相当于常量<code>EventSource.OPEN</code>，表示连接已经建立，可以接受数据。</li><li>2：相当于常量<code>EventSource.CLOSED</code>，表示连接已断，且不会重连。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>source</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>EventSource</span>(<span style=color:#a6e22e>url</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>source</span>.<span style=color:#a6e22e>readyState</span>);
</span></span></code></pre></div><h4 id=url-属性>url 属性
<a class=header-anchor href=#url-%e5%b1%9e%e6%80%a7></a></h4><p><code>EventSource</code>实例的<code>url</code>属性返回连接的网址，该属性只读。</p><h4 id=withcredentials-属性>withCredentials 属性
<a class=header-anchor href=#withcredentials-%e5%b1%9e%e6%80%a7></a></h4><p><code>EventSource</code>实例的<code>withCredentials</code>属性返回一个布尔值，表示当前实例是否开启 CORS 的<code>withCredentials</code>。该属性只读，默认是<code>false</code>。</p><h4 id=onopen-属性>onopen 属性
<a class=header-anchor href=#onopen-%e5%b1%9e%e6%80%a7></a></h4><p>连接一旦建立，就会触发<code>open</code>事件，可以在<code>onopen</code>属性定义回调函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>source</span>.<span style=color:#a6e22e>onopen</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>event</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 另一种写法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>source</span>.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;open&#39;</span>, <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>event</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}, <span style=color:#66d9ef>false</span>);
</span></span></code></pre></div><h4 id=onmessage-属性>onmessage 属性
<a class=header-anchor href=#onmessage-%e5%b1%9e%e6%80%a7></a></h4><p>客户端收到服务器发来的数据，就会触发<code>message</code>事件，可以在<code>onmessage</code>属性定义回调函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>source</span>.<span style=color:#a6e22e>onmessage</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>event</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>data</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>origin</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>origin</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>lastEventId</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>lastEventId</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// handle message
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 另一种写法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>source</span>.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;message&#39;</span>, <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>event</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>data</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>origin</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>origin</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>lastEventId</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>lastEventId</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// handle message
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}, <span style=color:#66d9ef>false</span>);
</span></span></code></pre></div><p>上面代码中，参数对象<code>event</code>有如下属性。</p><ul><li><code>data</code>：服务器端传回的数据（文本格式）。</li><li><code>origin</code>： 服务器 URL 的域名部分，即协议、域名和端口，表示消息的来源。</li><li><code>lastEventId</code>：数据的编号，由服务器端发送。如果没有编号，这个属性为空。</li></ul><h4 id=onerror-属性>onerror 属性
<a class=header-anchor href=#onerror-%e5%b1%9e%e6%80%a7></a></h4><p>如果发生通信错误（比如连接中断），就会触发<code>error</code>事件，可以在<code>onerror</code>属性定义回调函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>source</span>.<span style=color:#a6e22e>onerror</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>event</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// handle error event
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 另一种写法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>source</span>.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;error&#39;</span>, <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>event</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// handle error event
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}, <span style=color:#66d9ef>false</span>);
</span></span></code></pre></div><h4 id=自定义事件>自定义事件
<a class=header-anchor href=#%e8%87%aa%e5%ae%9a%e4%b9%89%e4%ba%8b%e4%bb%b6></a></h4><p>默认情况下，服务器发来的数据，总是触发浏览器<code>EventSource</code>实例的<code>message</code>事件。开发者还可以自定义 SSE 事件，这种情况下，发送回来的数据不会触发<code>message</code>事件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>source</span>.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;foo&#39;</span>, <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>event</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>data</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>origin</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>origin</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>lastEventId</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>lastEventId</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// handle message
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}, <span style=color:#66d9ef>false</span>);
</span></span></code></pre></div><p>上面代码中，浏览器对 SSE 的<code>foo</code>事件进行监听。如何实现服务器发送<code>foo</code>事件，请看下文。</p><h4 id=close-方法>close() 方法
<a class=header-anchor href=#close-%e6%96%b9%e6%b3%95></a></h4><p><code>close</code>方法用于关闭 SSE 连接。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>source</span>.<span style=color:#a6e22e>close</span>();
</span></span></code></pre></div><h3 id=服务器实现>服务器实现
<a class=header-anchor href=#%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%ae%9e%e7%8e%b0></a></h3><h4 id=数据格式>数据格式
<a class=header-anchor href=#%e6%95%b0%e6%8d%ae%e6%a0%bc%e5%bc%8f></a></h4><p>服务器向浏览器发送的 SSE 数据，必须是 UTF-8 编码的文本，具有如下的 HTTP 头信息。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>Content-Type: text/event-stream
</span></span><span style=display:flex><span>Cache-Control: no-cache
</span></span><span style=display:flex><span>Connection: keep-alive
</span></span></code></pre></div><p>上面三行之中，第一行的<code>Content-Type</code>必须指定 MIME 类型为<code>event-steam</code>。</p><p>每一次发送的信息，由若干个<code>message</code>组成，每个<code>message</code>之间用<code>\n\n</code>分隔。每个<code>message</code>内部由若干行组成，每一行都是如下格式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>[field]: value\n
</span></span></code></pre></div><p>上面的<code>field</code>可以取四个值。</p><ul><li>data</li><li>event</li><li>id</li><li>retry</li></ul><p>此外，还可以有冒号开头的行，表示注释。通常，服务器每隔一段时间就会向浏览器发送一个注释，保持连接不中断。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>: This is a comment
</span></span></code></pre></div><p>下面是一个例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>: this is a test stream\n\n
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>data: some text\n\n
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>data: another message\n
</span></span><span style=display:flex><span>data: with two lines \n\n
</span></span></code></pre></div><h4 id=data-字段>data 字段
<a class=header-anchor href=#data-%e5%ad%97%e6%ae%b5></a></h4><p>数据内容用<code>data</code>字段表示。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>data:  message\n\n
</span></span></code></pre></div><p>如果数据很长，可以分成多行，最后一行用<code>\n\n</code>结尾，前面行都用<code>\n</code>结尾。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>data: begin message\n
</span></span><span style=display:flex><span>data: continue message\n\n
</span></span></code></pre></div><p>下面是一个发送 JSON 数据的例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>data: {\n
</span></span><span style=display:flex><span>data: &#34;foo&#34;: &#34;bar&#34;,\n
</span></span><span style=display:flex><span>data: &#34;baz&#34;, 555\n
</span></span><span style=display:flex><span>data: }\n\n
</span></span></code></pre></div><h4 id=id-字段>id 字段
<a class=header-anchor href=#id-%e5%ad%97%e6%ae%b5></a></h4><p>数据标识符用<code>id</code>字段表示，相当于每一条数据的编号。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>id: msg1\n
</span></span><span style=display:flex><span>data: message\n\n
</span></span></code></pre></div><p>浏览器用<code>lastEventId</code>属性读取这个值。一旦连接断线，浏览器会发送一个 HTTP 头，里面包含一个特殊的<code>Last-Event-ID</code>头信息，将这个值发送回来，用来帮助服务器端重建连接。因此，这个头信息可以被视为一种同步机制。</p><h4 id=event-字段>event 字段
<a class=header-anchor href=#event-%e5%ad%97%e6%ae%b5></a></h4><p><code>event</code>字段表示自定义的事件类型，默认是<code>message</code>事件。浏览器可以用<code>addEventListener()</code>监听该事件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>event: foo\n
</span></span><span style=display:flex><span>data: a foo event\n\n
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>data: an unnamed event\n\n
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>event: bar\n
</span></span><span style=display:flex><span>data: a bar event\n\n
</span></span></code></pre></div><p>上面的代码创造了三条信息。第一条的名字是<code>foo</code>，触发浏览器的<code>foo</code>事件；第二条未取名，表示默认类型，触发浏览器的<code>message</code>事件；第三条是<code>bar</code>，触发浏览器的<code>bar</code>事件。</p><p>下面是另一个例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>event: userconnect
</span></span><span style=display:flex><span>data: {&#34;username&#34;: &#34;bobby&#34;, &#34;time&#34;: &#34;02:33:48&#34;}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>event: usermessage
</span></span><span style=display:flex><span>data: {&#34;username&#34;: &#34;bobby&#34;, &#34;time&#34;: &#34;02:34:11&#34;, &#34;text&#34;: &#34;Hi everyone.&#34;}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>event: userdisconnect
</span></span><span style=display:flex><span>data: {&#34;username&#34;: &#34;bobby&#34;, &#34;time&#34;: &#34;02:34:23&#34;}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>event: usermessage
</span></span><span style=display:flex><span>data: {&#34;username&#34;: &#34;sean&#34;, &#34;time&#34;: &#34;02:34:36&#34;, &#34;text&#34;: &#34;Bye, bobby.&#34;}
</span></span></code></pre></div><h4 id=retry-字段>retry 字段
<a class=header-anchor href=#retry-%e5%ad%97%e6%ae%b5></a></h4><p>服务器可以用<code>retry</code>字段，指定浏览器重新发起连接的时间间隔。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>retry: 10000\n
</span></span></code></pre></div><p>两种情况会导致浏览器重新发起连接：一种是时间间隔到期，二是由于网络错误等原因，导致连接出错。</p><h3 id=node-服务器实例>Node 服务器实例
<a class=header-anchor href=#node-%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%ae%9e%e4%be%8b></a></h3><p>SSE 要求服务器与浏览器保持连接。对于不同的服务器软件来说，所消耗的资源是不一样的。Apache 服务器，每个连接就是一个线程，如果要维持大量连接，势必要消耗大量资源。Node 则是所有连接都使用同一个线程，因此消耗的资源会小得多，但是这要求每个连接不能包含很耗时的操作，比如磁盘的 IO 读写。</p><p>下面是 Node 的 SSE 服务器
<a href=http://cjihrig.com/blog/server-sent-events-in-node-js/ title=实例 rel="noopener external nofollow noreferrer" target=_blank class=exturl>实例
<i class="fa fa-external-link-alt"></i>
</a>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>http</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#34;http&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>createServer</span>(<span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>res</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>fileName</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;.&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>url</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>fileName</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;./stream&#34;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>writeHead</span>(<span style=color:#ae81ff>200</span>, {
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;Content-Type&#34;</span><span style=color:#f92672>:</span><span style=color:#e6db74>&#34;text/event-stream&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;Cache-Control&#34;</span><span style=color:#f92672>:</span><span style=color:#e6db74>&#34;no-cache&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;Connection&#34;</span><span style=color:#f92672>:</span><span style=color:#e6db74>&#34;keep-alive&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;Access-Control-Allow-Origin&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;*&#39;</span>,
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>write</span>(<span style=color:#e6db74>&#34;retry: 10000\n&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>write</span>(<span style=color:#e6db74>&#34;event: connecttime\n&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>write</span>(<span style=color:#e6db74>&#34;data: &#34;</span> <span style=color:#f92672>+</span> (<span style=color:#66d9ef>new</span> Date()) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;\n\n&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>write</span>(<span style=color:#e6db74>&#34;data: &#34;</span> <span style=color:#f92672>+</span> (<span style=color:#66d9ef>new</span> Date()) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;\n\n&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>interval</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>setInterval</span>(<span style=color:#66d9ef>function</span> () {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>write</span>(<span style=color:#e6db74>&#34;data: &#34;</span> <span style=color:#f92672>+</span> (<span style=color:#66d9ef>new</span> Date()) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;\n\n&#34;</span>);
</span></span><span style=display:flex><span>        }, <span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>connection</span>.<span style=color:#a6e22e>addListener</span>(<span style=color:#e6db74>&#34;close&#34;</span>, <span style=color:#66d9ef>function</span> () {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>clearInterval</span>(<span style=color:#a6e22e>interval</span>);
</span></span><span style=display:flex><span>        }, <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}).<span style=color:#a6e22e>listen</span>(<span style=color:#ae81ff>8844</span>, <span style=color:#e6db74>&#34;127.0.0.1&#34;</span>);
</span></span></code></pre></div><h3 id=参考链接-8>参考链接
<a class=header-anchor href=#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5-8></a></h3><ul><li>Colin Ihrig,
<a href=http://jspro.com/apis/implementing-push-technology-using-server-sent-events/ title="Implementing Push Technology Using Server-Sent Events" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Implementing Push Technology Using Server-Sent Events
<i class="fa fa-external-link-alt"></i></a></li><li>Colin Ihrig，
<a href=http://cjihrig.com/blog/the-server-side-of-server-sent-events/ title="The Server Side of Server-Sent Events" rel="noopener external nofollow noreferrer" target=_blank class=exturl>The Server Side of Server-Sent Events
<i class="fa fa-external-link-alt"></i></a></li><li>Eric Bidelman,
<a href=http://www.html5rocks.com/en/tutorials/eventsource/basics/ title="Stream Updates with Server-Sent Events" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Stream Updates with Server-Sent Events
<i class="fa fa-external-link-alt"></i></a></li><li>MDN，
<a href=https://developer.mozilla.org/en-US/docs/Server-sent_events/Using_server-sent_events title="Using server-sent events" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Using server-sent events
<i class="fa fa-external-link-alt"></i></a></li><li>Segment.io,
<a href=https://segment.io/blog/2014-04-03-server-sent-events-the-simplest-realtime-browser-spec/ title="Server-Sent Events: The simplest realtime browser spec" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Server-Sent Events: The simplest realtime browser spec
<i class="fa fa-external-link-alt"></i></a></li></ul><h2 id=service-worker>Service Worker
<a class=header-anchor href=#service-worker></a></h2><h3 id=含义>含义
<a class=header-anchor href=#%e5%90%ab%e4%b9%89></a></h3><p>Service Worker 首先是一个运行在后台的 Worker 线程，然后它会长期运行，充当一个服务，很适合那些不需要网页或用户互动的功能。它的最常见用途就是拦截和处理网络请求。</p><p>Service Worker 是一个后台运行的脚本，充当一个代理服务器，拦截用户发出的网络请求，比如加载脚本和图片。Service Worker 可以修改用户的请求，或者直接向用户发出回应，不用联系服务器，这使得用户可以在离线情况下使用网络应用。它还可以在本地缓存资源文件，直接从缓存加载文件，因此可以加快访问速度。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#e6db74>&#39;serviceWorker&#39;</span> <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>navigator</span>) {
</span></span><span style=display:flex><span>    window.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;load&#39;</span>, <span style=color:#66d9ef>function</span>() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>serviceWorker</span>.<span style=color:#a6e22e>register</span>(<span style=color:#e6db74>&#39;/service-worker.js&#39;</span>);
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码确认浏览器支持 Service Worker 以后，会注册一个 Service Worker。</p><p>为了节省内存，Service worker 在不使用的时候是休眠的。它也不会保存数据，所以重新启动的时候，为了拿到数据，最好把数据放在 IndexedDb 里面。</p><p>Service Worker 是事件驱动的。</p><p>下面是拦截请求的例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>self</span>.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;fetch&#39;</span>, (<span style=color:#a6e22e>event</span>) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>waitUntil</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>url</span>.<span style=color:#a6e22e>includes</span>(<span style=color:#e6db74>&#39;/product&#39;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>productId</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>productId</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>productCount</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>getProductData</span>(<span style=color:#a6e22e>productId</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>indexedDB</span>.<span style=color:#a6e22e>open</span>(<span style=color:#e6db74>&#39;store&#39;</span>, <span style=color:#ae81ff>1</span>, (<span style=color:#a6e22e>db</span>) =&gt; {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>productStore</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>createObjectStore</span>(<span style=color:#e6db74>&#39;products&#39;</span>, { <span style=color:#a6e22e>keyPath</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;id&#39;</span> })
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>productStore</span>.<span style=color:#a6e22e>put</span>({ <span style=color:#a6e22e>id</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>productId</span>, <span style=color:#a6e22e>count</span><span style=color:#f92672>:</span> <span style=color:#f92672>++</span><span style=color:#a6e22e>productCount</span> })
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>Service Worker 不能直接操作 DOM。</p><h3 id=使用步骤>使用步骤
<a class=header-anchor href=#%e4%bd%bf%e7%94%a8%e6%ad%a5%e9%aa%a4></a></h3><h4 id=登记>登记
<a class=header-anchor href=#%e7%99%bb%e8%ae%b0></a></h4><p>使用 service worker 的第一步，就是告诉浏览器，需要注册一个 service worker 脚本。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>serviceWorker</span>.<span style=color:#a6e22e>register</span>(<span style=color:#e6db74>&#39;sw.js&#39;</span>.<span style=color:#a6e22e>then</span>(() =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#39;注册成功&#39;</span>)
</span></span><span style=display:flex><span>}).<span style=color:#66d9ef>catch</span>((<span style=color:#a6e22e>err</span>) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#39;注册失败&#39;</span>)
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>上面代码的<code>sw.js</code>就是需要浏览器注册的 service worker 脚本。注意，这个脚本必须与当前网址同域，service worker 不支持跨域脚本。另外，<code>sw.js</code>必须是从 HTTPS 协议加载的。</p><p>默认情况下，Service worker 只对根目录<code>/</code>生效，如果要改变生效范围，可以运行下面的代码。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>serviceWorker</span>.<span style=color:#a6e22e>register</span>(
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;/service-worker.js&#39;</span>,
</span></span><span style=display:flex><span>    { <span style=color:#a6e22e>scope</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;/products/fashion&#39;</span> }
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><h4 id=安装>安装
<a class=header-anchor href=#%e5%ae%89%e8%a3%85></a></h4><p>一旦登记成功，接下来都是 service worker 脚本的工作。下面的代码都是写在 service worker 脚本里面的。</p><p>登记后，就会触发<code>install</code>事件。service worker 脚本需要监听这个事件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>self</span>.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;install&#39;</span>, <span style=color:#a6e22e>event</span> =&gt; {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>waitUntil</span>(() =&gt; <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#39;安装完成&#39;</span>))
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p><code>event.waitUntil()</code>方法为事件完成后指定回调函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>self</span>.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;install&#39;</span>, (<span style=color:#a6e22e>event</span>) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>CACHE_NAME</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;xyz-cache&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>urlsToCache</span> <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;/&#39;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;/styles/main.css&#39;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;/scripts/bundle.js&#39;</span>
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>waitUntil</span>(
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>caches</span>.<span style=color:#a6e22e>open</span>(<span style=color:#a6e22e>CACHE_NAME</span>)
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>then</span> (<span style=color:#a6e22e>cache</span> =&gt; <span style=color:#a6e22e>cache</span>.<span style=color:#a6e22e>addAll</span>(<span style=color:#a6e22e>urlsToCache</span>))
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><h4 id=激活>激活
<a class=header-anchor href=#%e6%bf%80%e6%b4%bb></a></h4><p>安装完成后，service worker 就会等待激活。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>self</span>.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;activate&#39;</span>, (<span style=color:#a6e22e>event</span>) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>cacheWhitelist</span> <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;products-v2&#39;</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>waitUntil</span>(
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>caches</span>.<span style=color:#a6e22e>keys</span>().<span style=color:#a6e22e>then</span> (<span style=color:#a6e22e>cacheNames</span> =&gt; {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Promise.<span style=color:#a6e22e>all</span>(
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>cacheNames</span>.<span style=color:#a6e22e>map</span>( <span style=color:#a6e22e>cacheName</span> =&gt; {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>cacheWhitelist</span>.<span style=color:#a6e22e>indexOf</span>(<span style=color:#a6e22e>cacheName</span>) <span style=color:#f92672>===</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>caches</span>.<span style=color:#66d9ef>delete</span>(<span style=color:#a6e22e>cacheName</span>)
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                })
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><h3 id=service-worker-与网页的通信>Service Worker 与网页的通信
<a class=header-anchor href=#service-worker-%e4%b8%8e%e7%bd%91%e9%a1%b5%e7%9a%84%e9%80%9a%e4%bf%a1></a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>self</span>.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;activate&#39;</span>, (<span style=color:#a6e22e>event</span>) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>waitUntil</span>(
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>self</span>.<span style=color:#a6e22e>clients</span>.<span style=color:#a6e22e>matchAll</span>().<span style=color:#a6e22e>then</span> ( (<span style=color:#a6e22e>client</span>) =&gt; {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>postMessage</span>({
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>msg</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Hey, from service worker! I\&#39;m listening to your fetch requests.&#39;</span>,
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>source</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;service-worker&#39;</span>
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>上面代码中，Service Worker 监听<code>activate</code>事件，然后向客户端发送一条信息。</p><p>客户端需要部署消息监听代码。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;message&#39;</span>, (<span style=color:#a6e22e>data</span>) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>source</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;service-worker&#39;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>msg</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><h3 id=参考链接-9>参考链接
<a class=header-anchor href=#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5-9></a></h3><ul><li><a href=https://frontendian.co/service-workers title="Service Workers" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Service Workers
<i class="fa fa-external-link-alt"></i>
</a>, by Ryan Miller</li></ul><h2 id=svg-图像>SVG 图像
<a class=header-anchor href=#svg-%e5%9b%be%e5%83%8f></a></h2><h3 id=概述-1>概述
<a class=header-anchor href=#%e6%a6%82%e8%bf%b0-1></a></h3><p>SVG 是一种基于 XML 语法的图像格式，全称是可缩放矢量图（Scalable Vector Graphics）。其他图像格式都是基于像素处理的，SVG 则是属于对图像的形状描述，所以它本质上是文本文件，体积较小，且不管放大多少倍都不会失真。</p><p>SVG 文件可以直接插入网页，成为 DOM 的一部分，然后用 JavaScript 和 CSS 进行操作。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span><span style=color:#75715e>&lt;!DOCTYPE html&gt;</span>
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>html</span>&gt;
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>head</span>&gt;&lt;/<span style=color:#f92672>head</span>&gt;
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>body</span>&gt;
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>svg</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>id</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;mysvg&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>xmlns</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;http://www.w3.org/2000/svg&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>viewBox</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;0 0 800 600&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>preserveAspectRatio</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;xMidYMid meet&#34;</span>
</span></span><span style=display:flex><span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>circle</span> <span style=color:#a6e22e>id</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;mycircle&#34;</span> <span style=color:#a6e22e>cx</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;400&#34;</span> <span style=color:#a6e22e>cy</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;300&#34;</span> <span style=color:#a6e22e>r</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;50&#34;</span> /&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>svg</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>body</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>html</span>&gt;
</span></span></code></pre></div><p>上面是 SVG 代码直接插入网页的例子。</p><p>SVG 代码也可以写在一个独立文件中，然后用<code>&lt;img></code>、<code>&lt;object></code>、<code>&lt;embed></code>、<code>&lt;iframe></code>等标签插入网页。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>img</span> <span style=color:#a6e22e>src</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;circle.svg&#34;</span>&gt;
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>object</span> <span style=color:#a6e22e>id</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;object&#34;</span> <span style=color:#a6e22e>data</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;circle.svg&#34;</span> <span style=color:#a6e22e>type</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;image/svg+xml&#34;</span>&gt;&lt;/<span style=color:#f92672>object</span>&gt;
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>embed</span> <span style=color:#a6e22e>id</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;embed&#34;</span> <span style=color:#a6e22e>src</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;icon.svg&#34;</span> <span style=color:#a6e22e>type</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;image/svg+xml&#34;</span>&gt;
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>iframe</span> <span style=color:#a6e22e>id</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;iframe&#34;</span> <span style=color:#a6e22e>src</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;icon.svg&#34;</span>&gt;&lt;/<span style=color:#f92672>iframe</span>&gt;
</span></span></code></pre></div><p>CSS 也可以使用 SVG 文件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>logo</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>background</span>: url(<span style=color:#e6db74>icon.svg</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>SVG 文件还可以转为 BASE64 编码，然后作为 Data URI 写入网页。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>img</span> <span style=color:#a6e22e>src</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;data:image/svg+xml;base64,[data]&#34;</span>&gt;
</span></span></code></pre></div><h3 id=语法>语法
<a class=header-anchor href=#%e8%af%ad%e6%b3%95></a></h3><h4 id=svg标签><code>&lt;svg></code>标签
<a class=header-anchor href=#svg%e6%a0%87%e7%ad%be></a></h4><p>SVG 代码都放在顶层标签<code>&lt;svg></code>之中。下面是一个例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;svg</span> <span style=color:#a6e22e>width=</span><span style=color:#e6db74>&#34;100%&#34;</span> <span style=color:#a6e22e>height=</span><span style=color:#e6db74>&#34;100%&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;circle</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;mycircle&#34;</span> <span style=color:#a6e22e>cx=</span><span style=color:#e6db74>&#34;50&#34;</span> <span style=color:#a6e22e>cy=</span><span style=color:#e6db74>&#34;50&#34;</span> <span style=color:#a6e22e>r=</span><span style=color:#e6db74>&#34;50&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/svg&gt;</span>
</span></span></code></pre></div><p><code>&lt;svg></code>的<code>width</code>属性和<code>height</code>属性，指定了 SVG 图像在 HTML 元素中所占据的宽度和高度。除了相对单位，也可以采用绝对单位（单位：像素）。如果不指定这两个属性，SVG 图像的大小默认为300像素（宽）x 150像素（高）。</p><p>如果只想展示 SVG 图像的一部分，就要指定<code>viewBox</code>属性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;svg</span> <span style=color:#a6e22e>width=</span><span style=color:#e6db74>&#34;100&#34;</span> <span style=color:#a6e22e>height=</span><span style=color:#e6db74>&#34;100&#34;</span> <span style=color:#a6e22e>viewBox=</span><span style=color:#e6db74>&#34;50 50 50 50&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;circle</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;mycircle&#34;</span> <span style=color:#a6e22e>cx=</span><span style=color:#e6db74>&#34;50&#34;</span> <span style=color:#a6e22e>cy=</span><span style=color:#e6db74>&#34;50&#34;</span> <span style=color:#a6e22e>r=</span><span style=color:#e6db74>&#34;50&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/svg&gt;</span>
</span></span></code></pre></div><p><code>&lt;viewBox></code>属性的值有四个数字，分别是左上角的横坐标和纵坐标、视口的宽度和高度。上面代码中，SVG 图像是100像素宽 x 100像素高，<code>viewBox</code>属性指定视口从<code>(50, 50)</code>这个点开始。所以，实际看到的是右下角的四分之一圆。</p><p>注意，视口必须适配所在的空间。上面代码中，视口的大小是 50 x 50，由于 SVG 图像的大小是 100 x 100，所以视口会放大去适配 SVG 图像的大小，即放大了四倍。</p><p>如果不指定<code>width</code>属性和<code>height</code>属性，只指定<code>viewBox</code>属性，则相当于只给定 SVG 图像的长宽比。这时，SVG 图像的大小默认是所在的 HTML 元素的大小。</p><h4 id=circle标签><code>&lt;circle></code>标签
<a class=header-anchor href=#circle%e6%a0%87%e7%ad%be></a></h4><p><code>&lt;circle></code>标签代表圆形。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;svg</span> <span style=color:#a6e22e>width=</span><span style=color:#e6db74>&#34;300&#34;</span> <span style=color:#a6e22e>height=</span><span style=color:#e6db74>&#34;180&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;circle</span> <span style=color:#a6e22e>cx=</span><span style=color:#e6db74>&#34;30&#34;</span>  <span style=color:#a6e22e>cy=</span><span style=color:#e6db74>&#34;50&#34;</span> <span style=color:#a6e22e>r=</span><span style=color:#e6db74>&#34;25&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;circle</span> <span style=color:#a6e22e>cx=</span><span style=color:#e6db74>&#34;90&#34;</span>  <span style=color:#a6e22e>cy=</span><span style=color:#e6db74>&#34;50&#34;</span> <span style=color:#a6e22e>r=</span><span style=color:#e6db74>&#34;25&#34;</span> <span style=color:#a6e22e>class=</span><span style=color:#e6db74>&#34;red&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;circle</span> <span style=color:#a6e22e>cx=</span><span style=color:#e6db74>&#34;150&#34;</span> <span style=color:#a6e22e>cy=</span><span style=color:#e6db74>&#34;50&#34;</span> <span style=color:#a6e22e>r=</span><span style=color:#e6db74>&#34;25&#34;</span> <span style=color:#a6e22e>class=</span><span style=color:#e6db74>&#34;fancy&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/svg&gt;</span>
</span></span></code></pre></div><p>上面的代码定义了三个圆。<code>&lt;circle></code>标签的<code>cx</code>、<code>cy</code>、<code>r</code>属性分别为横坐标、纵坐标和半径，单位为像素。坐标都是相对于<code>&lt;svg></code>画布的左上角原点。</p><p><code>class</code>属性用来指定对应的 CSS 类。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>red</span> {
</span></span><span style=display:flex><span>    fill: <span style=color:#66d9ef>red</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>fancy</span> {
</span></span><span style=display:flex><span>    fill: <span style=color:#66d9ef>none</span>;
</span></span><span style=display:flex><span>    stroke: <span style=color:#66d9ef>black</span>;
</span></span><span style=display:flex><span>    stroke-width: <span style=color:#ae81ff>3</span><span style=color:#66d9ef>pt</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>SVG 的 CSS 属性与网页元素有所不同。</p><blockquote><ul><li>fill：填充色</li><li>stroke：描边色</li><li>stroke-width：边框宽度</li></ul></blockquote><h4 id=line标签><code>&lt;line></code>标签
<a class=header-anchor href=#line%e6%a0%87%e7%ad%be></a></h4><p><code>&lt;line></code>标签用来绘制直线。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;svg</span> <span style=color:#a6e22e>width=</span><span style=color:#e6db74>&#34;300&#34;</span> <span style=color:#a6e22e>height=</span><span style=color:#e6db74>&#34;180&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;line</span> <span style=color:#a6e22e>x1=</span><span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#a6e22e>y1=</span><span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#a6e22e>x2=</span><span style=color:#e6db74>&#34;200&#34;</span> <span style=color:#a6e22e>y2=</span><span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#a6e22e>style=</span><span style=color:#e6db74>&#34;stroke:rgb(0,0,0);stroke-width:5&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/svg&gt;</span>
</span></span></code></pre></div><p>上面代码中，<code>&lt;line></code>标签的<code>x1</code>属性和<code>y1</code>属性，表示线段起点的横坐标和纵坐标；<code>x2</code>属性和<code>y2</code>属性，表示线段终点的横坐标和纵坐标；<code>style</code>属性表示线段的样式。</p><h4 id=polyline标签><code>&lt;polyline></code>标签
<a class=header-anchor href=#polyline%e6%a0%87%e7%ad%be></a></h4><p><code>&lt;polyline></code>标签用于绘制一根折线。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;svg</span> <span style=color:#a6e22e>width=</span><span style=color:#e6db74>&#34;300&#34;</span> <span style=color:#a6e22e>height=</span><span style=color:#e6db74>&#34;180&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;polyline</span> <span style=color:#a6e22e>points=</span><span style=color:#e6db74>&#34;3,3 30,28 3,53&#34;</span> <span style=color:#a6e22e>fill=</span><span style=color:#e6db74>&#34;none&#34;</span> <span style=color:#a6e22e>stroke=</span><span style=color:#e6db74>&#34;black&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/svg&gt;</span>
</span></span></code></pre></div><p><code>&lt;polyline></code>的<code>points</code>属性指定了每个端点的坐标，横坐标与纵坐标之间与逗号分隔，点与点之间用空格分隔。</p><h4 id=rect标签><code>&lt;rect></code>标签
<a class=header-anchor href=#rect%e6%a0%87%e7%ad%be></a></h4><p><code>&lt;rect></code>标签用于绘制矩形。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;svg</span> <span style=color:#a6e22e>width=</span><span style=color:#e6db74>&#34;300&#34;</span> <span style=color:#a6e22e>height=</span><span style=color:#e6db74>&#34;180&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;rect</span> <span style=color:#a6e22e>x=</span><span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#a6e22e>y=</span><span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#a6e22e>height=</span><span style=color:#e6db74>&#34;100&#34;</span> <span style=color:#a6e22e>width=</span><span style=color:#e6db74>&#34;200&#34;</span> <span style=color:#a6e22e>style=</span><span style=color:#e6db74>&#34;stroke: ##70d5dd; fill: ##dd524b&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/svg&gt;</span>
</span></span></code></pre></div><p><code>&lt;rect></code>的<code>x</code>属性和<code>y</code>属性，指定了矩形左上角端点的横坐标和纵坐标；<code>width</code>属性和<code>height</code>属性指定了矩形的宽度和高度（单位像素）。</p><h4 id=ellipse标签><code>&lt;ellipse></code>标签
<a class=header-anchor href=#ellipse%e6%a0%87%e7%ad%be></a></h4><p><code>&lt;ellipse></code>标签用于绘制椭圆。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;svg</span> <span style=color:#a6e22e>width=</span><span style=color:#e6db74>&#34;300&#34;</span> <span style=color:#a6e22e>height=</span><span style=color:#e6db74>&#34;180&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;ellipse</span> <span style=color:#a6e22e>cx=</span><span style=color:#e6db74>&#34;60&#34;</span> <span style=color:#a6e22e>cy=</span><span style=color:#e6db74>&#34;60&#34;</span> <span style=color:#a6e22e>ry=</span><span style=color:#e6db74>&#34;40&#34;</span> <span style=color:#a6e22e>rx=</span><span style=color:#e6db74>&#34;20&#34;</span> <span style=color:#a6e22e>stroke=</span><span style=color:#e6db74>&#34;black&#34;</span> <span style=color:#a6e22e>stroke-width=</span><span style=color:#e6db74>&#34;5&#34;</span> <span style=color:#a6e22e>fill=</span><span style=color:#e6db74>&#34;silver&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/svg&gt;</span>
</span></span></code></pre></div><p><code>&lt;ellipse></code>的<code>cx</code>属性和<code>cy</code>属性，指定了椭圆中心的横坐标和纵坐标（单位像素）；<code>rx</code>属性和<code>ry</code>属性，指定了椭圆横向轴和纵向轴的半径（单位像素）。</p><h4 id=polygon标签><code>&lt;polygon></code>标签
<a class=header-anchor href=#polygon%e6%a0%87%e7%ad%be></a></h4><p><code>&lt;polygon></code>标签用于绘制多边形。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;svg</span> <span style=color:#a6e22e>width=</span><span style=color:#e6db74>&#34;300&#34;</span> <span style=color:#a6e22e>height=</span><span style=color:#e6db74>&#34;180&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;polygon</span> <span style=color:#a6e22e>fill=</span><span style=color:#e6db74>&#34;green&#34;</span> <span style=color:#a6e22e>stroke=</span><span style=color:#e6db74>&#34;orange&#34;</span> <span style=color:#a6e22e>stroke-width=</span><span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#a6e22e>points=</span><span style=color:#e6db74>&#34;0,0 100,0 100,100 0,100 0,0&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/svg&gt;</span>
</span></span></code></pre></div><p><code>&lt;polygon></code>的<code>points</code>属性指定了每个端点的坐标，横坐标与纵坐标之间与逗号分隔，点与点之间用空格分隔。</p><h4 id=path标签><code>&lt;path></code>标签
<a class=header-anchor href=#path%e6%a0%87%e7%ad%be></a></h4><p><code>&lt;path></code>标签用于制路径。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;svg</span> <span style=color:#a6e22e>width=</span><span style=color:#e6db74>&#34;300&#34;</span> <span style=color:#a6e22e>height=</span><span style=color:#e6db74>&#34;180&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;path</span> <span style=color:#a6e22e>d=</span><span style=color:#e6db74>&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  M 18,3
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  L 46,3
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  L 46,40
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  L 61,40
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  L 32,68
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  L 3,40
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  L 18,40
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  Z
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>&gt;&lt;/path&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/svg&gt;</span>
</span></span></code></pre></div><p><code>&lt;path></code>的<code>d</code>属性表示绘制顺序，它的值是一个长字符串，每个字母表示一个绘制动作，后面跟着坐标。</p><blockquote><ul><li>M：移动到（moveto）</li><li>L：画直线到（lineto）</li><li>Z：闭合路径</li></ul></blockquote><h4 id=text标签><code>&lt;text></code>标签
<a class=header-anchor href=#text%e6%a0%87%e7%ad%be></a></h4><p><code>&lt;text></code>标签用于绘制文本。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;svg</span> <span style=color:#a6e22e>width=</span><span style=color:#e6db74>&#34;300&#34;</span> <span style=color:#a6e22e>height=</span><span style=color:#e6db74>&#34;180&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;text</span> <span style=color:#a6e22e>x=</span><span style=color:#e6db74>&#34;50&#34;</span> <span style=color:#a6e22e>y=</span><span style=color:#e6db74>&#34;25&#34;</span><span style=color:#f92672>&gt;</span>Hello World<span style=color:#f92672>&lt;/text&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/svg&gt;</span>
</span></span></code></pre></div><p><code>&lt;text></code>的<code>x</code>属性和<code>y</code>属性，表示文本区块基线（baseline）起点的横坐标和纵坐标。文字的样式可以用<code>class</code>或<code>style</code>属性指定。</p><h4 id=use标签><code>&lt;use></code>标签
<a class=header-anchor href=#use%e6%a0%87%e7%ad%be></a></h4><p><code>&lt;use></code>标签用于复制一个形状。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;svg</span> <span style=color:#a6e22e>viewBox=</span><span style=color:#e6db74>&#34;0 0 30 10&#34;</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#34;http://www.w3.org/2000/svg&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;circle</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;myCircle&#34;</span> <span style=color:#a6e22e>cx=</span><span style=color:#e6db74>&#34;5&#34;</span> <span style=color:#a6e22e>cy=</span><span style=color:#e6db74>&#34;5&#34;</span> <span style=color:#a6e22e>r=</span><span style=color:#e6db74>&#34;4&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;use</span> <span style=color:#a6e22e>href=</span><span style=color:#e6db74>&#34;##myCircle&#34;</span> <span style=color:#a6e22e>x=</span><span style=color:#e6db74>&#34;10&#34;</span> <span style=color:#a6e22e>y=</span><span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#a6e22e>fill=</span><span style=color:#e6db74>&#34;blue&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;use</span> <span style=color:#a6e22e>href=</span><span style=color:#e6db74>&#34;##myCircle&#34;</span> <span style=color:#a6e22e>x=</span><span style=color:#e6db74>&#34;20&#34;</span> <span style=color:#a6e22e>y=</span><span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#a6e22e>fill=</span><span style=color:#e6db74>&#34;white&#34;</span> <span style=color:#a6e22e>stroke=</span><span style=color:#e6db74>&#34;blue&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/svg&gt;</span>
</span></span></code></pre></div><p><code>&lt;use></code>的<code>href</code>属性指定所要复制的节点，<code>x</code>属性和<code>y</code>属性是<code>&lt;use></code>左上角的坐标。另外，还可以指定<code>width</code>和<code>height</code>坐标。</p><h4 id=g标签><code>&lt;g></code>标签
<a class=header-anchor href=#g%e6%a0%87%e7%ad%be></a></h4><p><code>&lt;g></code>标签用于将多个形状组成一个组（group），方便复用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;svg</span> <span style=color:#a6e22e>width=</span><span style=color:#e6db74>&#34;300&#34;</span> <span style=color:#a6e22e>height=</span><span style=color:#e6db74>&#34;100&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;g</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;myCircle&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;text</span> <span style=color:#a6e22e>x=</span><span style=color:#e6db74>&#34;25&#34;</span> <span style=color:#a6e22e>y=</span><span style=color:#e6db74>&#34;20&#34;</span><span style=color:#f92672>&gt;</span>圆形<span style=color:#f92672>&lt;/text&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;circle</span> <span style=color:#a6e22e>cx=</span><span style=color:#e6db74>&#34;50&#34;</span> <span style=color:#a6e22e>cy=</span><span style=color:#e6db74>&#34;50&#34;</span> <span style=color:#a6e22e>r=</span><span style=color:#e6db74>&#34;20&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/g&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;use</span> <span style=color:#a6e22e>href=</span><span style=color:#e6db74>&#34;##myCircle&#34;</span> <span style=color:#a6e22e>x=</span><span style=color:#e6db74>&#34;100&#34;</span> <span style=color:#a6e22e>y=</span><span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#a6e22e>fill=</span><span style=color:#e6db74>&#34;blue&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;use</span> <span style=color:#a6e22e>href=</span><span style=color:#e6db74>&#34;##myCircle&#34;</span> <span style=color:#a6e22e>x=</span><span style=color:#e6db74>&#34;200&#34;</span> <span style=color:#a6e22e>y=</span><span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#a6e22e>fill=</span><span style=color:#e6db74>&#34;white&#34;</span> <span style=color:#a6e22e>stroke=</span><span style=color:#e6db74>&#34;blue&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/svg&gt;</span>
</span></span></code></pre></div><h4 id=defs标签><code>&lt;defs></code>标签
<a class=header-anchor href=#defs%e6%a0%87%e7%ad%be></a></h4><p><code>&lt;defs></code>标签用于自定义形状，它内部的代码不会显示，仅供引用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;svg</span> <span style=color:#a6e22e>width=</span><span style=color:#e6db74>&#34;300&#34;</span> <span style=color:#a6e22e>height=</span><span style=color:#e6db74>&#34;100&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;defs&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;g</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;myCircle&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;text</span> <span style=color:#a6e22e>x=</span><span style=color:#e6db74>&#34;25&#34;</span> <span style=color:#a6e22e>y=</span><span style=color:#e6db74>&#34;20&#34;</span><span style=color:#f92672>&gt;</span>圆形<span style=color:#f92672>&lt;/text&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;circle</span> <span style=color:#a6e22e>cx=</span><span style=color:#e6db74>&#34;50&#34;</span> <span style=color:#a6e22e>cy=</span><span style=color:#e6db74>&#34;50&#34;</span> <span style=color:#a6e22e>r=</span><span style=color:#e6db74>&#34;20&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;/g&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/defs&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;use</span> <span style=color:#a6e22e>href=</span><span style=color:#e6db74>&#34;##myCircle&#34;</span> <span style=color:#a6e22e>x=</span><span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#a6e22e>y=</span><span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;use</span> <span style=color:#a6e22e>href=</span><span style=color:#e6db74>&#34;##myCircle&#34;</span> <span style=color:#a6e22e>x=</span><span style=color:#e6db74>&#34;100&#34;</span> <span style=color:#a6e22e>y=</span><span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#a6e22e>fill=</span><span style=color:#e6db74>&#34;blue&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;use</span> <span style=color:#a6e22e>href=</span><span style=color:#e6db74>&#34;##myCircle&#34;</span> <span style=color:#a6e22e>x=</span><span style=color:#e6db74>&#34;200&#34;</span> <span style=color:#a6e22e>y=</span><span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#a6e22e>fill=</span><span style=color:#e6db74>&#34;white&#34;</span> <span style=color:#a6e22e>stroke=</span><span style=color:#e6db74>&#34;blue&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/svg&gt;</span>
</span></span></code></pre></div><h4 id=pattern标签><code>&lt;pattern></code>标签
<a class=header-anchor href=#pattern%e6%a0%87%e7%ad%be></a></h4><p><code>&lt;pattern></code>标签用于自定义一个形状，该形状可以被引用来平铺一个区域。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;svg</span> <span style=color:#a6e22e>width=</span><span style=color:#e6db74>&#34;500&#34;</span> <span style=color:#a6e22e>height=</span><span style=color:#e6db74>&#34;500&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;defs&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;pattern</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;dots&#34;</span> <span style=color:#a6e22e>x=</span><span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#a6e22e>y=</span><span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#a6e22e>width=</span><span style=color:#e6db74>&#34;100&#34;</span> <span style=color:#a6e22e>height=</span><span style=color:#e6db74>&#34;100&#34;</span> <span style=color:#a6e22e>patternUnits=</span><span style=color:#e6db74>&#34;userSpaceOnUse&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;circle</span> <span style=color:#a6e22e>fill=</span><span style=color:#e6db74>&#34;##bee9e8&#34;</span> <span style=color:#a6e22e>cx=</span><span style=color:#e6db74>&#34;50&#34;</span> <span style=color:#a6e22e>cy=</span><span style=color:#e6db74>&#34;50&#34;</span> <span style=color:#a6e22e>r=</span><span style=color:#e6db74>&#34;35&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;/pattern&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/defs&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;rect</span> <span style=color:#a6e22e>x=</span><span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#a6e22e>y=</span><span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#a6e22e>width=</span><span style=color:#e6db74>&#34;100%&#34;</span> <span style=color:#a6e22e>height=</span><span style=color:#e6db74>&#34;100%&#34;</span> <span style=color:#a6e22e>fill=</span><span style=color:#e6db74>&#34;url(##dots)&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/svg&gt;</span>
</span></span></code></pre></div><p>上面代码中，<code>&lt;pattern></code>标签将一个圆形定义为<code>dots</code>模式。<code>patternUnits="userSpaceOnUse"</code>表示<code>&lt;pattern></code>的宽度和长度是实际的像素值。然后，指定这个模式去填充下面的矩形。</p><h4 id=image标签><code>&lt;image></code>标签
<a class=header-anchor href=#image%e6%a0%87%e7%ad%be></a></h4><p><code>&lt;image></code>标签用于插入图片文件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;svg</span> <span style=color:#a6e22e>viewBox=</span><span style=color:#e6db74>&#34;0 0 100 100&#34;</span> <span style=color:#a6e22e>width=</span><span style=color:#e6db74>&#34;100&#34;</span> <span style=color:#a6e22e>height=</span><span style=color:#e6db74>&#34;100&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;image</span> <span style=color:#a6e22e>xlink:href=</span><span style=color:#e6db74>&#34;path/to/image.jpg&#34;</span>
</span></span><span style=display:flex><span>           <span style=color:#a6e22e>width=</span><span style=color:#e6db74>&#34;50%&#34;</span> <span style=color:#a6e22e>height=</span><span style=color:#e6db74>&#34;50%&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/svg&gt;</span>
</span></span></code></pre></div><p>上面代码中，<code>&lt;image></code>的<code>xlink:href</code>属性表示图像的来源。</p><h4 id=animate标签><code>&lt;animate></code>标签
<a class=header-anchor href=#animate%e6%a0%87%e7%ad%be></a></h4><p><code>&lt;animate></code>标签用于产生动画效果。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;svg</span> <span style=color:#a6e22e>width=</span><span style=color:#e6db74>&#34;500px&#34;</span> <span style=color:#a6e22e>height=</span><span style=color:#e6db74>&#34;500px&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;rect</span> <span style=color:#a6e22e>x=</span><span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#a6e22e>y=</span><span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#a6e22e>width=</span><span style=color:#e6db74>&#34;100&#34;</span> <span style=color:#a6e22e>height=</span><span style=color:#e6db74>&#34;100&#34;</span> <span style=color:#a6e22e>fill=</span><span style=color:#e6db74>&#34;##feac5e&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;animate</span> <span style=color:#a6e22e>attributeName=</span><span style=color:#e6db74>&#34;x&#34;</span> <span style=color:#a6e22e>from=</span><span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#a6e22e>to=</span><span style=color:#e6db74>&#34;500&#34;</span> <span style=color:#a6e22e>dur=</span><span style=color:#e6db74>&#34;2s&#34;</span> <span style=color:#a6e22e>repeatCount=</span><span style=color:#e6db74>&#34;indefinite&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/rect&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/svg&gt;</span>
</span></span></code></pre></div><p>上面代码中，矩形会不断移动，产生动画效果。</p><p><code>&lt;animate></code>的属性含义如下。</p><blockquote><ul><li>attributeName：发生动画效果的属性名。</li><li>from：单次动画的初始值。</li><li>to：单次动画的结束值。</li><li>dur：单次动画的持续时间。</li><li>repeatCount：动画的循环模式。</li></ul></blockquote><p>可以在多个属性上面定义动画。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;animate</span> <span style=color:#a6e22e>attributeName=</span><span style=color:#e6db74>&#34;x&#34;</span> <span style=color:#a6e22e>from=</span><span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#a6e22e>to=</span><span style=color:#e6db74>&#34;500&#34;</span> <span style=color:#a6e22e>dur=</span><span style=color:#e6db74>&#34;2s&#34;</span> <span style=color:#a6e22e>repeatCount=</span><span style=color:#e6db74>&#34;indefinite&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;animate</span> <span style=color:#a6e22e>attributeName=</span><span style=color:#e6db74>&#34;width&#34;</span> <span style=color:#a6e22e>to=</span><span style=color:#e6db74>&#34;500&#34;</span> <span style=color:#a6e22e>dur=</span><span style=color:#e6db74>&#34;2s&#34;</span> <span style=color:#a6e22e>repeatCount=</span><span style=color:#e6db74>&#34;indefinite&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span></code></pre></div><h4 id=animatetransform标签><code>&lt;animateTransform></code>标签
<a class=header-anchor href=#animatetransform%e6%a0%87%e7%ad%be></a></h4><p><code>&lt;animate></code>标签对 CSS 的<code>transform</code>属性不起作用，如果需要变形，就要使用<code>&lt;animateTransform></code>标签。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;svg</span> <span style=color:#a6e22e>width=</span><span style=color:#e6db74>&#34;500px&#34;</span> <span style=color:#a6e22e>height=</span><span style=color:#e6db74>&#34;500px&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;rect</span> <span style=color:#a6e22e>x=</span><span style=color:#e6db74>&#34;250&#34;</span> <span style=color:#a6e22e>y=</span><span style=color:#e6db74>&#34;250&#34;</span> <span style=color:#a6e22e>width=</span><span style=color:#e6db74>&#34;50&#34;</span> <span style=color:#a6e22e>height=</span><span style=color:#e6db74>&#34;50&#34;</span> <span style=color:#a6e22e>fill=</span><span style=color:#e6db74>&#34;##4bc0c8&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;animateTransform</span> <span style=color:#a6e22e>attributeName=</span><span style=color:#e6db74>&#34;transform&#34;</span> <span style=color:#a6e22e>type=</span><span style=color:#e6db74>&#34;rotate&#34;</span> <span style=color:#a6e22e>begin=</span><span style=color:#e6db74>&#34;0s&#34;</span> <span style=color:#a6e22e>dur=</span><span style=color:#e6db74>&#34;10s&#34;</span> <span style=color:#a6e22e>from=</span><span style=color:#e6db74>&#34;0 200 200&#34;</span> <span style=color:#a6e22e>to=</span><span style=color:#e6db74>&#34;360 400 400&#34;</span> <span style=color:#a6e22e>repeatCount=</span><span style=color:#e6db74>&#34;indefinite&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/rect&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/svg&gt;</span>
</span></span></code></pre></div><p>上面代码中，<code>&lt;animateTransform></code>的效果为旋转（<code>rotate</code>），这时<code>from</code>和<code>to</code>属性值有三个数字，第一个数字是角度值，第二个值和第三个值是旋转中心的坐标。<code>from="0 200 200"</code>表示开始时，角度为0，围绕<code>(200, 200)</code>开始旋转；<code>to="360 400 400"</code>表示结束时，角度为360，围绕<code>(400, 400)</code>旋转。</p><h3 id=javascript-操作>JavaScript 操作
<a class=header-anchor href=#javascript-%e6%93%8d%e4%bd%9c></a></h3><h4 id=dom-操作>DOM 操作
<a class=header-anchor href=#dom-%e6%93%8d%e4%bd%9c></a></h4><p>如果 SVG 代码直接写在 HTML 网页之中，它就成为网页 DOM 的一部分，可以直接用 DOM 操作。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>svg</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>id</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;mysvg&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>xmlns</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;http://www.w3.org/2000/svg&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>viewBox</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;0 0 800 600&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>preserveAspectRatio</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;xMidYMid meet&#34;</span>
</span></span><span style=display:flex><span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>circle</span> <span style=color:#a6e22e>id</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;mycircle&#34;</span> <span style=color:#a6e22e>cx</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;400&#34;</span> <span style=color:#a6e22e>cy</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;300&#34;</span> <span style=color:#a6e22e>r</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;50&#34;</span> /&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>svg</span>&gt;
</span></span></code></pre></div><p>上面代码插入网页之后，就可以用 CSS 定制样式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>circle</span> {
</span></span><span style=display:flex><span>    stroke-width: <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>    stroke: <span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>#f00</span>;
</span></span><span style=display:flex><span>    fill: <span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>#ff0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>circle</span>:<span style=color:#a6e22e>hover</span> {
</span></span><span style=display:flex><span>    stroke: <span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>#090</span>;
</span></span><span style=display:flex><span>    fill: <span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>#fff</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>然后，可以用 JavaScript 代码操作 SVG。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>mycircle</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;mycircle&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mycircle</span>.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;click&#39;</span>, <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>e</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;circle clicked - enlarging&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mycircle</span>.<span style=color:#a6e22e>setAttribute</span>(<span style=color:#e6db74>&#39;r&#39;</span>, <span style=color:#ae81ff>60</span>);
</span></span><span style=display:flex><span>}, <span style=color:#66d9ef>false</span>);
</span></span></code></pre></div><p>上面代码指定，如果点击图形，就改写<code>circle</code>元素的<code>r</code>属性。</p><h4 id=获取-svg-dom>获取 SVG DOM
<a class=header-anchor href=#%e8%8e%b7%e5%8f%96-svg-dom></a></h4><p>使用<code>&lt;object></code>、<code>&lt;iframe></code>、<code>&lt;embed></code>标签插入 SVG 文件，可以获取 SVG DOM。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>svgObject</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;object&#39;</span>).<span style=color:#a6e22e>contentDocument</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>svgIframe</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;iframe&#39;</span>).<span style=color:#a6e22e>contentDocument</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>svgEmbed</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;embed&#39;</span>).<span style=color:#a6e22e>getSVGDocument</span>();
</span></span></code></pre></div><p>注意，如果使用<code>&lt;img></code>标签插入 SVG 文件，就无法获取 SVG DOM。</p><h4 id=读取-svg-源码>读取 SVG 源码
<a class=header-anchor href=#%e8%af%bb%e5%8f%96-svg-%e6%ba%90%e7%a0%81></a></h4><p>由于 SVG 文件就是一段 XML 文本，因此可以通过读取 XML 代码的方式，读取 SVG 源码。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>id</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;svg-container&#34;</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>svg</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>xmlns</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;http://www.w3.org/2000/svg&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>xmlns:xlink</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;http://www.w3.org/1999/xlink&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>xml:space</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;preserve&#34;</span> <span style=color:#a6e22e>width</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;500&#34;</span> <span style=color:#a6e22e>height</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;440&#34;</span>
</span></span><span style=display:flex><span>    &gt;
</span></span><span style=display:flex><span>    <span style=color:#75715e>&lt;!-- svg code --&gt;</span>
</span></span><span style=display:flex><span>  &lt;/<span style=color:#f92672>svg</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>div</span>&gt;
</span></span></code></pre></div><p>使用<code>XMLSerializer</code>实例的<code>serializeToString()</code>方法，获取 SVG 元素的代码。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>svgString</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>XMLSerializer</span>()
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>serializeToString</span>(document.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;svg&#39;</span>));
</span></span></code></pre></div><h4 id=svg-图像转为-canvas-图像>SVG 图像转为 Canvas 图像
<a class=header-anchor href=#svg-%e5%9b%be%e5%83%8f%e8%bd%ac%e4%b8%ba-canvas-%e5%9b%be%e5%83%8f></a></h4><p>首先，需要新建一个<code>Image</code>对象，将 SVG 图像指定到该<code>Image</code>对象的<code>src</code>属性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>img</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Image</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>svg</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Blob</span>([<span style=color:#a6e22e>svgString</span>], {<span style=color:#a6e22e>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;image/svg+xml;charset=utf-8&#34;</span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>DOMURL</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>self</span>.<span style=color:#a6e22e>URL</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>self</span>.<span style=color:#a6e22e>webkitURL</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>self</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>url</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>DOMURL</span>.<span style=color:#a6e22e>createObjectURL</span>(<span style=color:#a6e22e>svg</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>src</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>url</span>;
</span></span></code></pre></div><p>然后，当图像加载完成后，再将它绘制到<code>&lt;canvas></code>元素。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>onload</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> () {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;canvas&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas</span>.<span style=color:#a6e22e>getContext</span>(<span style=color:#e6db74>&#39;2d&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>drawImage</span>(<span style=color:#a6e22e>img</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=实例折线图>实例：折线图
<a class=header-anchor href=#%e5%ae%9e%e4%be%8b%e6%8a%98%e7%ba%bf%e5%9b%be></a></h3><p>下面将一张数据表格画成折线图。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>Date |Amount
</span></span><span style=display:flex><span>-----|------
</span></span><span style=display:flex><span>2014-01-01 | $10
</span></span><span style=display:flex><span>2014-02-01 | $20
</span></span><span style=display:flex><span>2014-03-01 | $40
</span></span><span style=display:flex><span>2014-04-01 | $80
</span></span></code></pre></div><p>上面的图形，可以画成一个坐标系，<code>Date</code>作为横轴，<code>Amount</code>作为纵轴，四行数据画成一个数据点。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;svg</span> <span style=color:#a6e22e>width=</span><span style=color:#e6db74>&#34;350&#34;</span> <span style=color:#a6e22e>height=</span><span style=color:#e6db74>&#34;160&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;g</span> <span style=color:#a6e22e>class=</span><span style=color:#e6db74>&#34;layer&#34;</span> <span style=color:#a6e22e>transform=</span><span style=color:#e6db74>&#34;translate(60,10)&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;circle</span> <span style=color:#a6e22e>r=</span><span style=color:#e6db74>&#34;5&#34;</span> <span style=color:#a6e22e>cx=</span><span style=color:#e6db74>&#34;0&#34;</span>   <span style=color:#a6e22e>cy=</span><span style=color:#e6db74>&#34;105&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;circle</span> <span style=color:#a6e22e>r=</span><span style=color:#e6db74>&#34;5&#34;</span> <span style=color:#a6e22e>cx=</span><span style=color:#e6db74>&#34;90&#34;</span>  <span style=color:#a6e22e>cy=</span><span style=color:#e6db74>&#34;90&#34;</span>  <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;circle</span> <span style=color:#a6e22e>r=</span><span style=color:#e6db74>&#34;5&#34;</span> <span style=color:#a6e22e>cx=</span><span style=color:#e6db74>&#34;180&#34;</span> <span style=color:#a6e22e>cy=</span><span style=color:#e6db74>&#34;60&#34;</span>  <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;circle</span> <span style=color:#a6e22e>r=</span><span style=color:#e6db74>&#34;5&#34;</span> <span style=color:#a6e22e>cx=</span><span style=color:#e6db74>&#34;270&#34;</span> <span style=color:#a6e22e>cy=</span><span style=color:#e6db74>&#34;0&#34;</span>   <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;g</span> <span style=color:#a6e22e>class=</span><span style=color:#e6db74>&#34;y axis&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;line</span> <span style=color:#a6e22e>x1=</span><span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#a6e22e>y1=</span><span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#a6e22e>x2=</span><span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#a6e22e>y2=</span><span style=color:#e6db74>&#34;120&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;text</span> <span style=color:#a6e22e>x=</span><span style=color:#e6db74>&#34;-40&#34;</span> <span style=color:#a6e22e>y=</span><span style=color:#e6db74>&#34;105&#34;</span> <span style=color:#a6e22e>dy=</span><span style=color:#e6db74>&#34;5&#34;</span><span style=color:#f92672>&gt;</span>$10<span style=color:#f92672>&lt;/text&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;text</span> <span style=color:#a6e22e>x=</span><span style=color:#e6db74>&#34;-40&#34;</span> <span style=color:#a6e22e>y=</span><span style=color:#e6db74>&#34;0&#34;</span>   <span style=color:#a6e22e>dy=</span><span style=color:#e6db74>&#34;5&#34;</span><span style=color:#f92672>&gt;</span>$80<span style=color:#f92672>&lt;/text&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;/g&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;g</span> <span style=color:#a6e22e>class=</span><span style=color:#e6db74>&#34;x axis&#34;</span> <span style=color:#a6e22e>transform=</span><span style=color:#e6db74>&#34;translate(0, 120)&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;line</span> <span style=color:#a6e22e>x1=</span><span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#a6e22e>y1=</span><span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#a6e22e>x2=</span><span style=color:#e6db74>&#34;270&#34;</span> <span style=color:#a6e22e>y2=</span><span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;text</span> <span style=color:#a6e22e>x=</span><span style=color:#e6db74>&#34;-30&#34;</span>   <span style=color:#a6e22e>y=</span><span style=color:#e6db74>&#34;20&#34;</span><span style=color:#f92672>&gt;</span>January 2014<span style=color:#f92672>&lt;/text&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;text</span> <span style=color:#a6e22e>x=</span><span style=color:#e6db74>&#34;240&#34;</span> <span style=color:#a6e22e>y=</span><span style=color:#e6db74>&#34;20&#34;</span><span style=color:#f92672>&gt;</span>April<span style=color:#f92672>&lt;/text&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;/g&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/g&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/svg&gt;</span>
</span></span></code></pre></div><h3 id=参考链接-10>参考链接
<a class=header-anchor href=#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5-10></a></h3><ul><li>Jon McPartland,
<a href=http://bigbitecreative.com/introduction-svg-animation/ title="An introduction to SVG animation" rel="noopener external nofollow noreferrer" target=_blank class=exturl>An introduction to SVG animation
<i class="fa fa-external-link-alt"></i></a></li><li>Alexander Goedde,
<a href=http://tavendo.com/blog/post/super-vector-graphics/ title="SVG - Super Vector Graphics" rel="noopener external nofollow noreferrer" target=_blank class=exturl>SVG - Super Vector Graphics
<i class="fa fa-external-link-alt"></i></a></li><li>Joseph Wegner,
<a href=http://flippinawesome.org/2014/02/03/learning-svg/ title="Learning SVG" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Learning SVG
<i class="fa fa-external-link-alt"></i></a></li><li>biovisualize,
<a href=http://bl.ocks.org/biovisualize/8187844 title="Direct svg to canvas to png conversion" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Direct svg to canvas to png conversion
<i class="fa fa-external-link-alt"></i></a></li><li>Tyler Sticka,
<a href=https://cloudfour.com/thinks/cropping-image-thumbnails-with-svg/ title="Cropping Image Thumbnails with SVG" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Cropping Image Thumbnails with SVG
<i class="fa fa-external-link-alt"></i></a></li><li>Adi Purdila,
<a href=https://webdesign.tutsplus.com/tutorials/how-to-create-a-loader-icon-with-svg-animations--cms-31542 title="How to Create a Loader Icon With SVG Animations" rel="noopener external nofollow noreferrer" target=_blank class=exturl>How to Create a Loader Icon With SVG Animations
<i class="fa fa-external-link-alt"></i></a></li></ul><h2 id=web-share-api>Web Share API
<a class=header-anchor href=#web-share-api></a></h2><h3 id=概述-2>概述
<a class=header-anchor href=#%e6%a6%82%e8%bf%b0-2></a></h3><p>网页内容如果要分享到其他应用，通常要自己实现分享接口，逐一给出目标应用的连接方式。这样很麻烦，也对网页性能有一定影响。Web Share API 就是为了解决这个问题而提出的，允许网页调用操作系统的分享接口，实质是 Web App 与本机的应用程序交换信息的一种方式。</p><p>这个 API 不仅可以改善网页性能，而且不限制分享目标的数量和类型。社交媒体应用、电子邮件、即时消息、以及本地系统安装的、且接受分享的应用，都会出现在系统的分享弹窗，这对手机网页尤其有用。另外，使用这个接口只需要一个分享按钮，而传统的网页分享有多个分享目标，就有多少个分享按钮。</p><p>目前，桌面的 Safari 浏览器，手机的安卓 Chrome 浏览器和 iOS Safari 浏览器，支持这个 API。</p><p>这个 API 要求网站必须启用 HTTPS 协议，但是本地 Localhost 开发可以使用 HTTP 协议。另外，这个 API 不能直接调用，只能用来响应用户的操作（比如<code>click</code>事件）。</p><h3 id=接口细节>接口细节
<a class=header-anchor href=#%e6%8e%a5%e5%8f%a3%e7%bb%86%e8%8a%82></a></h3><p>该接口部署在<code>navigator.share</code>，可以用下面的代码检查本机是否支持该接口。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>share</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 支持
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 不支持
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p><code>navigator.share</code>是一个函数方法，接受一个配置对象作为参数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>share</span>({
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>title</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;WebShare API Demo&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>url</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;https://codepen.io/ayoisaiah/pen/YbNazJ&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>text</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;我正在看《Web Share API》&#39;</span>
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>配置对象有三个属性，都是可选的，但至少必须指定一个。</p><ul><li><code>title</code>：分享文档的标题。</li><li><code>url</code>：分享的 URL。</li><li><code>text</code>：分享的内容。</li></ul><p>一般来说，<code>url</code>是当前网页的网址，<code>title</code>是当前网页的标题，可以采用下面的写法获取。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>title</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>title</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>url</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;link[rel=canonical]&#39;</span>) <span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>    document.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;link[rel=canonical]&#39;</span>).<span style=color:#a6e22e>href</span> <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    document.<span style=color:#a6e22e>location</span>.<span style=color:#a6e22e>href</span>;
</span></span></code></pre></div><p><code>navigator.share</code>的返回值是一个 Promise 对象。这个方法调用之后，会立刻弹出系统的分享弹窗，用户操作完毕之后，Promise 对象就会变为<code>resolved</code>状态。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>share</span>({
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>title</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;WebShare API Demo&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>url</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;https://codepen.io/ayoisaiah/pen/YbNazJ&#39;</span>
</span></span><span style=display:flex><span>}).<span style=color:#a6e22e>then</span>(() =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;Thanks for sharing!&#39;</span>);
</span></span><span style=display:flex><span>}).<span style=color:#66d9ef>catch</span>((<span style=color:#a6e22e>error</span>) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#39;Sharing error&#39;</span>, <span style=color:#a6e22e>error</span>);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>由于返回值是 Promise 对象，所以也可以使用<code>await</code>命令。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>shareButton</span>.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;click&#39;</span>, <span style=color:#66d9ef>async</span> () =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>share</span>({ <span style=color:#a6e22e>title</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Example Page&#39;</span>, <span style=color:#a6e22e>url</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;&#39;</span> });
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;Data was shared successfully&#39;</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>err</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#39;Share failed:&#39;</span>, <span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>message</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h3 id=分享文件>分享文件
<a class=header-anchor href=#%e5%88%86%e4%ba%ab%e6%96%87%e4%bb%b6></a></h3><p>这个 API 还可以分享文件，先使用<code>navigator.canShare()</code>方法，判断一下目标文件是否可以分享。因为不是所有文件都允许分享的，目前图像，视频，音频和文本文件可以分享2。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>canShare</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>canShare</span>({ <span style=color:#a6e22e>files</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>filesArray</span> })) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>上面代码中，<code>navigator.canShare()</code>方法的参数对象，就是<code>navigator.share()</code>方法的参数对象。这里的关键是<code>files</code>属性，它的值是一个<code>FileList</code>实例对象。</p><p><code>navigator.canShare()</code>方法返回一个布尔值，如果为<code>true</code>，就可以使用<code>navigator.share()</code>方法分享文件了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>canShare</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>canShare</span>({ <span style=color:#a6e22e>files</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>filesArray</span> })) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>share</span>({
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>files</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>filesArray</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>title</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Vacation Pictures&#39;</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>text</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Photos from September 27 to October 14.&#39;</span>,
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>        .<span style=color:#a6e22e>then</span>(() =&gt; <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;Share was successful.&#39;</span>))
</span></span><span style=display:flex><span>        .<span style=color:#66d9ef>catch</span>((<span style=color:#a6e22e>error</span>) =&gt; <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;Sharing failed&#39;</span>, <span style=color:#a6e22e>error</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=参考链接-11>参考链接
<a class=header-anchor href=#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5-11></a></h3><ul><li><a href=https://css-tricks.com/how-to-use-the-web-share-api/ title="How to Use the Web Share API" rel="noopener external nofollow noreferrer" target=_blank class=exturl>How to Use the Web Share API
<i class="fa fa-external-link-alt"></i>
</a>, Ayooluwa Isaiah</li><li><a href=https://wicg.github.io/web-share/ title="Web Share API - Level 1" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Web Share API - Level 1
<i class="fa fa-external-link-alt"></i>
</a>, W3C</li><li><a href=https://developers.google.com/web/updates/2016/09/navigator-share title="Introducing the Web Share API" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Introducing the Web Share API
<i class="fa fa-external-link-alt"></i>
</a>, Paul Kinlan, Sam Thorogood</li><li><a href=https://web.dev/web-share/ title="Share like a native app with the Web Share API" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Share like a native app with the Web Share API
<i class="fa fa-external-link-alt"></i>
</a>, Joe Medley</li></ul><h2 id=web-audio-api>Web Audio API
<a class=header-anchor href=#web-audio-api></a></h2><p>Web Audio API 用于操作声音。这个 API 可以让网页发出声音。</p><h3 id=基本用法-2>基本用法
<a class=header-anchor href=#%e5%9f%ba%e6%9c%ac%e7%94%a8%e6%b3%95-2></a></h3><p>浏览器原生提供<code>AudioContext</code>对象，该对象用于生成一个声音的上下文，与扬声器相连。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>audioContext</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>AudioContext</span>();
</span></span></code></pre></div><p>然后，获取音源文件，将其在内存中解码，就可以播放声音了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>context</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>AudioContext</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;sound.mp4&#39;</span>)
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>response</span> =&gt; <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>arrayBuffer</span>())
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>arrayBuffer</span> =&gt; <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>decodeAudioData</span>(<span style=color:#a6e22e>arrayBuffer</span>))
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>audioBuffer</span> =&gt; {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 播放声音
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>source</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>createBufferSource</span>();
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>source</span>.<span style=color:#a6e22e>buffer</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>audioBuffer</span>;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>source</span>.<span style=color:#a6e22e>connect</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>destination</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>source</span>.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>    });
</span></span></code></pre></div><h3 id=contextcreatebuffer>context.createBuffer()
<a class=header-anchor href=#contextcreatebuffer></a></h3><p><code>context.createBuffer()</code>方法生成一个内存的操作视图，用于存放数据。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>buffer</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>audioContext</span>.<span style=color:#a6e22e>createBuffer</span>(<span style=color:#a6e22e>channels</span>, <span style=color:#a6e22e>signalLength</span>, <span style=color:#a6e22e>sampleRate</span>);
</span></span></code></pre></div><p><code>createBuffer</code>方法接受三个参数。</p><ul><li>channels：整数，表示声道。创建单声道的声音，该值为 1。</li><li>signalLength：整数，表示声音数组的长度。</li><li>sampleRate：浮点数，表示取样率，即一秒取样多少次。</li></ul><p><code>signalLength</code>和<code>sampleRate</code>这两个参数决定了声音的长度。比如，如果取样率是<code>1/3000</code>（每秒取样3000次），声音数组长度是6000，那么播放的声音是2秒长度。</p><p>接着，使用<code>buffer.getChannelData</code>方法取出一个声道。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>buffer</span>.<span style=color:#a6e22e>getChannelData</span>(<span style=color:#ae81ff>0</span>)
</span></span></code></pre></div><p>上面代码中，<code>buffer.getChannelData</code>的参数<code>0</code>表示取出第一个声道。</p><p>下一步，将声音数组放入这个声道。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>buffer</span>.<span style=color:#a6e22e>getChannelData</span>(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// singal 是一个声音数组
</span></span></span><span style=display:flex><span><span style=color:#75715e>// singalLengal 是该数组的长度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>signalLength</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>data</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>signal</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>最后，使用<code>context.createBufferSource</code>方法生成一个声音节点。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 生成一个声音节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>node</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>audioContext</span>.<span style=color:#a6e22e>createBufferSource</span>();
</span></span><span style=display:flex><span><span style=color:#75715e>// 将声音数组的内存对象，放入这个节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>buffer</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>buffer</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>// 将声音上下文与节点连接
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>connect</span>(<span style=color:#a6e22e>audioContext</span>.<span style=color:#a6e22e>destination</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// 开始播放声音
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>start</span>(<span style=color:#a6e22e>audioContext</span>.<span style=color:#a6e22e>currentTime</span>);
</span></span></code></pre></div><p>默认情况下，播放一次后就将停止播放。如果需要循环播放，可以将节点对象的<code>looping</code>属性设为<code>true</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>looping</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span></code></pre></div><h3 id=过滤器>过滤器
<a class=header-anchor href=#%e8%bf%87%e6%bb%a4%e5%99%a8></a></h3><p>Web Audio API 原生提供了一些过滤器（filter），用来处理声音。</p><p>首先，使用<code>context.createBiquadFilter</code>方法建立过滤器实例。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>filter</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>audioContext</span>.<span style=color:#a6e22e>createBiquadFilter</span>();
</span></span></code></pre></div><p>然后，通过<code>filter.type</code>属性指定过滤器的类型。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>filter</span>.<span style=color:#a6e22e>type</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;lowpass&#39;</span>;
</span></span></code></pre></div><p>目前，过滤器有以下这些类型。</p><ul><li>lowpass</li><li>highpass</li><li>bandpass</li><li>lowshelf</li><li>highshelf</li><li>peaking</li><li>notch</li><li>allpass</li></ul><p>然后指定过滤器的频率（frequency）属性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>filter</span>.<span style=color:#a6e22e>frequency</span>.<span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>frequency</span>
</span></span></code></pre></div><p>最后，过滤器实例连接节点实例，就可以生效了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>sourceNode</span>.<span style=color:#a6e22e>connect</span>(<span style=color:#a6e22e>filter</span>);
</span></span></code></pre></div><h2 id=web-components>Web Components
<a class=header-anchor href=#web-components></a></h2><h3 id=概述-3>概述
<a class=header-anchor href=#%e6%a6%82%e8%bf%b0-3></a></h3><p>各种网站往往需要一些相同的模块，比如日历、调色板等等，这种模块就被称为“组件”（component）。Web Components 就是浏览器原生的组件规范。</p><p>采用组件开发，有很多优点。</p><p>（1）有利于代码复用。组件是模块化编程思想的体现，可以跨平台、跨框架使用，构建、部署和与其他 UI 元素互动都有统一做法。</p><p>（2）使用非常容易。加载或卸载组件，只要添加或删除一行代码就可以了。</p><p>（3）开发和定制很方便。组件开发不需要使用框架，只要用原生的语法就可以了。开发好的组件往往留出接口，供使用者设置常见属性，比如上面代码的<code>heading</code>属性，就是用来设置对话框的标题。</p><p>（4）组件提供了 HTML、CSS、JavaScript 封装的方法，实现了与同一页面上其他代码的隔离。</p><p>未来的网站开发，可以像搭积木一样，把组件合在一起，就组成了一个网站。这种前景是非常诱人的。</p><p>Web Components 不是单一的规范，而是一系列的技术组成，以下是它的四个构成。</p><ul><li>Custom Elements</li><li>Template</li><li>Shadow DOM</li><li>HTML Import</li></ul><p>使用时，并不一定上面四种 API 都要用到。其中，Custom Element 和 Shadow DOM 比较重要，Template 和 HTML Import 只起到辅助作用。</p><h3 id=custom-element>Custom Element
<a class=header-anchor href=#custom-element></a></h3><h4 id=简介-4>简介
<a class=header-anchor href=#%e7%ae%80%e4%bb%8b-4></a></h4><p>HTML 标准定义的网页元素，有时并不符合我们的需要，这时浏览器允许用户自定义网页元素，这就叫做 Custom Element。简单说，它就是用户自定义的网页元素，是 Web components 技术的核心。</p><p>举例来说，你可以自定义一个叫做<code>&lt;my-element></code>的网页元素。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>my-element</span>&gt;&lt;/<span style=color:#f92672>my-element</span>&gt;
</span></span></code></pre></div><p>注意，自定义网页元素的标签名必须含有连字符<code>-</code>，一个或多个连字符都可以。这是因为浏览器内置的的 HTML 元素标签名，都不含有连字符，这样可以做到有效区分。</p><p>下面的代码先定义一个自定义元素的类。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyElement</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>HTMLElement</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>constructor</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>attachShadow</span>( { <span style=color:#a6e22e>mode</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;open&#39;</span> } );
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>shadowRoot</span>.<span style=color:#a6e22e>innerHTML</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>`
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      &lt;style&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        /* scoped styles */
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      &lt;/style&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      &lt;slot&gt;&lt;/slot&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    `</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#a6e22e>get</span> <span style=color:#a6e22e>observedAttributes</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Return list of attributes to watch.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>attributeChangedCallback</span>( <span style=color:#a6e22e>name</span>, <span style=color:#a6e22e>oldValue</span>, <span style=color:#a6e22e>newValue</span> ) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Run functionality when one of these attributes is changed.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>connectedCallback</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Run functionality when an instance of this element is inserted into the DOM.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>disconnectedCallback</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Run functionality when an instance of this element is removed from the DOM.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码有几个注意点。</p><ul><li>自定义元素类的基类是<code>HTMLElement</code>。当然也可以根据需要，基于<code>HTMLElement</code>的子类，比如<code>HTMLButtonElement</code>。</li><li>构造函数内部定义了 Shadow DOM。所谓<code>Shadow DOM</code>指的是，这部分的 HTML 代码和样式，不直接暴露给用户。</li><li>类可以定义生命周期方法，比如<code>connectedCallback()</code>。</li></ul><p>然后，<code>window.customElements.define()</code>方法，用来登记自定义元素与这个类之间的映射。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span>window.<span style=color:#a6e22e>customElements</span>.<span style=color:#a6e22e>define</span>(<span style=color:#e6db74>&#39;my-element&#39;</span>, <span style=color:#a6e22e>MyElement</span>);
</span></span></code></pre></div><p>登记以后，页面上的每一个<code>&lt;my-element></code>元素都是一个<code>MyElement</code>类的实例。只要浏览器解析到<code>&lt;my-element></code>元素，就会运行<code>MyElement</code>的构造函数。</p><p>注意，如果没有登记就使用 Custom Element，浏览器会认为这是一个不认识的元素，会当做空的 div 元素处理。</p><p><code>window.customElements.define()</code>方法定义了 Custom Element 以后，可以使用<code>window.customeElements.get()</code>方法获取该元素的构造方法。这使得除了直接插入 HTML 网页，Custom Element 也能使用脚本插入网页。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span>window.<span style=color:#a6e22e>customElements</span>.<span style=color:#a6e22e>define</span>(
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;my-element&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>HTMLElement</span> {...}
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>el</span> <span style=color:#f92672>=</span> window.<span style=color:#a6e22e>customElements</span>.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#39;my-element&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>myElement</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>el</span>();
</span></span><span style=display:flex><span>document.<span style=color:#a6e22e>body</span>.<span style=color:#a6e22e>appendChild</span>(<span style=color:#a6e22e>myElement</span>);
</span></span></code></pre></div><p>如果你想扩展现有的 HTML 元素（比如<code>&lt;button></code>）也是可以的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GreetingElement</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>HTMLButtonElement</span>
</span></span></code></pre></div><p>登记的时候，需要提供扩展的元素。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>customElements</span>.<span style=color:#a6e22e>define</span>(<span style=color:#e6db74>&#39;hey-there&#39;</span>, <span style=color:#a6e22e>GreetingElement</span>, { <span style=color:#66d9ef>extends</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;button&#39;</span> });
</span></span></code></pre></div><p>使用的时候，为元素加上<code>is</code>属性就可以了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>is</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;hey-there&#34;</span> <span style=color:#a6e22e>name</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;World&#34;</span>&gt;Howdy&lt;/<span style=color:#f92672>button</span>&gt;
</span></span></code></pre></div><h4 id=生命周期方法>生命周期方法
<a class=header-anchor href=#%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e6%96%b9%e6%b3%95></a></h4><p>Custom Element 提供一些生命周期方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyElement</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>HTMLElement</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>constructor</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>connectedCallback</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// here the element has been inserted into the DOM
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码中，<code>connectedCallback()</code>方法就是<code>MyElement</code>元素的生命周期方法。每次，该元素插入 DOM，就会自动执行该方法。</p><ul><li><code>connectedCallback()</code>：插入 DOM 时调用。这可能不止一次发生，比如元素被移除后又重新添加。类的设置应该尽量放到这个方法里面执行，因为这时各种属性和子元素都可用。</li><li><code>disconnectedCallback()</code>：移出 DOM 时执行。</li><li><code>attributeChangedCallback(attrName, oldVal, newVal)</code>：添加、删除、更新或替换属性时调用。元素创建或升级时，也会调用。注意：只有加入<code>observedAttributes</code>的属性才会执行这个方法。</li><li><code>adoptedCallback()</code>：自定义元素移动到新的 document 时调用，比如执行<code>document.adoptNode(element)</code>时。</li></ul><p>下面是一个例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GreetingElement</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>HTMLElement</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>constructor</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Stranger&#39;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>connectedCallback</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;click&#39;</span>, <span style=color:#a6e22e>e</span> =&gt; <span style=color:#a6e22e>alert</span>(<span style=color:#e6db74>`Hello, </span><span style=color:#e6db74>${</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_name</span><span style=color:#e6db74>}</span><span style=color:#e6db74>!`</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>attributeChangedCallback</span>(<span style=color:#a6e22e>attrName</span>, <span style=color:#a6e22e>oldValue</span>, <span style=color:#a6e22e>newValue</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>attrName</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;name&#39;</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>newValue</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_name</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>newValue</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Stranger&#39;</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>GreetingElement</span>.<span style=color:#a6e22e>observedAttributes</span> <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;name&#39;</span>];
</span></span><span style=display:flex><span><span style=color:#a6e22e>customElements</span>.<span style=color:#a6e22e>define</span>(<span style=color:#e6db74>&#39;hey-there&#39;</span>, <span style=color:#a6e22e>GreetingElement</span>);
</span></span></code></pre></div><p>上面代码中，<code>GreetingElement.observedAttributes</code>属性用来指定白名单里面的属性，上例是<code>name</code>属性。只要这个属性的值发生变化，就会自动调用<code>attributeChangedCallback</code>方法。</p><p>使用上面这个类的方法如下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>hey-there</span>&gt;Greeting&lt;/<span style=color:#f92672>hey-there</span>&gt;
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>hey-there</span> <span style=color:#a6e22e>name</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Potch&#34;</span>&gt;Personalized Greeting&lt;/<span style=color:#f92672>hey-there</span>&gt;
</span></span></code></pre></div><p><code>attributeChangedCallback</code>方法主要用于外部传入的属性，就像上面例子中<code>name="Potch"</code>。</p><p>生命周期方法调用的顺序如下：<code>constructor</code> -> <code>attributeChangedCallback</code> -> <code>connectedCallback</code>，即<code>attributeChangedCallback</code>早于<code>connectedCallback</code>执行。这是因为<code>attributeChangedCallback</code>相当于调整配置，应该在插入 DOM 之前完成。</p><p>下面的例子能够更明显地看出这一点，在插入 DOM 前修改 Custome Element 的颜色。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyElement</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>HTMLElement</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>constructor</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>container</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>shadowRoot</span>.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;##container&#39;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>attributeChangedCallback</span>(<span style=color:#a6e22e>attr</span>, <span style=color:#a6e22e>oldVal</span>, <span style=color:#a6e22e>newVal</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>attr</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;disabled&#39;</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>hasAttribute</span>(<span style=color:#e6db74>&#39;disabled&#39;</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>container</span>.<span style=color:#a6e22e>style</span>.<span style=color:#a6e22e>background</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;##808080&#39;</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>container</span>.<span style=color:#a6e22e>style</span>.<span style=color:#a6e22e>background</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;##ffffff&#39;</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=自定义属性和方法>自定义属性和方法
<a class=header-anchor href=#%e8%87%aa%e5%ae%9a%e4%b9%89%e5%b1%9e%e6%80%a7%e5%92%8c%e6%96%b9%e6%b3%95></a></h4><p>Custom Element 允许自定义属性或方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyElement</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>HTMLElement</span> {
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>doSomething</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// do something in this method
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码中，<code>doSomething()</code>就是<code>MyElement</code>的自定义方法，使用方法如下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>element</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;my-element&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>element</span>.<span style=color:#a6e22e>doSomething</span>();
</span></span></code></pre></div><p>自定义属性可以使用 JavaScript class 的所有语法，因此也可以设置取值器和赋值器。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyElement</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>HTMLElement</span> {
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>set</span> <span style=color:#a6e22e>disabled</span>(<span style=color:#a6e22e>isDisabled</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>isDisabled</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>setAttribute</span>(<span style=color:#e6db74>&#39;disabled&#39;</span>, <span style=color:#e6db74>&#39;&#39;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>removeAttribute</span>(<span style=color:#e6db74>&#39;disabled&#39;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>get</span> <span style=color:#a6e22e>disabled</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>hasAttribute</span>(<span style=color:#e6db74>&#39;disabled&#39;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码中的取值器和赋值器，可用于<code>&lt;my-input name="name" disabled></code>这样的用法。</p><h4 id=windowcustomelementswhendefined>window.customElements.whenDefined()
<a class=header-anchor href=#windowcustomelementswhendefined></a></h4><p><code>window.customElements.whenDefined()</code>方法在一个 Custom Element 被<code>customElements.define()</code>方法定义以后执行，用于“升级”一个元素。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span>window.<span style=color:#a6e22e>customElements</span>.<span style=color:#a6e22e>whenDefined</span>(<span style=color:#e6db74>&#39;my-element&#39;</span>)
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>then</span>(() =&gt; {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// my-element is now defined
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    })
</span></span></code></pre></div><p>如果某个属性值发生变化时，需要做出反应，可以将它放入<code>observedAttributes</code>数组。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyElement</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>HTMLElement</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#a6e22e>get</span> <span style=color:#a6e22e>observedAttributes</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> [<span style=color:#e6db74>&#39;disabled&#39;</span>];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>constructor</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>shadowRoot</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>attachShadow</span>({<span style=color:#a6e22e>mode</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;open&#39;</span>});
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>shadowRoot</span>.<span style=color:#a6e22e>innerHTML</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>`
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      &lt;style&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        .disabled {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          opacity: 0.4;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      &lt;/style&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      &lt;div id=&#34;container&#34;&gt;&lt;/div&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    `</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>container</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>shadowRoot</span>(<span style=color:#e6db74>&#39;##container&#39;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>attributeChangedCallback</span>(<span style=color:#a6e22e>attr</span>, <span style=color:#a6e22e>oldVal</span>, <span style=color:#a6e22e>newVal</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>attr</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;disabled&#39;</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>disabled</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>container</span>.<span style=color:#a6e22e>classList</span>.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#39;disabled&#39;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>container</span>.<span style=color:#a6e22e>classList</span>.<span style=color:#a6e22e>remove</span>(<span style=color:#e6db74>&#39;disabled&#39;</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=回调函数>回调函数
<a class=header-anchor href=#%e5%9b%9e%e8%b0%83%e5%87%bd%e6%95%b0></a></h4><p>自定义元素的原型有一些属性，用来指定回调函数，在特定事件发生时触发。</p><ul><li><strong>createdCallback</strong>：实例生成时触发</li><li><strong>attachedCallback</strong>：实例插入HTML文档时触发</li><li><strong>detachedCallback</strong>：实例从HTML文档移除时触发</li><li><strong>attributeChangedCallback(attrName, oldVal, newVal)</strong>：实例的属性发生改变时（添加、移除、更新）触发</li></ul><p>下面是一个例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>proto</span> <span style=color:#f92672>=</span> Object.<span style=color:#a6e22e>create</span>(<span style=color:#a6e22e>HTMLElement</span>.<span style=color:#a6e22e>prototype</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>proto</span>.<span style=color:#a6e22e>createdCallback</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;created&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>innerHTML</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;This is a my-demo element!&#39;</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>proto</span>.<span style=color:#a6e22e>attachedCallback</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;attached&#39;</span>);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>XFoo</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>registerElement</span>(<span style=color:#e6db74>&#39;x-foo&#39;</span>, {<span style=color:#a6e22e>prototype</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>proto</span>});
</span></span></code></pre></div><p>利用回调函数，可以方便地在自定义元素中插入HTML语句。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>XFooProto</span> <span style=color:#f92672>=</span> Object.<span style=color:#a6e22e>create</span>(<span style=color:#a6e22e>HTMLElement</span>.<span style=color:#a6e22e>prototype</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>XFooProto</span>.<span style=color:#a6e22e>createdCallback</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>innerHTML</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&lt;b&gt;I&#39;m an x-foo-with-markup!&lt;/b&gt;&#34;</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>XFoo</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>registerElement</span>(<span style=color:#e6db74>&#39;x-foo-with-markup&#39;</span>,
</span></span><span style=display:flex><span>    {<span style=color:#a6e22e>prototype</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>XFooProto</span>});
</span></span></code></pre></div><p>上面代码定义了createdCallback回调函数，生成实例时，该函数运行，插入如下的HTML语句。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>x-foo-with-markup</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>b</span>&gt;I&#39;m an x-foo-with-markup!&lt;/<span style=color:#f92672>b</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>x-foo-with-markup</span>&gt;
</span></span></code></pre></div><h4 id=custom-element-的子元素>Custom Element 的子元素
<a class=header-anchor href=#custom-element-%e7%9a%84%e5%ad%90%e5%85%83%e7%b4%a0></a></h4><p>用户使用 Custom Element 时候，可以在内部放置子元素。Custom Element 提供<code>&lt;slot></code>用来引用内部内容。</p><p>下面的<code>&lt;image-gallery></code>是一个 Custom Element。用户在里面放置了子元素。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>image-gallery</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>img</span> <span style=color:#a6e22e>src</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;foo.jpg&#34;</span> <span style=color:#a6e22e>slot</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;image&#34;</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>img</span> <span style=color:#a6e22e>src</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;bar.jpg&#34;</span> <span style=color:#a6e22e>slot</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;image&#34;</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>image-gallery</span>&gt;
</span></span></code></pre></div><p><code>&lt;image-gallery></code>内部的模板如下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>id</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;container&#34;</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;images&#34;</span>&gt;
</span></span><span style=display:flex><span>        &lt;<span style=color:#f92672>slot</span> <span style=color:#a6e22e>name</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;image&#34;</span>&gt;&lt;/<span style=color:#f92672>slot</span>&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>div</span>&gt;
</span></span></code></pre></div><p>最终合成的代码如下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>id</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;container&#34;</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;images&#34;</span>&gt;
</span></span><span style=display:flex><span>        &lt;<span style=color:#f92672>slot</span> <span style=color:#a6e22e>name</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;image&#34;</span>&gt;
</span></span><span style=display:flex><span>            &lt;<span style=color:#f92672>img</span> <span style=color:#a6e22e>src</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;foo.jpg&#34;</span> <span style=color:#a6e22e>slot</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;image&#34;</span>&gt;
</span></span><span style=display:flex><span>            &lt;<span style=color:#f92672>img</span> <span style=color:#a6e22e>src</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;bar.jpg&#34;</span> <span style=color:#a6e22e>slot</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;image&#34;</span>&gt;
</span></span><span style=display:flex><span>        &lt;/<span style=color:#f92672>slot</span>&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>div</span>&gt;
</span></span></code></pre></div><h3 id=template标签><code>&lt;template></code>标签
<a class=header-anchor href=#template%e6%a0%87%e7%ad%be></a></h3><h4 id=基本用法-3>基本用法
<a class=header-anchor href=#%e5%9f%ba%e6%9c%ac%e7%94%a8%e6%b3%95-3></a></h4><p><code>&lt;template></code>标签表示组件的 HTML 代码模板。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>template</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>h1</span>&gt;This won&#39;t display!&lt;/<span style=color:#f92672>h1</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>script</span>&gt;<span style=color:#a6e22e>alert</span>(<span style=color:#e6db74>&#34;this won&#39;t alert!&#34;</span>);&lt;/<span style=color:#f92672>script</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>template</span>&gt;
</span></span></code></pre></div><p><code>&lt;template></code>内部就是正常的 HTML 代码，浏览器不会将这些代码加入 DOM。</p><p>下面的代码会将模板内部的代码插入 DOM。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>template</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;template&#39;</span>);
</span></span><span style=display:flex><span>document.<span style=color:#a6e22e>body</span>.<span style=color:#a6e22e>appendChild</span>(<span style=color:#a6e22e>template</span>.<span style=color:#a6e22e>content</span>);
</span></span></code></pre></div><p>注意，模板内部的代码只能插入一次，如果第二次执行上面的代码就会报错。</p><p>如果需要多次插入模板，可以复制<code>&lt;template></code>内部代码，然后再插入。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span>document.<span style=color:#a6e22e>body</span>.<span style=color:#a6e22e>appendChild</span>(<span style=color:#a6e22e>template</span>.<span style=color:#a6e22e>content</span>.<span style=color:#a6e22e>cloneNode</span>(<span style=color:#66d9ef>true</span>));
</span></span></code></pre></div><p>上面代码中，<code>cloneNode()</code>方法的参数<code>true</code>表示复制包含所有子节点。</p><p>接受<code>&lt;template></code>插入的元素，叫做宿主元素（host）。在<code>&lt;template></code>之中，可以对宿主元素设置样式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>template</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>style</span>&gt;
</span></span><span style=display:flex><span>        :<span style=color:#a6e22e>host</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>background</span>: <span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>#f8f8f8</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        :<span style=color:#a6e22e>host</span><span style=color:#f92672>(</span>:<span style=color:#a6e22e>hover</span><span style=color:#f92672>)</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>background</span>: <span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>#ccc</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>style</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>template</span>&gt;
</span></span></code></pre></div><h4 id=documentimportnode>document.importNode()
<a class=header-anchor href=#documentimportnode></a></h4><p>document.importNode方法用于克隆外部文档的DOM节点。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>iframe</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementsByTagName</span>(<span style=color:#e6db74>&#34;iframe&#34;</span>)[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>oldNode</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>iframe</span>.<span style=color:#a6e22e>contentWindow</span>.document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#34;myNode&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>newNode</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>importNode</span>(<span style=color:#a6e22e>oldNode</span>, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#34;container&#34;</span>).<span style=color:#a6e22e>appendChild</span>(<span style=color:#a6e22e>newNode</span>);
</span></span></code></pre></div><p>上面例子是将iframe窗口之中的节点oldNode，克隆进入当前文档。</p><p>注意，克隆节点之后，还必须用appendChild方法将其加入当前文档，否则不会显示。换个角度说，这意味着插入外部文档节点之前，必须用document.importNode方法先将这个节点准备好。</p><p>document.importNode方法接受两个参数，第一个参数是外部文档的DOM节点，第二个参数是一个布尔值，表示是否连同子节点一起克隆，默认为false。大多数情况下，必须显式地将第二个参数设为true。</p><h3 id=shadow-dom>Shadow DOM
<a class=header-anchor href=#shadow-dom></a></h3><p>所谓 Shadow DOM 指的是，浏览器将模板、样式表、属性、JavaScript 码等，封装成一个独立的 DOM 元素。外部的设置无法影响到其内部，而内部的设置也不会影响到外部，与浏览器处理原生网页元素（比如<code>&lt;video></code>元素）的方式很像。</p><p>Shadow DOM 最大的好处有两个，一是可以向用户隐藏细节，直接提供组件，二是可以封装内部样式表，不会影响到外部。</p><p>Custom Element 内部有一个 Shadow Root。它就是接入外部 DOM 的根元素。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// attachShadow() creates a shadow root.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>shadow</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>div</span>.<span style=color:#a6e22e>attachShadow</span>({ <span style=color:#a6e22e>mode</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;open&#39;</span> });
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>inner</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>createElement</span>(<span style=color:#e6db74>&#39;b&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>inner</span>.<span style=color:#a6e22e>appendChild</span>(document.<span style=color:#a6e22e>createTextNode</span>(<span style=color:#e6db74>&#39;Hiding in the shadows&#39;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// shadow root supports the normal appendChild method.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>shadow</span>.<span style=color:#a6e22e>appendChild</span>(<span style=color:#a6e22e>inner</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>div</span>.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;b&#39;</span>); <span style=color:#75715e>// empty
</span></span></span></code></pre></div><p>上面代码中，<code>&lt;div></code>包含<code>&lt;b></code>，但是 DOM 方法无法看到它，而且页面的样式也影响不到它。</p><p><code>mode: 'open'</code>表示开发者工具里面，可以看到 Custom HTML 内部的 DOM，并与之互动。<code>mode: closed</code>将不允许 Custom Element 的使用者与内部代码互动。</p><p>Shadow root 内部通过指定<code>innerHTML</code>属性或使用<code>&lt;template></code>元素，指定 HTML 代码。</p><p>Shadow DOM 内部可以通过向根添加<code>&lt;style></code>（或<code>&lt;link></code>）来设置样式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>style</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>createElement</span>(<span style=color:#e6db74>&#39;style&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>style</span>.<span style=color:#a6e22e>innerText</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;b { font-weight: bolder; color: red; }&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>shadowRoot</span>.<span style=color:#a6e22e>appendChild</span>(<span style=color:#a6e22e>style</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>inner</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>createElement</span>(<span style=color:#e6db74>&#39;b&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>inner</span>.<span style=color:#a6e22e>innerHTML</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;I&#39;m bolder in the shadows&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>shadowRoot</span>.<span style=color:#a6e22e>appendChild</span>(<span style=color:#a6e22e>inner</span>);
</span></span></code></pre></div><p>上面代码添加的样式，只会影响 Shadow DOM 内的元素。</p><p>Custom Element 的 CSS 样式内部，<code>:root</code>表示这个根元素。比如，Custom Element 默认是行内元素，下面代码可以改成块级元素。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-css data-lang=css><span style=display:flex><span>:<span style=color:#a6e22e>host</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>block</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>:<span style=color:#a6e22e>host</span><span style=color:#f92672>([</span><span style=color:#f92672>disabled</span><span style=color:#f92672>])</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>opacity</span>: <span style=color:#ae81ff>0.5</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>注意，外部样式会覆盖掉<code>:host</code>的设置，比如下面的样式会覆盖<code>:host</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>my-element</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>inline-block</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>利用 CSS 的自定义属性，可以为 Custom Element 可以被覆盖的默认样式。下面是外部样式，<code>my-element</code>是 Custom Element。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>my-element</span> {
</span></span><span style=display:flex><span>    --background-color: <span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>#ff0000</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>然后，内部可以指定默认样式，用于用户没有指定颜色的情况。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-css data-lang=css><span style=display:flex><span>:<span style=color:#a6e22e>host</span> {
</span></span><span style=display:flex><span>    --background-color: <span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>#ffffff</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span>#container {
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>background-color</span>: <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>background<span style=color:#f92672>-</span><span style=color:#66d9ef>color</span>);
</span></span><span style=display:flex><span> }
</span></span></code></pre></div><p>下面的例子是为 Shadow DOM 加上独立的模板。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>id</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;nameTag&#34;</span>&gt;张三&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>template</span> <span style=color:#a6e22e>id</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;nameTagTemplate&#34;</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>style</span>&gt;
</span></span><span style=display:flex><span>        .<span style=color:#a6e22e>outer</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>border</span>: <span style=color:#ae81ff>2</span><span style=color:#66d9ef>px</span> <span style=color:#66d9ef>solid</span> <span style=color:#66d9ef>brown</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>style</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;outer&#34;</span>&gt;
</span></span><span style=display:flex><span>        &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;boilerplate&#34;</span>&gt;
</span></span><span style=display:flex><span>            Hi! My name is
</span></span><span style=display:flex><span>        &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>        &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;name&#34;</span>&gt;
</span></span><span style=display:flex><span>            Bob
</span></span><span style=display:flex><span>        &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>template</span>&gt;
</span></span></code></pre></div><p>上面代码是一个<code>div</code>元素和模板。接下来，就是要把模板应用到<code>div</code>元素上。</p><h3 id=html-import>HTML Import
<a class=header-anchor href=#html-import></a></h3><h4 id=基本操作>基本操作
<a class=header-anchor href=#%e5%9f%ba%e6%9c%ac%e6%93%8d%e4%bd%9c></a></h4><p>长久以来，网页可以加载外部的样式表、脚本、图片、多媒体，却无法方便地加载其他网页，iframe和ajax都只能提供部分的解决方案，且有很大的局限。HTML Import就是为了解决加载外部网页这个问题，而提出来的。</p><p>下面代码用于测试当前浏览器是否支持HTML Import。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>supportsImports</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;import&#39;</span> <span style=color:#66d9ef>in</span> document.<span style=color:#a6e22e>createElement</span>(<span style=color:#e6db74>&#39;link&#39;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>supportsImports</span>()) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 支持
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 不支持
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>HTML Import用于将外部的HTML文档加载进当前文档。我们可以将组件的HTML、CSS、JavaScript封装在一个文件里，然后使用下面的代码插入需要使用该组件的网页。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>link</span> <span style=color:#a6e22e>rel</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;import&#34;</span> <span style=color:#a6e22e>href</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;dialog.html&#34;</span>&gt;
</span></span></code></pre></div><p>上面代码在网页中插入一个对话框组件，该组建封装在<code>dialog.html</code>文件。注意，dialog.html文件中的样式和JavaScript脚本，都对所插入的整个网页有效。</p><p>假定A网页通过HTML Import加载了B网页，即B是一个组件，那么B网页的样式表和脚本，对A网页也有效（准确得说，只有style标签中的样式对A网页有效，link标签加载的样式表对A网页无效）。所以可以把多个样式表和脚本，都放在B网页中，都从那里加载。这对大型的框架，是很方便的加载方法。</p><p>如果B与A不在同一个域，那么A所在的域必须打开CORS。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span><span style=color:#75715e>&lt;!-- example.com必须打开CORS --&gt;</span>
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>link</span> <span style=color:#a6e22e>rel</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;import&#34;</span> <span style=color:#a6e22e>href</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;http://example.com/elements.html&#34;</span>&gt;
</span></span></code></pre></div><p>除了用link标签，也可以用JavaScript调用link元素，完成HTML Import。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>link</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>createElement</span>(<span style=color:#e6db74>&#39;link&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>link</span>.<span style=color:#a6e22e>rel</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;import&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>link</span>.<span style=color:#a6e22e>href</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;file.html&#39;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>link</span>.<span style=color:#a6e22e>onload</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>e</span>) {...};
</span></span><span style=display:flex><span><span style=color:#a6e22e>link</span>.<span style=color:#a6e22e>onerror</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>e</span>) {...};
</span></span><span style=display:flex><span>document.<span style=color:#a6e22e>head</span>.<span style=color:#a6e22e>appendChild</span>(<span style=color:#a6e22e>link</span>);
</span></span></code></pre></div><p>HTML Import加载成功时，会在link元素上触发load事件，加载失败时（比如404错误）会触发error事件，可以对这两个事件指定回调函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>script</span> <span style=color:#a6e22e>async</span>&gt;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>handleLoad</span>(<span style=color:#a6e22e>e</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;Loaded import: &#39;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>href</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>handleError</span>(<span style=color:#a6e22e>e</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;Error loading import: &#39;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>href</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>script</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>link</span> <span style=color:#a6e22e>rel</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;import&#34;</span> <span style=color:#a6e22e>href</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;file.html&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>onload</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;handleLoad(event)&#34;</span> <span style=color:#a6e22e>onerror</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;handleError(event)&#34;</span>&gt;
</span></span></code></pre></div><p>上面代码中，handleLoad和handleError函数的定义，必须在link元素的前面。因为浏览器元素遇到link元素时，立刻解析并加载外部网页（同步操作），如果这时没有对这两个函数定义，就会报错。</p><p>HTML Import是同步加载，会阻塞当前网页的渲染，这主要是为了样式表的考虑，因为外部网页的样式表对当前网页也有效。如果想避免这一点，可以为link元素加上async属性。当然，这也意味着，如果外部网页定义了组件，就不能立即使用了，必须等HTML Import完成，才能使用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>link</span> <span style=color:#a6e22e>rel</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;import&#34;</span> <span style=color:#a6e22e>href</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/path/to/import_that_takes_5secs.html&#34;</span> <span style=color:#a6e22e>async</span>&gt;
</span></span></code></pre></div><p>但是，HTML Import不会阻塞当前网页的解析和脚本执行（即阻塞渲染）。这意味着在加载的同时，主页面的脚本会继续执行。</p><p>最后，HTML Import支持多重加载，即被加载的网页同时又加载其他网页。如果这些网页都重复加载同一个外部脚本，浏览器只会抓取并执行一次该脚本。比如，A网页加载了B网页，它们各自都需要加载jQuery，浏览器只会加载一次jQuery。</p><h4 id=脚本的执行>脚本的执行
<a class=header-anchor href=#%e8%84%9a%e6%9c%ac%e7%9a%84%e6%89%a7%e8%a1%8c></a></h4><p>外部网页的内容，并不会自动显示在当前网页中，它只是储存在浏览器中，等到被调用的时候才加载进入当前网页。为了加载网页网页，必须用DOM操作获取加载的内容。具体来说，就是使用link元素的import属性，来获取加载的内容。这一点与iframe完全不同。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>content</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;link[rel=&#34;import&#34;]&#39;</span>).<span style=color:#66d9ef>import</span>;
</span></span></code></pre></div><p>发生以下情况时，link.import属性为null。</p><ul><li>浏览器不支持HTML Import</li><li>link元素没有声明<code>rel="import"</code></li><li>link元素没有被加入DOM</li><li>link元素已经从DOM中移除</li><li>对方域名没有打开CORS</li></ul><p>下面代码用于从加载的外部网页选取id为template的元素，然后将其克隆后加入当前网页的DOM。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>el</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>linkElement</span>.<span style=color:#66d9ef>import</span>.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;##template&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>document.<span style=color:#a6e22e>body</span>.<span style=color:#a6e22e>appendChild</span>(<span style=color:#a6e22e>el</span>.<span style=color:#a6e22e>cloneNode</span>(<span style=color:#66d9ef>true</span>));
</span></span></code></pre></div><p>当前网页可以获取外部网页，反过来也一样，外部网页中的脚本，不仅可以获取本身的DOM，还可以获取link元素所在的当前网页的DOM。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 以下代码位于被加载（import）的外部网页
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// importDoc指向被加载的DOM
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>importDoc</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>currentScript</span>.<span style=color:#a6e22e>ownerDocument</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// mainDoc指向主文档的DOM
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>mainDoc</span> <span style=color:#f92672>=</span> document;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 将子页面的样式表添加主文档
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>styles</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>importDoc</span>.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;link[rel=&#34;stylesheet&#34;]&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>mainDoc</span>.<span style=color:#a6e22e>head</span>.<span style=color:#a6e22e>appendChild</span>(<span style=color:#a6e22e>styles</span>.<span style=color:#a6e22e>cloneNode</span>(<span style=color:#66d9ef>true</span>));
</span></span></code></pre></div><p>上面代码将所加载的外部网页的样式表，添加进当前网页。</p><p>被加载的外部网页的脚本是直接在当前网页的上下文执行，因为它的<code>window.document</code>指的是当前网页的document，而且它定义的函数可以被当前网页的脚本直接引用。</p><h4 id=web-component的封装>Web Component的封装
<a class=header-anchor href=#web-component%e7%9a%84%e5%b0%81%e8%a3%85></a></h4><p>对于Web Component来说，HTML Import的一个重要应用是在所加载的网页中，自动登记Custom Element。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>script</span>&gt;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 定义并登记&lt;say-hi&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>proto</span> <span style=color:#f92672>=</span> Object.<span style=color:#a6e22e>create</span>(<span style=color:#a6e22e>HTMLElement</span>.<span style=color:#a6e22e>prototype</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>proto</span>.<span style=color:#a6e22e>createdCallback</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>innerHTML</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Hello, &lt;b&gt;&#39;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>getAttribute</span>(<span style=color:#e6db74>&#39;name&#39;</span>) <span style=color:#f92672>||</span> <span style=color:#e6db74>&#39;?&#39;</span>) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;&lt;/b&gt;&#39;</span>;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    document.<span style=color:#a6e22e>registerElement</span>(<span style=color:#e6db74>&#39;say-hi&#39;</span>, {<span style=color:#a6e22e>prototype</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>proto</span>});
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>script</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>template</span> <span style=color:#a6e22e>id</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;t&#34;</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>style</span>&gt;
</span></span><span style=display:flex><span>        ::<span style=color:#a6e22e>content</span> <span style=color:#f92672>&gt;</span> <span style=color:#f92672>*</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>red</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>style</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>span</span>&gt;I&#39;m a shadow-element using Shadow DOM!&lt;/<span style=color:#f92672>span</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>content</span>&gt;&lt;/<span style=color:#f92672>content</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>template</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>script</span>&gt;
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>function</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>importDoc</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>currentScript</span>.<span style=color:#a6e22e>ownerDocument</span>; <span style=color:#75715e>//指向被加载的网页
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 定义并登记&lt;shadow-element&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>proto2</span> <span style=color:#f92672>=</span> Object.<span style=color:#a6e22e>create</span>(<span style=color:#a6e22e>HTMLElement</span>.<span style=color:#a6e22e>prototype</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>proto2</span>.<span style=color:#a6e22e>createdCallback</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>template</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>importDoc</span>.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;##t&#39;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>clone</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>importNode</span>(<span style=color:#a6e22e>template</span>.<span style=color:#a6e22e>content</span>, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>createShadowRoot</span>();
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>appendChild</span>(<span style=color:#a6e22e>clone</span>);
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        document.<span style=color:#a6e22e>registerElement</span>(<span style=color:#e6db74>&#39;shadow-element&#39;</span>, {<span style=color:#a6e22e>prototype</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>proto2</span>});
</span></span><span style=display:flex><span>    })();
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>script</span>&gt;
</span></span></code></pre></div><p>上面代码定义并登记了两个元素：&lt;say-hi>和&lt;shadow-element>。在主页面使用这两个元素，非常简单。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>head</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>link</span> <span style=color:#a6e22e>rel</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;import&#34;</span> <span style=color:#a6e22e>href</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;elements.html&#34;</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>head</span>&gt;
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>body</span>&gt;
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>say-hi</span> <span style=color:#a6e22e>name</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Eric&#34;</span>&gt;&lt;/<span style=color:#f92672>say-hi</span>&gt;
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>shadow-element</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span>&gt;( I&#39;m in the light dom )&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>shadow-element</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>body</span>&gt;
</span></span></code></pre></div><p>不难想到，这意味着HTML Import使得Web Component变得可分享了，其他人只要拷贝<code>elements.html</code>，就可以在自己的页面中使用了。</p><h3 id=polymerjs>Polymer.js
<a class=header-anchor href=#polymerjs></a></h3><p>Web Components是非常新的技术，为了让老式浏览器也能使用，Google推出了一个函数库
<a href=http://www.polymer-project.org/ title=Polymer.js rel="noopener external nofollow noreferrer" target=_blank class=exturl>Polymer.js
<i class="fa fa-external-link-alt"></i>
</a>。这个库不仅可以帮助开发者，定义自己的网页元素，还提供许多预先制作好的组件，可以直接使用。</p><h4 id=直接使用的组件>直接使用的组件
<a class=header-anchor href=#%e7%9b%b4%e6%8e%a5%e4%bd%bf%e7%94%a8%e7%9a%84%e7%bb%84%e4%bb%b6></a></h4><p>Polymer.js提供的组件，可以直接插入网页，比如下面的google-map。。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>script</span> <span style=color:#a6e22e>src</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;components/platform/platform.js&#34;</span>&gt;&lt;/<span style=color:#f92672>script</span>&gt;
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>link</span> <span style=color:#a6e22e>rel</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;import&#34;</span> <span style=color:#a6e22e>href</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;google-map.html&#34;</span>&gt;
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>google-map</span> <span style=color:#a6e22e>lat</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;37.790&#34;</span> <span style=color:#a6e22e>long</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;-122.390&#34;</span>&gt;&lt;/<span style=color:#f92672>google-map</span>&gt;
</span></span></code></pre></div><p>再比如，在网页中插入一个时钟，可以直接使用下面的标签。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>polymer-ui-clock</span>&gt;&lt;/<span style=color:#f92672>polymer-ui-clock</span>&gt;
</span></span></code></pre></div><p>自定义标签与其他标签的用法完全相同，也可以使用CSS指定它的样式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>polymer-ui-clock</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>320</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>height</span>: <span style=color:#ae81ff>320</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>inline-block</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>background</span>: url(<span style=color:#e6db74>&#34;../assets/glass.png&#34;</span>) <span style=color:#66d9ef>no-repeat</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>background-size</span>: <span style=color:#66d9ef>cover</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>border</span>: <span style=color:#ae81ff>4</span><span style=color:#66d9ef>px</span> <span style=color:#66d9ef>solid</span> rgba(<span style=color:#ae81ff>32</span>, <span style=color:#ae81ff>32</span>, <span style=color:#ae81ff>32</span>, <span style=color:#ae81ff>0.3</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=安装-1>安装
<a class=header-anchor href=#%e5%ae%89%e8%a3%85-1></a></h4><p>如果使用bower安装，至少需要安装platform和core components这两个核心部分。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>bower install --save Polymer/platform
</span></span><span style=display:flex><span>bower install --save Polymer/polymer
</span></span></code></pre></div><p>你还可以安装所有预先定义的界面组件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>bower install Polymer/core-elements
</span></span><span style=display:flex><span>bower install Polymer/polymer-ui-elements
</span></span></code></pre></div><p>还可以只安装单个组件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>bower install Polymer/polymer-ui-accordion
</span></span></code></pre></div><p>这时，组件根目录下的bower.json，会指明该组件的依赖的模块，这些模块会被自动安装。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;name&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;polymer-ui-accordion&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;private&#34;</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;dependencies&#34;</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;polymer&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Polymer/polymer##0.2.0&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;polymer-selector&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Polymer/polymer-selector##0.2.0&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;polymer-ui-collapsible&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Polymer/polymer-ui-collapsible##0.2.0&#34;</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;version&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;0.2.0&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=自定义组件>自定义组件
<a class=header-anchor href=#%e8%87%aa%e5%ae%9a%e4%b9%89%e7%bb%84%e4%bb%b6></a></h4><p>下面是一个最简单的自定义组件的例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>link</span> <span style=color:#a6e22e>rel</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;import&#34;</span> <span style=color:#a6e22e>href</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;../bower_components/polymer/polymer.html&#34;</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>polymer-element</span> <span style=color:#a6e22e>name</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;lorem-element&#34;</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>template</span>&gt;
</span></span><span style=display:flex><span>        &lt;<span style=color:#f92672>p</span>&gt;Lorem ipsum&lt;/<span style=color:#f92672>p</span>&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>template</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>polymer-element</span>&gt;
</span></span></code></pre></div><p>上面代码定义了lorem-element组件。它分成三个部分。</p><p><strong>（1）import命令</strong></p><p>import命令表示载入核心模块</p><p><strong>（2）polymer-element标签</strong></p><p>polymer-element标签定义了组件的名称（注意，组件名称中必须包含连字符）。它还可以使用extends属性，表示组件基于某种网页元素。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>polymer-element</span> <span style=color:#a6e22e>name</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;w3c-disclosure&#34;</span> <span style=color:#a6e22e>extends</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;button&#34;</span>&gt;
</span></span></code></pre></div><p><strong>（3）template标签</strong></p><p>template标签定义了网页元素的模板。</p><h4 id=组件的使用方法>组件的使用方法
<a class=header-anchor href=#%e7%bb%84%e4%bb%b6%e7%9a%84%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95></a></h4><p>在调用组件的网页中，首先加载polymer.js库和组件文件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>script</span> <span style=color:#a6e22e>src</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;components/platform/platform.js&#34;</span>&gt;&lt;/<span style=color:#f92672>script</span>&gt;
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>link</span> <span style=color:#a6e22e>rel</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;import&#34;</span> <span style=color:#a6e22e>href</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;w3c-disclosure.html&#34;</span>&gt;
</span></span></code></pre></div><p>然后，分成两种情况。如果组件不基于任何现有的HTML网页元素（即定义的时候没有使用extends属性），则可以直接使用组件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>lorem-element</span>&gt;&lt;/<span style=color:#f92672>lorem-element</span>&gt;
</span></span></code></pre></div><p>这时网页上就会显示一行字“Lorem ipsum”。</p><p>如果组件是基于（extends）现有的网页元素，则必须在该种元素上使用is属性指定组件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>&lt;button is=&#34;w3c-disclosure&#34;&gt;Expand section 1&lt;/button&gt;
</span></span></code></pre></div><h3 id=参考链接-12>参考链接
<a class=header-anchor href=#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5-12></a></h3><ul><li><a href=https://hacks.mozilla.org/2018/11/the-power-of-web-components/ title="The Power of Web Components" rel="noopener external nofollow noreferrer" target=_blank class=exturl>The Power of Web Components
<i class="fa fa-external-link-alt"></i>
</a>, Potch</li><li>Todd Motto,
<a href=http://toddmotto.com/web-components-concepts-shadow-dom-imports-templates-custom-elements/ title="Web Components and concepts, ShadowDOM, imports, templates, custom elements" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Web Components and concepts, ShadowDOM, imports, templates, custom elements
<i class="fa fa-external-link-alt"></i></a></li><li>Dominic Cooney,
<a href=http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/ title="Shadow DOM 101" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Shadow DOM 101
<i class="fa fa-external-link-alt"></i></a></li><li>Eric Bidelman,
<a href=http://www.html5rocks.com/en/tutorials/webcomponents/template/ title="HTML&amp;rsquo;s New Template Tag" rel="noopener external nofollow noreferrer" target=_blank class=exturl>HTML&rsquo;s New Template Tag
<i class="fa fa-external-link-alt"></i></a></li><li>Rey Bango,
<a href=http://code.tutsplus.com/tutorials/using-polymer-to-create-web-components--cms-20475 title="Using Polymer to Create Web Components" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Using Polymer to Create Web Components
<i class="fa fa-external-link-alt"></i></a></li><li>Cédric Trévisan, Building an Accessible Disclosure Button – using Web Components](
<a href=http://blog.paciellogroup.com/2014/06/accessible-disclosure-button-using-web-components/ title=http://blog.paciellogroup.com/2014/06/accessible-disclosure-button-using-web-components/ rel="noopener external nofollow noreferrer" target=_blank class=exturl>http://blog.paciellogroup.com/2014/06/accessible-disclosure-button-using-web-components/
<i class="fa fa-external-link-alt"></i>
</a>)</li><li>Eric Bidelman,
<a href=http://www.html5rocks.com/en/tutorials/webcomponents/customelements/ title="Custom Elements: defining new elements in HTML" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Custom Elements: defining new elements in HTML
<i class="fa fa-external-link-alt"></i></a></li><li>Eric Bidelman,
<a href=http://www.html5rocks.com/en/tutorials/webcomponents/imports/ title="HTML Imports" rel="noopener external nofollow noreferrer" target=_blank class=exturl>HTML Imports
<i class="fa fa-external-link-alt"></i></a></li><li>TJ VanToll,
<a href=http://developer.telerik.com/featured/web-components-ready-production/ title="Why Web Components Are Ready For Production" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Why Web Components Are Ready For Production
<i class="fa fa-external-link-alt"></i></a></li><li>Chris Bateman,
<a href=http://cbateman.com/blog/a-no-nonsense-guide-to-web-components-part-1-the-specs/ title="A No-Nonsense Guide to Web Components, Part 1: The Specs" rel="noopener external nofollow noreferrer" target=_blank class=exturl>A No-Nonsense Guide to Web Components, Part 1: The Specs
<i class="fa fa-external-link-alt"></i></a></li><li><a href=https://blog.usejournal.com/web-components-will-replace-your-frontend-framework-3b17a580831c title="Web Components will replace your frontend framework" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Web Components will replace your frontend framework
<i class="fa fa-external-link-alt"></i>
</a>, Danny Moerkerke</li><li><a href=https://developers.google.com/web/fundamentals/web-components/customelements##extend title="Custom Elements v1: Reusable Web Components" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Custom Elements v1: Reusable Web Components
<i class="fa fa-external-link-alt"></i>
</a>, Eric Bidelman</li></ul><h2 id=websocket>WebSocket
<a class=header-anchor href=#websocket></a></h2><p>WebSocket 是一种网络通信协议，很多高级功能都需要它。</p><p>初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？</p><p>答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。HTTP 协议的这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用“轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。</p><p>轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。</p><h3 id=简介-5>简介
<a class=header-anchor href=#%e7%ae%80%e4%bb%8b-5></a></h3><p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。</p><p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。WebSocket 允许服务器端与客户端进行全双工（full-duplex）的通信。举例来说，HTTP 协议有点像发电子邮件，发出后必须等待对方回信；WebSocket 则是像打电话，服务器端和客户端可以同时向对方发送数据，它们之间存着一条持续打开的数据通道。</p><p>其他特点包括：</p><p>（1）建立在 TCP 协议之上，服务器端的实现比较容易。</p><p>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</p><p>（3）数据格式比较轻量，性能开销小，通信高效。</p><p>（4）可以发送文本，也可以发送二进制数据。</p><p>（5）没有同源限制，客户端可以与任意服务器通信，完全可以取代 Ajax。</p><p>（6）协议标识符是<code>ws</code>（如果加密，则为<code>wss</code>，对应 HTTPS 协议），服务器网址就是 URL。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html><span style=display:flex><span>ws://example.com:80/some/path
</span></span></code></pre></div><h3 id=websocket-握手>WebSocket 握手
<a class=header-anchor href=#websocket-%e6%8f%a1%e6%89%8b></a></h3><p>浏览器发出的 WebSocket 握手请求类似于下面的样子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#a6e22e>GET</span> / <span style=color:#66d9ef>HTTP</span><span style=color:#f92672>/</span><span style=color:#ae81ff>1.1</span>
</span></span><span style=display:flex><span>Connection<span style=color:#f92672>:</span> <span style=color:#ae81ff>Upgrade</span>
</span></span><span style=display:flex><span>Upgrade<span style=color:#f92672>:</span> <span style=color:#ae81ff>websocket</span>
</span></span><span style=display:flex><span>Host<span style=color:#f92672>:</span> <span style=color:#ae81ff>example.com</span>
</span></span><span style=display:flex><span>Origin<span style=color:#f92672>:</span> <span style=color:#ae81ff>null</span>
</span></span><span style=display:flex><span>Sec-WebSocket-Key<span style=color:#f92672>:</span> <span style=color:#ae81ff>sN9cRrP/n9NdMgdcy2VJFQ==</span>
</span></span><span style=display:flex><span>Sec-WebSocket-Version<span style=color:#f92672>:</span> <span style=color:#ae81ff>13</span>
</span></span></code></pre></div><p>上面的头信息之中，有一个 HTTP 头是<code>Upgrade</code>。HTTP1.1 协议规定，<code>Upgrade</code>字段表示将通信协议从<code>HTTP/1.1</code>转向该字段指定的协议。<code>Connection</code>字段表示浏览器通知服务器，如果可以的话，就升级到 WebSocket 协议。<code>Origin</code>字段用于提供请求发出的域名，供服务器验证是否许可的范围内（服务器也可以不验证）。<code>Sec-WebSocket-Key</code>则是用于握手协议的密钥，是 Base64 编码的16字节随机字符串。</p><p>服务器的 WebSocket 回应如下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#66d9ef>HTTP</span><span style=color:#f92672>/</span><span style=color:#ae81ff>1.1</span> <span style=color:#ae81ff>101</span> <span style=color:#a6e22e>Switching Protocols</span>
</span></span><span style=display:flex><span>Connection<span style=color:#f92672>:</span> <span style=color:#ae81ff>Upgrade</span>
</span></span><span style=display:flex><span>Upgrade<span style=color:#f92672>:</span> <span style=color:#ae81ff>websocket</span>
</span></span><span style=display:flex><span>Sec-WebSocket-Accept<span style=color:#f92672>:</span> <span style=color:#ae81ff>fFBooB7FAkLlXgRSz0BT3v4hq5s=</span>
</span></span><span style=display:flex><span>Sec-WebSocket-Origin<span style=color:#f92672>:</span> <span style=color:#ae81ff>null</span>
</span></span><span style=display:flex><span>Sec-WebSocket-Location<span style=color:#f92672>:</span> <span style=color:#ae81ff>ws://example.com/</span>
</span></span></code></pre></div><p>上面代码中，服务器同样用<code>Connection</code>字段通知浏览器，需要改变协议。<code>Sec-WebSocket-Accept</code>字段是服务器在浏览器提供的<code>Sec-WebSocket-Key</code>字符串后面，添加
<a href=http://tools.ietf.org/html/rfc6455 title=RFC6456 rel="noopener external nofollow noreferrer" target=_blank class=exturl>RFC6456
<i class="fa fa-external-link-alt"></i></a> 标准规定的“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”字符串，然后再取 SHA-1 的哈希值。浏览器将对这个值进行验证，以证明确实是目标服务器回应了 WebSocket 请求。<code>Sec-WebSocket-Location</code>字段表示进行通信的 WebSocket 网址。</p><p>完成握手以后，WebSocket 协议就在 TCP 协议之上，开始传送数据。</p><h3 id=客户端的简单示例>客户端的简单示例
<a class=header-anchor href=#%e5%ae%a2%e6%88%b7%e7%ab%af%e7%9a%84%e7%ae%80%e5%8d%95%e7%a4%ba%e4%be%8b></a></h3><p>WebSocket 的用法相当简单。</p><p>下面是一个网页脚本的例子，基本上一眼就能明白。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ws</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>WebSocket</span>(<span style=color:#e6db74>&#39;wss://echo.websocket.org&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ws</span>.<span style=color:#a6e22e>onopen</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>evt</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;Connection open ...&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ws</span>.<span style=color:#a6e22e>send</span>(<span style=color:#e6db74>&#39;Hello WebSockets!&#39;</span>);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ws</span>.<span style=color:#a6e22e>onmessage</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>evt</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;Received Message: &#39;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>evt</span>.<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ws</span>.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ws</span>.<span style=color:#a6e22e>onclose</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>evt</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;Connection closed.&#39;</span>);
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=客户端-api-1>客户端 API
<a class=header-anchor href=#%e5%ae%a2%e6%88%b7%e7%ab%af-api-1></a></h3><p>浏览器对 WebSocket 协议的处理，无非就是三件事。</p><ul><li>建立连接和断开连接</li><li>发送数据和接收数据</li><li>处理错误</li></ul><h4 id=构造函数-websocket>构造函数 WebSocket
<a class=header-anchor href=#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0-websocket></a></h4><p><code>WebSocket</code>对象作为一个构造函数，用于新建<code>WebSocket</code>实例。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ws</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>WebSocket</span>(<span style=color:#e6db74>&#39;ws://localhost:8080&#39;</span>);
</span></span></code></pre></div><p>执行上面语句之后，客户端就会与服务器进行连接。</p><h4 id=websocketreadystate>webSocket.readyState
<a class=header-anchor href=#websocketreadystate></a></h4><p><code>readyState</code>属性返回实例对象的当前状态，共有四种。</p><ul><li>CONNECTING：值为0，表示正在连接。</li><li>OPEN：值为1，表示连接成功，可以通信了。</li><li>CLOSING：值为2，表示连接正在关闭。</li><li>CLOSED：值为3，表示连接已经关闭，或者打开连接失败。</li></ul><p>下面是一个示例。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>switch</span> (<span style=color:#a6e22e>ws</span>.<span style=color:#a6e22e>readyState</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>WebSocket</span>.<span style=color:#a6e22e>CONNECTING</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// do something
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>WebSocket</span>.<span style=color:#a6e22e>OPEN</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// do something
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>WebSocket</span>.<span style=color:#a6e22e>CLOSING</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// do something
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>WebSocket</span>.<span style=color:#a6e22e>CLOSED</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// do something
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// this never happens
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=websocketonopen>webSocket.onopen
<a class=header-anchor href=#websocketonopen></a></h4><p>实例对象的<code>onopen</code>属性，用于指定连接成功后的回调函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>ws</span>.<span style=color:#a6e22e>onopen</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> () {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ws</span>.<span style=color:#a6e22e>send</span>(<span style=color:#e6db74>&#39;Hello Server!&#39;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果要指定多个回调函数，可以使用<code>addEventListener</code>方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>ws</span>.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;open&#39;</span>, <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>event</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ws</span>.<span style=color:#a6e22e>send</span>(<span style=color:#e6db74>&#39;Hello Server!&#39;</span>);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h4 id=websocketonclose>webSocket.onclose
<a class=header-anchor href=#websocketonclose></a></h4><p>实例对象的<code>onclose</code>属性，用于指定连接关闭后的回调函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>ws</span>.<span style=color:#a6e22e>onclose</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>event</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>code</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>code</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>reason</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>reason</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>wasClean</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>wasClean</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// handle close event
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ws</span>.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#34;close&#34;</span>, <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>event</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>code</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>code</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>reason</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>reason</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>wasClean</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>wasClean</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// handle close event
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>});
</span></span></code></pre></div><h4 id=websocketonmessage>webSocket.onmessage
<a class=header-anchor href=#websocketonmessage></a></h4><p>实例对象的<code>onmessage</code>属性，用于指定收到服务器数据后的回调函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>ws</span>.<span style=color:#a6e22e>onmessage</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>event</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>data</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 处理数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ws</span>.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#34;message&#34;</span>, <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>event</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>data</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 处理数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>});
</span></span></code></pre></div><p>注意，服务器数据可能是文本，也可能是二进制数据（<code>blob</code>对象或<code>Arraybuffer</code>对象）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>ws</span>.<span style=color:#a6e22e>onmessage</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>event</span>){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>typeOf</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>data</span> <span style=color:#f92672>===</span> String) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;Received data string&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>data</span> <span style=color:#66d9ef>instanceof</span> <span style=color:#a6e22e>ArrayBuffer</span>){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>buffer</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>data</span>;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;Received arraybuffer&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>除了动态判断收到的数据类型，也可以使用<code>binaryType</code>属性，显式指定收到的二进制数据类型。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 收到的是 blob 数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>ws</span>.<span style=color:#a6e22e>binaryType</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;blob&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>ws</span>.<span style=color:#a6e22e>onmessage</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>e</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>size</span>);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 收到的是 ArrayBuffer 数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>ws</span>.<span style=color:#a6e22e>binaryType</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;arraybuffer&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>ws</span>.<span style=color:#a6e22e>onmessage</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>e</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>byteLength</span>);
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=websocketsend>webSocket.send()
<a class=header-anchor href=#websocketsend></a></h4><p>实例对象的<code>send()</code>方法用于向服务器发送数据。</p><p>发送文本的例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>ws</span>.<span style=color:#a6e22e>send</span>(<span style=color:#e6db74>&#39;your message&#39;</span>);
</span></span></code></pre></div><p>发送 Blob 对象的例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>file</span> <span style=color:#f92672>=</span> document
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;input[type=&#34;file&#34;]&#39;</span>)
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>files</span>[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span><span style=color:#a6e22e>ws</span>.<span style=color:#a6e22e>send</span>(<span style=color:#a6e22e>file</span>);
</span></span></code></pre></div><p>发送 ArrayBuffer 对象的例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// Sending canvas ImageData as ArrayBuffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>img</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>canvas_context</span>.<span style=color:#a6e22e>getImageData</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>400</span>, <span style=color:#ae81ff>320</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>binary</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Uint8Array</span>(<span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>length</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>length</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>binary</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>data</span>[<span style=color:#a6e22e>i</span>];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>ws</span>.<span style=color:#a6e22e>send</span>(<span style=color:#a6e22e>binary</span>.<span style=color:#a6e22e>buffer</span>);
</span></span></code></pre></div><h4 id=websocketbufferedamount>webSocket.bufferedAmount
<a class=header-anchor href=#websocketbufferedamount></a></h4><p>实例对象的<code>bufferedAmount</code>属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ArrayBuffer</span>(<span style=color:#ae81ff>10000000</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>socket</span>.<span style=color:#a6e22e>send</span>(<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>socket</span>.<span style=color:#a6e22e>bufferedAmount</span> <span style=color:#f92672>===</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 发送完毕
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 发送还没结束
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h4 id=websocketonerror>webSocket.onerror
<a class=header-anchor href=#websocketonerror></a></h4><p>实例对象的<code>onerror</code>属性，用于指定报错时的回调函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>socket</span>.<span style=color:#a6e22e>onerror</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>event</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// handle error event
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>socket</span>.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#34;error&#34;</span>, <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>event</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// handle error event
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>});
</span></span></code></pre></div><h3 id=websocket-服务器>WebSocket 服务器
<a class=header-anchor href=#websocket-%e6%9c%8d%e5%8a%a1%e5%99%a8></a></h3><p>WebSocket 协议需要服务器支持。各种服务器的实现，可以查看维基百科的
<a href=https://en.wikipedia.org/wiki/Comparison_of_WebSocket_implementations title=列表 rel="noopener external nofollow noreferrer" target=_blank class=exturl>列表
<i class="fa fa-external-link-alt"></i>
</a>。</p><p>常用的 Node 实现有以下三种。</p><ul><li><a href=https://github.com/uWebSockets/uWebSockets title=µWebSockets rel="noopener external nofollow noreferrer" target=_blank class=exturl>µWebSockets
<i class="fa fa-external-link-alt"></i></a></li><li><a href=http://socket.io/ title=Socket.IO rel="noopener external nofollow noreferrer" target=_blank class=exturl>Socket.IO
<i class="fa fa-external-link-alt"></i></a></li><li><a href=https://github.com/theturtle32/WebSocket-Node title=WebSocket-Node rel="noopener external nofollow noreferrer" target=_blank class=exturl>WebSocket-Node
<i class="fa fa-external-link-alt"></i></a></li></ul><p>具体的用法请查看它们的文档，本教程不详细介绍了。</p><h3 id=参考链接-13>参考链接
<a class=header-anchor href=#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5-13></a></h3><ul><li>Ryan Stewart,
<a href=http://www.adobe.com/devnet/html5/articles/real-time-data-exchange-in-html5-with-websockets.html title="Real-time data exchange in HTML5 with WebSockets" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Real-time data exchange in HTML5 with WebSockets
<i class="fa fa-external-link-alt"></i></a></li><li>Malte Ubl & Eiji Kitamura，
<a href=https://www.html5rocks.com/en/tutorials/websockets/basics/ title="Introducing WebSockets: Bringing Sockets to the Web" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Introducing WebSockets: Bringing Sockets to the Web
<i class="fa fa-external-link-alt"></i></a></li><li>Jack Lawson,
<a href=http://buildnewgames.com/websockets/ title="WebSockets: A Guide" rel="noopener external nofollow noreferrer" target=_blank class=exturl>WebSockets: A Guide
<i class="fa fa-external-link-alt"></i></a></li><li>Michael W.,
<a href=http://codular.com/node-web-sockets title="Starting with Node and Web Sockets" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Starting with Node and Web Sockets
<i class="fa fa-external-link-alt"></i></a></li><li>Jesse Cravens,
<a href=http://tech.pro/tutorial/1167/introduction-to-websockets title="Introduction to WebSockets" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Introduction to WebSockets
<i class="fa fa-external-link-alt"></i></a></li><li>Matt West,
<a href=http://blog.teamtreehouse.com/an-introduction-to-websockets title="An Introduction to WebSockets" rel="noopener external nofollow noreferrer" target=_blank class=exturl>An Introduction to WebSockets
<i class="fa fa-external-link-alt"></i></a></li><li>Maciej Sopyło,
<a href=http://net.tutsplus.com/tutorials/javascript-ajax/node-js-better-performance-with-socket-io-and-dot/ title="Node.js: Better Performance With Socket.IO and doT" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Node.js: Better Performance With Socket.IO and doT
<i class="fa fa-external-link-alt"></i></a></li><li>Jos Dirksen,
<a href=http://www.smartjava.org/content/capture-canvas-and-webgl-output-video-using-websockets title="Capture Canvas and WebGL output as video using websockets" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Capture Canvas and WebGL output as video using websockets
<i class="fa fa-external-link-alt"></i></a></li><li>Fionn Kellehe,
<a href=https://nodesource.com/blog/understanding-socketio title="Understanding Socket.IO" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Understanding Socket.IO
<i class="fa fa-external-link-alt"></i></a></li><li><a href=http://cjihrig.com/blog/how-to-use-websockets/ title="How to Use WebSockets" rel="noopener external nofollow noreferrer" target=_blank class=exturl>How to Use WebSockets
<i class="fa fa-external-link-alt"></i></a></li><li><a href=https://www.tutorialspoint.com/websockets/websockets_send_receive_messages.htm title="WebSockets - Send &amp;amp; Receive Messages" rel="noopener external nofollow noreferrer" target=_blank class=exturl>WebSockets - Send & Receive Messages
<i class="fa fa-external-link-alt"></i></a></li></ul></div><footer class=post-footer><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right alt=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
WebApi</li><li class=post-copyright-author><strong>本文作者：</strong>
爸比娃娃</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://blog.jiandan.cf/post/webapi.html title=WebApi>https://blog.jiandan.cf/post/webapi.html</a></li><li class=post-copyright-license><strong>版权声明：</strong>
本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"></div><div class="post-nav-prev post-nav-item"><a href=/post/Markdown.html rel=prev title=Markdown语法收藏>Markdown语法收藏
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=waline-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div id=gtranslate class=google-translate><i class="fa fa-language"></i><div id=google_translate_element></div></div><div class=copyright>&copy;
<span itemprop=copyrightYear>2005 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>爸比娃娃</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.102.3 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.5.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=vendors-list><a target=_blank href=https://vercel.com title=Vercel><img src=/imgs/img-lazy-loading.gif data-src=/imgs/vendors/vercel.svg alt=Vercel></a>
<a target=_blank href=https://Netlify.com title=Netlify>Netlify</a>
<span>提供云资源支持</span></div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"https://blog.jiandan.cf/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline"},"views":{"enable":true,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.5.3","waline":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o \n\n可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄\n(Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":"https://waline.jiandan.cf","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.0fb3547374c917d23a2e5f762b70f3698d20b46a01cc18c38f9c467aeffc99fc.js defer></script></body></html>